<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>OS_lab4</title>
      <link href="/2024/04/14/lab4-shi-yan-bao-gao/"/>
      <url>/2024/04/14/lab4-shi-yan-bao-gao/</url>
      
        <content type="html"><![CDATA[<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><blockquote><p>**Thinking4.1  **</p></blockquote><blockquote><p><strong>• 内核在保存现场的时候是如何避免破坏通用寄存器的？</strong></p></blockquote><p>在系统发生异常进入异常分发程序时，使用<code>SAVE_ALL</code>宏，①将用户现场保存到<strong>内核的异常栈KSTACKTOP</strong>，②使sp寄存器指向保存的<code>Trapframe</code>（P106）。这样保证了用户态的通用寄存器值不被改变，也能在内核中使用每个寄存器的值。</p><blockquote><p><strong>• 系统陷入内核调用后可以直接从当时的<code>$a0-$a3</code>参数寄存器中得到用户调用 msyscall留下的信息吗？</strong></p></blockquote><p>可以。因为在陷入内核、保存现场的过程中，寄存器$$ $a0-$a3$$中的值都没有被破坏。</p><blockquote><p><strong>• 我们是怎么做到让 sys 开头的函数“认为”我们提供了和用户调用 msyscall 时同样的参数的？</strong></p></blockquote><p>用户调用msyscall时传入的参数会被保存在$$ $a0-$a3$$寄存器和堆栈中。在 <code>do_syscall</code> 函数中，我们通过系统调用向量 <code>syscall_table</code> 选择系统调用函数后，在函数内调用了 <code>func(arg1, arg2, arg3, arg4, arg5);</code> 此处的 <code>arg</code>都来源于用户态中保存的参数寄存器和栈帧内。所以相当于调用了相同参数的函数。</p><blockquote><p><strong>• 内核处理系统调用的过程对 Trapframe 做了哪些更改？这种修改对应的用户态的变化是什么？</strong></p></blockquote><p>（1）<code>tf-&gt;regs[2] = func(arg1, arg2, arg3, arg4, arg5);</code> 更改了 $$$v0$$ 寄存器以保存系统调用执行后的返回值；<br>（2）<code>tf-&gt;cp0_epc += 4;</code> 更改了 <code>cp0_epc</code> 寄存器，使得返回用户态的执行系统调用的后一条指令。</p><blockquote><p>**Thinking4.2 **<br>思考 envid2env 函数: 为什么 envid2env 中需要判断 e-&gt;env_id != envid的情况？如果没有这步判断会发生什么情况？   </p></blockquote><p>由函数<code>mkenvid</code>，id低10位为该<code>env</code>在<code>envs</code>数组中的索引，高位是按序增大的数。如果一个<code>env</code>块已经被调度过，两次为其获取的<code>envid</code>低10位相同，高位不同。我们利用宏<code>ENVX (envid)</code>获取了<code>env</code>块只能保证低10位的id相同，没有对高位进行校验。因此<code>e-&gt;env_id != envid</code>可以防止取到已经失效的<code>env</code>块。</p><blockquote><p>**Thinking4.3 **</p><p>思考下面的问题，并对这个问题谈谈你的理解：请回顾 kern/env.c 文件 中 mkenvid() 函数的实现，该函数不会返回 0，请结合系统调用和 IPC 部分的实现与 envid2env() 函数的行为进行解释。 </p></blockquote><p>回顾<code>mkenvid</code>函数，我们生成的<code>envid</code>永远是大于0的。事实上0作为一个保留值，代表的是当前进程。也就是通过0这个特殊的envid，代表的是<strong>当前</strong>进程。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">envid2env</span><span class="token punctuation">(</span>u_int envid<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">Env</span> <span class="token operator">*</span><span class="token operator">*</span>penv<span class="token punctuation">,</span> <span class="token keyword">int</span> checkperm<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">struct</span> <span class="token class-name">Env</span> <span class="token operator">*</span>e<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>envid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token operator">*</span>penv <span class="token operator">=</span> curenv<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>e <span class="token operator">=</span> envs <span class="token operator">+</span> <span class="token function">ENVX</span> <span class="token punctuation">(</span>envid<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token comment">//omit...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>Thinking 4.4</strong><br>关于 fork 函数的两个返回值，下面说法正确的是：</p></blockquote><p>$$C.$$ fork 只在父进程中被调用了一次，在两个进程中各产生一个返回值</p><blockquote><p><strong>Thinking 4.5</strong> 我们并不应该对所有的用户空间页都使用 duppage 进行映射。那么究竟哪些用户空间页应该映射，哪些不应该呢？请结合 kern/env.c 中 env_init 函数进行的页面映射、 include/mmu.h 里的内存布局图以及本章的后续描述进行思考。</p></blockquote><p>需要被映射的页面只有<code>USTACKTOP</code>之下的部分。</p><img src="lab4%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/1fd2a62460cacf0d5989a47af5d7485.jpg" alt="1fd2a62460cacf0d5989a47af5d7485" style="zoom:30%;"><blockquote><p><strong>Thinking 4.6</strong> 在遍历地址空间存取页表项时你需要使用到 vpd 和 vpt 这两个指针，请参考 user/include/lib.h 中的相关定义，思考并回答这几个问题：</p><p>• vpt 和 vpd 的作用是什么？怎样使用它们？</p><p>• 从实现的角度谈一下为什么进程能够通过这种方式来存取自身的页表？</p><p>• 它们是如何体现自映射设计的？</p><p>• 进程能够通过这种方式来修改自己的页表项吗？</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">vpt</span> <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">volatile</span> Pte <span class="token operator">*</span><span class="token punctuation">)</span>UVPT<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">vpd</span> <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">volatile</span> Pde <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>UVPT <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token function">PDX</span><span class="token punctuation">(</span>UVPT<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> PGSHIFT<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><code>vpt</code> 指向了用户进程自身的<strong>用户页表基址</strong>，<code>vpd</code> 指向了用户进程的<strong>用户页目录基址</strong>。所以我们可以直接通过<code>vpt</code>和<code>vpd</code>访问到用户进程页表和页目录。对于给定的<code>vpn</code>（也就是<code>va</code>的高20位），我们可以通过<code>vpd[vpn&gt;&gt;10]</code>访问页目录项，<code>vpt[vpn]</code>访问页表项。</li><li><code>vpt</code>指向了<code>UVPT</code>，也就是用户地址空间的页表首地址。由自映射的实现，<code>(UVPT + (PDX(UVPT) &lt;&lt; PGSHIFT))</code>是页目录首地址。从而我们通过这两个指针访问自身的页表。</li><li>再解释一下自映射的实现，要想获取页目录的首地址，就要知道页目录作为一个页表所在整个1024个页表的索引，即通过<code>index = PDX(UVPT)</code>得知。然后想要再获取地址，只需要<code>基地址UVPT + index * PAGE_SIZE</code>。</li><li>不可以，进程页表由内核维护，在用户态是只读的，我们可以通过<code>syscall</code>对其修改。</li></ul><blockquote><p><strong>Thinking 4.7</strong>  在 <code>do_tlb_mod</code> 函数中，你可能注意到了一个向异常处理栈复制 <code>Trapframe</code> 运行现场的过程，请思考并回答这几个问题：</p><p>• 这里实现了一个支持类似于“异常重入”的机制，而在什么时候会出现这种“异常重入”？</p><p> • 内核为什么需要将异常的现场 <code>Trapframe</code> 复制到用户空间？</p></blockquote><ul><li><p>如果<strong>用户异常处理函数出错</strong>，就需要再次处理异常，同时由于没有关闭中断，所以若再次发生外部中断（时钟中断），也会触发异常的重入</p></li><li><p>因为异常的处理是在用户态进行的，而<strong>用户态只能访问用户空间（低2G空间）内的数据</strong>，所以需要将现场保存在用户空间。</p></li></ul><blockquote><p><strong>Thinking 4.8</strong> 在用户态处理页写入异常，相比于在内核态处理有什么优势？</p></blockquote><p>在用户态处理，相较于内核态处理最明显的区别就在于其省去了跳转进入内核态的繁琐操作，为频繁的跳转省去了大量时间。 其次在用户态处理，给用户自定义页写入异常处理函数的入口，使得操作系统的处理更多样性、更灵活。  </p><blockquote><p><strong>Thinking 4.9</strong> 请思考并回答以下几个问题：</p><p>• 为什么需要将 <code>syscall_set_tlb_mod_entry</code> 的调用放置在 <code>syscall_exofork</code> 之前？ </p></blockquote><blockquote><p>• 如果放置在写时复制保护机制完成之后会有怎样的效果？</p></blockquote><h2 id="难点分析"><a href="#难点分析" class="headerlink" title="难点分析"></a>难点分析</h2><h4 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h4><p><strong>用户空间和内核空间</strong></p><p>进程的地址空间分为两部分：用户空间(kuseg)和内核(kseg0, kseg1)空间。每个进程的<strong>用户空间通常通过页表映射到不同的物理页</strong>，但内核空间通常直接映射到<strong>固定</strong>的物理页或外设。</p><p>CPU在内核态下可以访问任何内存区域，而在用户态下则只能访问用户空间。</p><p><strong>进程和内核</strong></p><p>可以认为内核是存在于所有进程地址空间中的一段代码。</p><img src="lab4%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20240502115544365.png" alt="GuideBook pic4.1" style="zoom:50%;"><h4 id="debugf-函数"><a href="#debugf-函数" class="headerlink" title="debugf()函数:"></a><code>debugf()</code>函数:</h4><p>位于<code>user/lib/debugf.c</code>，注意<strong>user</strong>代表是是用户态的函数</p><p>这个函数负责：1 将参数转换为字符串 2 将字符串输出（<code>debug_output</code>函数）</p><ul><li><code>debug_output</code>函数调用了<strong>用户空间的<code>syscall_*</code>函数</strong>，该函数是<strong>用户</strong>包装函数</li><li><code>syscall_*</code>位于<code>user/lib/syscall_lib.c</code>，调用<code>msyscall</code>叶✌函数，【<strong>由此陷入内核态</strong>】。用户态的<code>syscall_*</code>函数和内核中的系统调用函数（<code>sys_*</code>）一一对应。</li></ul><p><strong>调用关系</strong>：<code>debugf -&gt; vdebugf -&gt; vprintfmt -&gt; debug_output -&gt; debug_flush -&gt; syscall_* -&gt; msyscall</code></p><ul><li>内核态中将异常分发到<code>handle_sys</code>函数，内核取得信息，执行对应的内核空间的系统调用函数（<code>sys_*</code>）</li><li>系统调用完成，并返回用户态，同时将返回值“传递”回用户态，从系统调用函数返回，回到用户程序 debugf 调用处。</li></ul><p><code>handle_sys -&gt; do_syscall -&gt; sys_*</code>，后两个函数位于<code>kern/syscall_all.c</code></p><h4 id="msyscall-函数"><a href="#msyscall-函数" class="headerlink" title="msyscall 函数:"></a><strong><code>msyscall</code> 函数:</strong></h4><p>位于<code>user/lib/syscall_wrap.S</code></p><p>只有一个<code>syscall</code>指令;</p><p>共6个参数，第一个参数是系统调用号，这些参数是系统调用时需要传递给内核的参数。</p><p>通过该syscall指令，陷入内核态（syscall 是一条用于执行系统调用的自陷指令，通过执行 syscall 指令，用户进程可以陷入到内核态，请求内核提供的服务）。</p><p>这时栈指针指向了内核空间保存的TrapFrame</p><p>———————–由此陷入内核态—————————</p><h4 id="handle-sys函数-【系统调用异常】的处理入口"><a href="#handle-sys函数-【系统调用异常】的处理入口" class="headerlink" title="handle_sys函数:【系统调用异常】的处理入口"></a><code>handle_sys</code>函数:【<strong>系统调用异常</strong>】的处理入口</h4><p>位于<code>kern/genex.S</code>。该函数包装了<code>do_syscall</code>函数（实际进行异常处理的C函数）</p><h4 id="do-syscall函数-内核的系统调用处理程序"><a href="#do-syscall函数-内核的系统调用处理程序" class="headerlink" title="do_syscall函数: 内核的系统调用处理程序"></a><code>do_syscall</code>函数: 内核的系统调用处理程序</h4><p>分别取出6个参数，根据sysno（系统调用号）取得相应的系统调用函数。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">tf<span class="token operator">-&gt;</span>regs<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">(</span>arg1<span class="token punctuation">,</span> arg2<span class="token punctuation">,</span> arg3<span class="token punctuation">,</span> arg4<span class="token punctuation">,</span> arg5<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>内核中的系统调用函数：<code>sys_*</code></strong></p><h4 id="用户态到内核态的传参"><a href="#用户态到内核态的传参" class="headerlink" title="用户态到内核态的传参"></a>用户态到内核态的传参</h4><p>明确：用户和内核都有自己的<strong>栈</strong>，即内核态执行汇编时，有自己专门的<code>stack_pointer</code>的位置，和用户态下<code>stack_pointer</code>的位置不一样。</p><p><strong>栈帧：</strong></p><p>进入函数体时会通过<strong>对栈指针做减法（压栈）</strong>，为该函数自身的局部变量、返回地址、调用函数的参数分配存储空间。这部分存储空间叫栈帧。</p><p>MIPS寄存器使用规范指出：寄存器 <code>$a0-$a3</code> 用于存放函数调用的前四个参数 （但在栈中仍然需要为其预留空间），剩余的参数仅存放在栈中。</p><p>例如MOS操作系统的<code>msyscall</code>，一共有 6 个参数。</p><p>【寄存器传参，栈仅预留空间】前 4 个参数会被 <code>syscall_*</code> 的函数分别存入 $$ $a0-$a3 $$寄存器 ，同时栈帧底部保留 16 字节的空间（不要求存入参数的值）。</p><p>【无寄存器传参，栈传参】后2个参数只会被存入在预留空间之上的 8 字节空间内，于是总共 24 字节的空间用于参数传递。</p><p>所以进入函数后，<code>sp</code>已经指向了<code>arg0</code>的位置（虽然是空的），如果这时我要<code>arg5</code>，通过<code>sp+4*5</code>即可取得。</p><h4 id="基础系统调用函数"><a href="#基础系统调用函数" class="headerlink" title="基础系统调用函数"></a>基础系统调用函数</h4><p><code>kern/syscall_all.c</code> 中定义了一 系列系统调用，它们就是 MOS 系统的基础系统调用。</p><h5 id="sys-mem-alloc："><a href="#sys-mem-alloc：" class="headerlink" title="sys_mem_alloc："></a><strong><code>sys_mem_alloc</code>：</strong></h5><p>给该用户程序显式分配物理内存。</p><p>一个进程请求将其运行空间中的某段地址与实际物理内存进行映射，从而可以通过该虚拟页面来对物理内存进行存取访问。</p><p><code>static inline int is_illegal_va_range(u_long va, u_int len)</code></p><h5 id="sys-mem-map"><a href="#sys-mem-map" class="headerlink" title="sys_mem_map"></a><code>sys_mem_map</code></h5><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">sys_mem_map</span><span class="token punctuation">(</span>u_int srcid<span class="token punctuation">,</span> u_int srcva<span class="token punctuation">,</span> u_int dstid<span class="token punctuation">,</span> u_int dstva<span class="token punctuation">,</span> u_int perm<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将源进程地址空间中的<strong>相应内存</strong>映射到目标进程的相应地址空间的相应虚拟内存中去。换句话说，<strong>此时两者共享一页物理内存</strong>。</p><p>最后调用<code>page_insert</code>，更改页表项权限为<code>perm</code>。</p><h4 id="进程间通信机制-IPC"><a href="#进程间通信机制-IPC" class="headerlink" title="进程间通信机制$$(IPC)$$"></a>进程间通信机制$$(IPC)$$</h4><p><strong><code>sys_ipc_recv</code></strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">sys_ipc_recv</span><span class="token punctuation">(</span>u_int dstva<span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>阻塞当前进程，直到收到信息。</p><p><img src="/lab4%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20240502121026171.png" alt="GuideBook pic4.4"></p><h4 id="fork的返回值"><a href="#fork的返回值" class="headerlink" title="fork的返回值"></a>fork的返回值</h4><p>子进程会从 <code>fork</code> 后的时刻开始执行，且具有和父进程不同的返回值。</p><p>父进程的返回值为子进程的 进程标识符<code>envid</code>，而子进程的返回值为 0。</p><p>结合<code>envid==0</code>代表是当前进程，因此<code>fork</code>返回值都为子进程的<code>envid</code>。</p><h4 id="写时复制机制-Copy-On-Write"><a href="#写时复制机制-Copy-On-Write" class="headerlink" title="写时复制机制 $$(Copy\ On\ Write)$$"></a>写时复制机制 $$(Copy\ On\ Write)$$</h4><p>我们可以在创建子进程时只是让子进程<strong>映射</strong>到和父进程相同的物理页。在 fork 时，我们只需将<strong>地址空间中的所有可写页</strong>标记为写时复制页面，使得在<strong>父进程或子进程</strong>对写时复制页面进行写入时，能够产生一种<strong>异常</strong>。  </p><h4 id="sys-exofork-系统调用函数"><a href="#sys-exofork-系统调用函数" class="headerlink" title="sys_exofork 系统调用函数"></a><code>sys_exofork</code> 系统调用函数</h4><p>位于<code>kern/syscall_all.c </code>，复制父进程的信息，【创建】一个子进程。</p><p>解决了返回值的问题。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">sys_exofork</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">struct</span> <span class="token class-name">Env</span> <span class="token operator">*</span>e<span class="token punctuation">;</span><span class="token comment">/* Step 1: Allocate a new env using 'env_alloc'. */</span><span class="token function">try</span><span class="token punctuation">(</span><span class="token function">env_alloc</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>e<span class="token punctuation">,</span> curenv<span class="token operator">-&gt;</span>env_id<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    e<span class="token operator">-&gt;</span>env_tf <span class="token operator">=</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Trapframe</span> <span class="token operator">*</span><span class="token punctuation">)</span>KSTACKTOP <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//注意这里不能用curenv-&gt;env_tf</span>e<span class="token operator">-&gt;</span>env_tf<span class="token punctuation">.</span>regs<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//$v0 = 0</span>e<span class="token operator">-&gt;</span>env_status <span class="token operator">=</span> ENV_NOT_RUNNABLE<span class="token punctuation">;</span>e<span class="token operator">-&gt;</span>env_pri <span class="token operator">=</span> curenv<span class="token operator">-&gt;</span>env_pri<span class="token punctuation">;</span><span class="token keyword">return</span> e<span class="token operator">-&gt;</span>env_id<span class="token punctuation">;</span> <span class="token comment">//系统调用在内核态返回的envid只传递给父进程</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="duppage-函数"><a href="#duppage-函数" class="headerlink" title="duppage 函数"></a><code>duppage</code> 函数</h4><p>位于<code>user/lib/fork.c</code><br>将地址空间中需要与子进程共享的页面映射给子进程。</p><p><code>vpt</code></p><p>1 <code>虚拟地址va &gt;&gt; 12 = 虚拟页号</code>，即在4MB的二级页表中属于第几个虚拟页；所以<code>addr = vpn &lt;&lt; PGSHIFT;</code></p><p>2 从表现上来看，<code>vpt</code> 是一个 <code>Pte</code> 类型的数组，其中按虚拟地址的顺序存储了所有的页表项。本质上，<code>vpt</code> 是用户空间中的地址，并且正是页表自映射时设置的基地址。所以可以通过<code>vpt[vpn]</code>获得所有的页表项。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">duppage</span><span class="token punctuation">(</span>u_int envid<span class="token punctuation">,</span> u_int vpn<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">int</span> r<span class="token punctuation">;</span>u_int addr<span class="token punctuation">;</span>u_int perm<span class="token punctuation">;</span><span class="token comment">//#define vpt ((const volatile Pte *)UVPT)</span>addr <span class="token operator">=</span> vpn <span class="token operator">&lt;&lt;</span> PGSHIFT<span class="token punctuation">;</span><span class="token comment">//按页对齐了</span>perm <span class="token operator">=</span> vpt<span class="token punctuation">[</span>vpn<span class="token punctuation">]</span> <span class="token operator">&amp;</span> <span class="token number">0xfff</span><span class="token punctuation">;</span><span class="token comment">//取页表项的内容，获得低12位</span><span class="token comment">//在用户态，我们不能直接修改页表项，因此需要通过系统调用来实现修改</span><span class="token comment">//int sys_mem_map(u_int srcid, u_int srcva,u_int dstid, u_int dstva, u_int perm)</span><span class="token keyword">int</span> flg <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>perm <span class="token operator">&amp;</span> PTE_D<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>perm <span class="token operator">&amp;</span> PTE_LIBRARY<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//对于可写的且不是共享的页，需要更新页表项权限。</span>perm <span class="token operator">=</span> <span class="token punctuation">(</span>perm <span class="token operator">&amp;</span> <span class="token operator">~</span>PTE_D<span class="token punctuation">)</span> <span class="token operator">|</span> PTE_COW<span class="token punctuation">;</span>flg <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token comment">//envid是child的</span><span class="token function">syscall_mem_map</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span>addr<span class="token punctuation">,</span> envid<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span>addr<span class="token punctuation">,</span> perm<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>flg<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">syscall_mem_map</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span> addr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span>addr<span class="token punctuation">,</span> perm<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>只有当一个页面是可写的(有<code>PTE_D</code>权限位)，且不是共享页面<code>PTE_LIBRARY</code>，则在父进程和子进程<strong>都需要加上 <code>PTE_COW </code>标志位</strong>， 同时取消 <code>PTE_D</code>，以实现写时复制保护。</p><p>需要注意的是，<strong>应该先将父进程将页映射到子进程，再对父进程自己权限的修改</strong>。如果先修改自己的权限位，则该页表就不再可写，这样的话就会发生 TLB Mod 异常，而不能实现父进程将页映射到子进程。</p><h4 id="fork-函数"><a href="#fork-函数" class="headerlink" title="fork 函数"></a><code>fork</code> 函数</h4><p>位于<code>user/lib/fork.c</code>，是一个用户态函数，包含若干原子的系统调用来完成期望功能。其中最核心的一个系统调用就是新进程的创建 <code>syscall_exofork</code>。  </p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>u_int child<span class="token punctuation">;</span>u_int i<span class="token punctuation">;</span><span class="token comment">/* Step 1: Set our TLB Mod user exception entry to 'cow_entry' if not done yet. */</span><span class="token keyword">if</span> <span class="token punctuation">(</span>env<span class="token operator">-&gt;</span>env_user_tlb_mod_entry <span class="token operator">!=</span> <span class="token punctuation">(</span>u_int<span class="token punctuation">)</span>cow_entry<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">try</span><span class="token punctuation">(</span><span class="token function">syscall_set_tlb_mod_entry</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> cow_entry<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* Step 2: Create a child env that's not ready to be scheduled. */</span>child <span class="token operator">=</span> <span class="token function">syscall_exofork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>child <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> env <span class="token operator">=</span> envs <span class="token operator">+</span> <span class="token function">ENVX</span><span class="token punctuation">(</span><span class="token function">syscall_getenvid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//子进程被创建后第一次调度是在fork函数中，这时需要对env指针更新，使其指向【子进程自己的】控制块</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//只遍历USTACKTOP之下的地址空间，因为其上的空间总是会被共享</span><span class="token keyword">for</span> <span class="token punctuation">(</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">VPN</span><span class="token punctuation">(</span>USTACKTOP<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>vpd<span class="token punctuation">[</span>i<span class="token operator">&gt;&gt;</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">&amp;</span> PTE_V<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>vpt<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&amp;</span> PTE_V<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">//先检查页目录项和页表项是否有效</span><span class="token function">duppage</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">//vpd是页目录项数组，i相当于地址高20位(i刻画了当前是第几个页表项，也就是vpn虚页号低12位是Offset)，因此我们取i的高10位作为**页目录**索引</span>    <span class="token function">try</span><span class="token punctuation">(</span><span class="token function">syscall_set_tlb_mod_entry</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> cow_entry<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">try</span><span class="token punctuation">(</span><span class="token function">syscall_set_env_status</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> ENV_RUNNABLE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> child<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="页写入异常-（TLB-Mod）"><a href="#页写入异常-（TLB-Mod）" class="headerlink" title="页写入异常$$（TLB\  Mod）$$"></a>页写入异常$$（TLB\  Mod）$$</h4><p>在 MIPS 中，当程序尝试写入的虚拟页对应的 TLB 项没有 <code>PTE_D</code> 标志时，会触发 <strong><code>TLB Mod</code>（页写入） 异常</strong>(Modify)，使系统陷入到内核中。</p><ul><li>我们在异常向量组中为其注册了一个处理函数 <code>handle_mod</code>，这一函数会跳转到 <code>kern/tlbex.c</code>中的 <code>do_tlb_mod</code> 函数中，<strong>这个函数正是处理页写入异常的【内核】函数</strong>。</li><li><code>do_tlb_mod</code>函数将当前现场保存在<strong>异常处理栈</strong>中，并设置 a0 和 EPC 寄存器的值，使得从异常恢复后能够以异常处理栈中保存的现场（Trapframe）为参数，跳转到<code>env_user_tlb_mod_entry</code> 域存储的<strong>用户异常处理函数</strong>的地址。</li><li>从异常恢复到用户态，跳转到<strong>用户</strong>异常处理函数中，由用户程序完成写时复制等自定义处理。</li></ul><p>因此，页写入异常的主要处理过程在【用户态】下完成。</p><p>正因为要在<strong>用户态</strong>下完成页写入异常的<strong>处理</strong>，所以用户进程就需要一个单独的栈来执行处理程序，我们把这个栈称作<strong>异常处理栈</strong>。</p><p>此外，内核还需要知晓进程自身的处理函数所在地址，它的地址存在于进程控制块的<code>env_user_tlb_mod_entry </code>域中，这个地址也需要事先由父进程通过系统调用设置。</p><h4 id="syscall-set-tlb-mod-entry"><a href="#syscall-set-tlb-mod-entry" class="headerlink" title="syscall_set_tlb_mod_entry"></a><code>syscall_set_tlb_mod_entry</code></h4><p>注册自身的页写入异常处理函数</p><h4 id="syscall-set-trapframe"><a href="#syscall-set-trapframe" class="headerlink" title="syscall_set_trapframe"></a><code>syscall_set_trapframe</code></h4><p>将envid对应的tf设置为传入的参数</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">sys_set_trapframe</span><span class="token punctuation">(</span>u_int envid<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">Trapframe</span> <span class="token operator">*</span>tf<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="sys-set-tlb-mod-entry-内核系统调用处理函数"><a href="#sys-set-tlb-mod-entry-内核系统调用处理函数" class="headerlink" title="sys_set_tlb_mod_entry 内核系统调用处理函数"></a><code>sys_set_tlb_mod_entry</code> 内核系统调用处理函数</h4><p>将进程控制块的 env_user_tlb_mod_entry 域设为传入的参数。</p><h4 id="do-tlb-mod-函数"><a href="#do-tlb-mod-函数" class="headerlink" title="do_tlb_mod 函数"></a><code>do_tlb_mod</code> 函数</h4><p>位于<code>kern/tlbex.c</code>，<strong>内核中</strong>TLB Mod异常的处理函数，负责完成写时复制处理前的相关设置。</p><p>将现场保存在<strong>异常处理栈</strong>中，设置 a0 和 EPC 寄存器的值，使得从异常恢复后能够以异常处理栈中保存的现场（Trapframe）为参数，跳转到 <code>env_user_tlb_mod_entry </code>域存储的<strong>用户异常处理函数</strong>的地址。（P118）</p><h4 id="cow-entry-函数"><a href="#cow-entry-函数" class="headerlink" title="cow_entry 函数"></a><code>cow_entry</code> 函数</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token keyword">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span>noreturn<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">cow_entry</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Trapframe</span> <span class="token operator">*</span>tf<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>位于<code>user/lib/fork.c</code>，cow_entry 函数是<strong>写时复制处理</strong>的函数，也是内核会从<code>do_tlb_mod</code>返回到的函数，负责对带有 <code>PTE_COW</code> 标志的页面进行处理</p><p>1 重新设置权限 <code>perm = (perm &amp; ~PTE_COW) | PTE_D;</code></p><p>2 申请一个新物理页，对应的虚拟地址<code>UCOW</code></p><p>3 把出现COW错误的地址<code>va</code>对应的物理页内容拷贝至新建的物理页</p><p>4 取消va到原物理页的映射，将va映射到新申请的物理页（使用系统调用 <code>syscall_mem_map</code> 将当前进程的 <code>UCOW</code> 所在的物理页，作为当前进程的 <code>va</code> 地址所映射的物理页，并设定其权限即可）</p><p>5 取消该进程中 UCOW 与物理页的映射</p><p>6 <strong>异常处理后</strong>恢复现场（在函数的最后，使用系统调用 syscall_set_trapframe 恢复了保存的现场）</p><h2 id="实验心得"><a href="#实验心得" class="headerlink" title="实验心得"></a>实验心得</h2><p>本次作业实现的是一些<strong>由内核提供的，可供用户程序调用的接口</strong>，即系统调用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OS_lab3</title>
      <link href="/2024/04/14/lab3-shi-yan-bao-gao/"/>
      <url>/2024/04/14/lab3-shi-yan-bao-gao/</url>
      
        <content type="html"><![CDATA[<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h4 id="Thinking-3-1"><a href="#Thinking-3-1" class="headerlink" title="Thinking 3.1"></a>Thinking 3.1</h4><p><strong>Q:  Thinking 3.1 请结合 MOS 中的页目录自映射应用解释代码中 <code>e-&gt;env_pgdir[PDX(UVPT)]= PADDR(e-&gt;env_pgdir) | PTE_V</code> 的含义</strong>  </p><p><strong>A:</strong>  </p><p>该语句实现了自映射。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">e<span class="token operator">-&gt;</span>env_pgdir<span class="token punctuation">[</span><span class="token function">PDX</span><span class="token punctuation">(</span>UVPT<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">PADDR</span><span class="token punctuation">(</span>e<span class="token operator">-&gt;</span>env_pgdir<span class="token punctuation">)</span> <span class="token operator">|</span> PTE_V<span class="token punctuation">;</span><span class="token comment">//实现了映射：虚拟地址UVPT &lt;-&gt; 该进程页目录自身的pa</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这使得<code>UVPT</code>这个虚拟地址对应的页目录项，该页目录项不再对应二级页表，而是<strong>指向页目录自身</strong></p><blockquote><p>MOS系统将页表和页目录映射到了用户空间中的 0x7fc00000-0x80000000（共 4MB）区域，这意味着 MOS 中允许在用户态下通过 UVPT 访问当前进程的页表和页目录。  </p></blockquote><blockquote><p>自映射的作用：在用户空间划分出一部分，使得用户可以通过访问这部分空间得到二级页表以及页目录中的内容。</p><p>具体来说，<code>UVPT</code>以上的4KB空间(1024个页表的大小)被标记为 <code>User VPT</code>。我们用这部分虚拟地址<code>va</code>访存的过程如下：</p><p>首先，这个地址会经过页目录，<code>PDX(va)</code> 的结果和 <code>UVPT</code> 相同，我们进入到索引对应的二级页表——由于上述自映射，我们得到的还是<strong>页目录自身</strong>。</p><p>好的，我们在页目录中重新来一遍，这次通过 <code>PTX(va)</code> 计算索引，可以找到一个物理页，取出其中的数据。可是这个物理页却不再是一般的物理页了，而是<strong>作为二级页表的物理页</strong>。这样我们就<strong>取到了二级页表的内容</strong>。</p><p>另外假如我们恰好取得的 <code>PTX(va)</code> 值与 <code>PDX(va)</code> 相同，那么我们绕了两圈，最终还是处在页目录之中，这样我们就<strong>取到了页目录的内容</strong>。</p></blockquote><h4 id="Thinking-3-2"><a href="#Thinking-3-2" class="headerlink" title="Thinking 3.2"></a>Thinking 3.2</h4><p><strong>Q:</strong>  </p><p><strong><code>elf_load_seg</code> 以函数指针的形式，接受外部自定义的回调函数 <code>map_page</code>。 请你找到与之相关的 <code>data</code> 这一参数在此处的来源，并思考它的作用。没有这个参数可不可以？为什么？</strong> </p><p><strong>A:</strong> </p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//lib/elfloader.c</span><span class="token keyword">int</span> <span class="token function">elf_load_seg</span><span class="token punctuation">(</span>Elf32_Phdr <span class="token operator">*</span>ph<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>bin<span class="token punctuation">,</span> <span class="token class-name">elf_mapper_t</span> map_page<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>data<span class="token punctuation">)</span>    <span class="token comment">//kern/env.c</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">load_icode</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Env</span> <span class="token operator">*</span>e<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>binary<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">const</span> Elf32_Ehdr <span class="token operator">*</span>ehdr <span class="token operator">=</span> <span class="token function">elf_from</span><span class="token punctuation">(</span>binary<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//...for循环遍历所有的程序头表</span>    <span class="token comment">//如果其对应的程序需要被加载到内存，则调用elf_load_seg进行加载</span><span class="token function">panic_on</span><span class="token punctuation">(</span><span class="token function">elf_load_seg</span><span class="token punctuation">(</span>ph<span class="token punctuation">,</span> binary <span class="token operator">+</span> ph<span class="token operator">-&gt;</span>p_offset<span class="token punctuation">,</span> load_icode_mapper<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//...</span>e<span class="token operator">-&gt;</span>env_tf<span class="token punctuation">.</span>cp0_epc <span class="token operator">=</span> ehdr <span class="token operator">-&gt;</span> e_entry<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">load_icode_mapper</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>data<span class="token punctuation">,</span> u_long va<span class="token punctuation">,</span> <span class="token class-name">size_t</span> offset<span class="token punctuation">,</span>                              u_int perm<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>src<span class="token punctuation">,</span> <span class="token class-name">size_t</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//该函数 将数据映射到虚拟地址所在的页上</span><span class="token keyword">struct</span> <span class="token class-name">Env</span> <span class="token operator">*</span>env <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Env</span> <span class="token operator">*</span><span class="token punctuation">)</span>data<span class="token punctuation">;</span> <span class="token comment">//将 data 还原为进程控制块</span>    <span class="token comment">//...</span>    <span class="token keyword">return</span> <span class="token function">page_insert</span><span class="token punctuation">(</span>env<span class="token operator">-&gt;</span>env_pgdir<span class="token punctuation">,</span> env<span class="token operator">-&gt;</span>env_asid<span class="token punctuation">,</span> p<span class="token punctuation">,</span> va<span class="token punctuation">,</span> perm<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//env可区别不同进程的相同虚拟地址</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>elf_load_seg</code> 函数根据程序头表中的信息将<code>bin</code>中的数据加载到指定位置。其中<code>void* data</code>是回调函数需要使用的参数。<code>elf_load_seg</code> 函数在<code>load_icode</code>函数中被调用。</p><p>这里的<code>struct Env *e</code>是<code>load_icode</code>函数的传入参数，<code>env_create</code>中我们用<code>env_alloc</code>分配到新的Env，调用<code>load_icode</code>函数来为进程加载 ELF 程序。</p><p>所以，这个<code>data</code>参数作为待加载的进程管理块指针是必要的，它被传入回调函数<code>load_icode_mapper()</code>，用来告知后者加载到哪个进程的虚拟内存中。</p><h4 id="Thinking-3-3"><a href="#Thinking-3-3" class="headerlink" title="Thinking 3.3"></a>Thinking 3.3</h4><p>**Q:  结合 elf_load_seg 的参数和实现，考虑该函数需要处理哪些页面加载的情况。 **</p><p><strong>A:</strong></p><ul><li>(1) 段起始地址未页面对齐</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">u_long offset <span class="token operator">=</span> va <span class="token operator">-</span> <span class="token function">ROUNDDOWN</span><span class="token punctuation">(</span>va<span class="token punctuation">,</span> PAGE_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>offset <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//先映射到内存的页中</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token function">map_page</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> va<span class="token punctuation">,</span> offset<span class="token punctuation">,</span> perm<span class="token punctuation">,</span> bin<span class="token punctuation">,</span>  <span class="token function">MIN</span><span class="token punctuation">(</span>bin_size<span class="token punctuation">,</span> PAGE_SIZE <span class="token operator">-</span> offset<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> r<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>(2) 处理数据中间完整的部分，通过循环不断将数据加载到页上。</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> offset <span class="token operator">?</span> <span class="token function">MIN</span><span class="token punctuation">(</span>bin_size<span class="token punctuation">,</span> PAGE_SIZE <span class="token operator">-</span> offset<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> bin_size<span class="token punctuation">;</span> i <span class="token operator">+=</span> PAGE_SIZE<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token function">map_page</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> va <span class="token operator">+</span> i<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> perm<span class="token punctuation">,</span> bin <span class="token operator">+</span> i<span class="token punctuation">,</span> <span class="token function">MIN</span><span class="token punctuation">(</span>bin_size <span class="token operator">-</span> i<span class="token punctuation">,</span> PAGE_SIZE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">return</span> r<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>(3) 段大小大于数据大小的情况(如<code>.bss</code>)，补充空页面</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> sgsize<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token function">map_page</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> va <span class="token operator">+</span> i<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> perm<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token function">MIN</span><span class="token punctuation">(</span>sgsize <span class="token operator">-</span> i<span class="token punctuation">,</span> PAGE_SIZE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">return</span> r<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    i <span class="token operator">+=</span> PAGE_SIZE<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Thinking-3-4"><a href="#Thinking-3-4" class="headerlink" title="Thinking 3.4"></a>Thinking 3.4</h4><p>**Q: ** </p><blockquote><p>这里的 <code>env_tf.cp0_epc</code> 字段指示了进程恢复运行时 PC 应恢复到的位置。我们要运行的进程的代码段预先被载入到了内存中，且程序入口为 <code>e_entry</code>，当我们运行进程时，CPU 将自动从PC 所指的位置开始执行二进制码。</p></blockquote><p><strong>思考上面这一段话，并根据自己在 Lab2 中的理解，回答： 你认为这里的 <code>env_tf.cp0_epc</code> 存储的是物理地址还是虚拟地址?</strong></p><p><strong>A:</strong>  虚拟地址。对于每个用户进程来说<code>entry_point</code>都应该是一样的（如果不手动进行设置的话），虚拟地址能够实现程序的每次执行都从一个固定的地址开始。</p><h4 id="Thinking-3-5"><a href="#Thinking-3-5" class="headerlink" title="Thinking 3.5"></a>Thinking 3.5</h4><p>**Q: **</p><p><strong>试找出 0、1、2、3 号异常处理函数的具体实现位置。8 号异常（系统调用） 涉及的 do_syscall() 函数将在 Lab4 中实现</strong></p><p><strong>A:</strong></p><p>0 号异常 的处理函数为 <code>handle_int</code>，表示中断，由时钟中断、控制台中断等中断造成<br>1 号异常 的处理函数为 <code>handle_mod</code>，表示存储异常，进行存储操作时该页被标记为只读<br>2 号异常 的处理函数为<code>handle_tlb</code>，表示 TLB load 异常<br>3 号异常 的处理函数为<code>handle_tlb</code>，表示 TLB store 异常</p><p><code>kern/genex.S</code></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;asm/asm.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stackframe.h&gt;</span></span><span class="token punctuation">.</span>macro BUILD_HANDLER exception handler<span class="token function">NESTED</span><span class="token punctuation">(</span>handle_\exception<span class="token punctuation">,</span> TF_SIZE <span class="token operator">+</span> <span class="token number">8</span><span class="token punctuation">,</span> zero<span class="token punctuation">)</span>    move    a0<span class="token punctuation">,</span> sp    addiu   sp<span class="token punctuation">,</span> sp<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">8</span>    jal     \handler    addiu   sp<span class="token punctuation">,</span> sp<span class="token punctuation">,</span> <span class="token number">8</span>    j       ret_from_exception<span class="token function">END</span><span class="token punctuation">(</span>handle_\exception<span class="token punctuation">)</span><span class="token punctuation">.</span>endm<span class="token punctuation">.</span>text<span class="token function">FEXPORT</span><span class="token punctuation">(</span>ret_from_exception<span class="token punctuation">)</span>    RESTORE_ALL <span class="token comment">//恢复Status寄存器，开启中断</span>    eret<span class="token function">NESTED</span><span class="token punctuation">(</span>handle_int<span class="token punctuation">,</span> TF_SIZE<span class="token punctuation">,</span> zero<span class="token punctuation">)</span> <span class="token comment">// handle_int 实现</span>    mfc0    t0<span class="token punctuation">,</span> CP0_CAUSE    mfc0    t2<span class="token punctuation">,</span> CP0_STATUS    and     t0<span class="token punctuation">,</span> t2    andi    t1<span class="token punctuation">,</span> t0<span class="token punctuation">,</span> STATUS_IM7    bnez    t1<span class="token punctuation">,</span> timer_irq <span class="token comment">//如果是时钟中断，跳转到时钟中断处理</span>timer_irq<span class="token operator">:</span>    li      a0<span class="token punctuation">,</span> <span class="token number">0</span>    j       schedule<span class="token function">END</span><span class="token punctuation">(</span>handle_int<span class="token punctuation">)</span>BUILD_HANDLER tlb do_tlb_refill <span class="token comment">// kern/tlbex.c</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token operator">!</span><span class="token function">defined</span><span class="token punctuation">(</span>LAB<span class="token punctuation">)</span> <span class="token operator">||</span> LAB <span class="token operator">&gt;=</span> <span class="token number">4</span></span></span>BUILD_HANDLER mod do_tlb_mod <span class="token comment">// kern/tlbex.c</span>BUILD_HANDLER sys do_syscall <span class="token comment">// kern/syscall_all.c</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>BUILD_HANDLER reserved do_reserved <span class="token comment">// kern/traps.c</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Thinking-3-6"><a href="#Thinking-3-6" class="headerlink" title="Thinking 3.6"></a>Thinking 3.6</h4><p><strong>Q:  阅读 <code>entry.S</code>、<code>genex.S</code> 和 <code>env_asm.S</code> 这几个文件，并尝试说出时钟中断在哪些时候开启，在哪些时候关闭。</strong></p><p><strong>A:</strong>  </p><h4 id="Thinking-3-7"><a href="#Thinking-3-7" class="headerlink" title="Thinking 3.7"></a>Thinking 3.7</h4><p><strong>Q:  阅读相关代码，思考操作系统是怎么根据时钟中断切换进程的。</strong></p><p><strong>A:</strong> </p><p>一旦时钟中断产生，就会触发 4KC 硬件的异常中断处理流程。系统将 PC 指向 0x80000180，跳转到.text.exc_gen_entry 代码段执行。对于时钟引起的中断，通过.text.exc_gen_entry代码段的分发，最终会调用 handle_int 函数进行处理。随后执行中断服务函数 timer_irq，跳转到 schedule 中执行，根据当前进程块状态进行进程块队列调度，实现进程切换或进程的舍弃，完成时钟中断响应。</p><h2 id="难点分析"><a href="#难点分析" class="headerlink" title="难点分析"></a>难点分析</h2><img src="lab3%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20240501101832217.png" alt="image-20240501101832217" style="zoom:60%;"><h4 id="关于mips-init"><a href="#关于mips-init" class="headerlink" title="关于mips_init"></a>关于<code>mips_init</code></h4><p>lab3内容如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">env_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">ENV_CREATE_PRIORITY</span><span class="token punctuation">(</span>user_bare_loop<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">ENV_CREATE_PRIORITY</span><span class="token punctuation">(</span>user_bare_loop<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">schedule</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先，我们调用env_init来完成进程的初始化。</p><p>然后，我们又调用 <code>ENV_CREATE_PRIORITY</code> 宏创建了两个进程。把这个宏展开如下。我们调用了 <code>env_create</code> 函数，用于创建一个进程。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">env_create</span><span class="token punctuation">(</span>binary_user_bare_loop_start<span class="token punctuation">,</span> <span class="token punctuation">(</span>u_int<span class="token punctuation">)</span>binary_user_bare_loop_size<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意⏰：我们所 “加载” 的程序实际上是被一同编译到内核中的一段 ELF 格式的数据。这段数据中存在标签 <code>binary_user_bare_loop_start</code> 和 <code>binary_user_bare_loop_size</code>，所以我们才可以只通过引用外部变量的形式就 “加载” 了程序文件。</p><h4 id="env-init"><a href="#env-init" class="headerlink" title="env_init"></a><code>env_init</code></h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">env_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>1.初始化2个list，初始的时候所有的env都被放入了free那个list</p><p>总共向<code>env_free_list</code>加入了NENV个env</p><p>envs[NENV]，共1024个进程控制块</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LOG2NENV</span> <span class="token expression"><span class="token number">10</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NENV</span> <span class="token expression"><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> LOG2NENV<span class="token punctuation">)</span></span></span><span class="token comment">//即：1 &lt;&lt; 10 ;即：2^10</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>2.创建一个 “模板页目录”，设置该页将 pages 和 envs （即所有页控制块和所有进程控制块的内存空间）（内核）分别映射到 UPAGES 和 UENVS （用户）的空间中.并且在后续进程创建新的页目录时，也要首先复制模板页目录中的内容。使得用户程序也能够通过 UPAGES 和 UENVS 的用户地址空间获取 Page 和 Env 的信息。<br>即：映射：UTOP 到 UVPT 的虚拟地址空间 &lt;-&gt; 内核数组pages, envs</p><h4 id="mkenvid"><a href="#mkenvid" class="headerlink" title="mkenvid"></a><code>mkenvid</code></h4><p>为每个env创建一个唯一的ID</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">u_int <span class="token function">mkenvid</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Env</span> <span class="token operator">*</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">static</span> u_int i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> LOG2NENV<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>e <span class="token operator">-</span> envs<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到i左移了11位，这时低11位就全是0了。</p><h4 id="asid-alloc"><a href="#asid-alloc" class="headerlink" title="asid_alloc"></a><code>asid_alloc</code></h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NASID</span> <span class="token expression"><span class="token number">256</span> </span><span class="token comment">//asid部分占8bits</span></span><span class="token keyword">static</span> <span class="token class-name">uint32_t</span> asid_bitmap<span class="token punctuation">[</span>NASID <span class="token operator">/</span> <span class="token number">32</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 64</span><span class="token comment">//用64*32记录每个asid是否被占用，如果全部256个都已经分配，则返回错误</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">asid_alloc</span><span class="token punctuation">(</span>u_int <span class="token operator">*</span>asid<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">for</span> <span class="token punctuation">(</span>u_int i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> NASID<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">int</span> index <span class="token operator">=</span> i <span class="token operator">&gt;&gt;</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token comment">//抹去低5位，/=32</span><span class="token keyword">int</span> inner <span class="token operator">=</span> i <span class="token operator">&amp;</span> <span class="token number">31</span><span class="token punctuation">;</span> <span class="token comment">//取得低5位，31是11111</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>asid_bitmap<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> inner<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>asid_bitmap<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">|=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> inner<span class="token punctuation">;</span><span class="token operator">*</span>asid <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token operator">-</span>E_NO_FREE_ENV<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="进程的标识"><a href="#进程的标识" class="headerlink" title="进程的标识"></a>进程的标识</h4><p>ASID 用于标识虚拟地址空间，同时并发执行的多个进程具有不同 ASID 以方便 TLB 标识其虚拟地址空间。</p><h4 id="env-create-进程创建函数"><a href="#env-create-进程创建函数" class="headerlink" title="env_create 进程创建函数"></a><code>env_create</code> 进程创建函数</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">Env</span> <span class="token operator">*</span><span class="token function">env_create</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>binary<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">,</span> <span class="token keyword">int</span> priority<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在mips_init中调用，用于创建一个进程<br>1 用 env_alloc 分配一个新的 Env 结构体;<br>2 设置进程控制块（ e-&gt;env.pri 和 e-&gt;env_status ）;<br>3 用 load_icode 将程序载入到该进程的地址空间;<br>4 用TAILQ_INSERT_HEAD 将进程控制块加入到 env_sched_list调度队列</p><h4 id="env-alloc-申请空闲PCB（env）"><a href="#env-alloc-申请空闲PCB（env）" class="headerlink" title="env_alloc 申请空闲PCB（env）"></a><code>env_alloc</code> 申请空闲PCB（env）</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">env_alloc</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Env</span> <span class="token operator">*</span><span class="token operator">*</span>new<span class="token punctuation">,</span> u_int parent_id<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>1 从env_free_list获取一个空的PCB :<code>struct Env *e</code>;<br>2 env_setup_vm(e); 初始化新进程的地址空间<br>3 初始化Env结构体的一些变量，包括：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">e<span class="token operator">-&gt;</span>env_user_tlb_mod_entry <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// for lab4</span>e<span class="token operator">-&gt;</span>env_runs <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>       <span class="token comment">// for lab6</span>e<span class="token operator">-&gt;</span>env_id <span class="token operator">=</span> <span class="token function">mkenvid</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>e<span class="token operator">-&gt;</span>env_parent_id <span class="token operator">=</span> parent_id<span class="token punctuation">;</span><span class="token comment">//所以最多只有256个进程同时被创建</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token function">asid_alloc</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>e<span class="token operator">-&gt;</span>env_asid<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> r<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>4 设置进程的 status 寄存器和 sp 寄存器的值</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">e<span class="token operator">-&gt;</span>env_tf<span class="token punctuation">.</span>cp0_status <span class="token operator">=</span> STATUS_IM7 <span class="token operator">|</span> STATUS_IE <span class="token operator">|</span> STATUS_EXL <span class="token operator">|</span> STATUS_UM<span class="token punctuation">;</span><span class="token comment">//UM = 1,使得ERET把EXL置为1时处理器切换到用户态；EXL=1，确保目前处理器仍保留在内核态，IM7和IE确保时钟中断被响应</span>e<span class="token operator">-&gt;</span>env_tf<span class="token punctuation">.</span>regs<span class="token punctuation">[</span><span class="token number">29</span><span class="token punctuation">]</span> <span class="token operator">=</span> USTACKTOP <span class="token operator">-</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//设置【用户栈】指针</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在未执行的情况下，用户程序的 sp 寄存器应该处于栈顶 <code>USTACKTOP</code> 的位置。但为了给程序的 <code>main</code> 函数的参数 <code>argc</code> 和 <code>argv</code> 留出空间，需要减去 <code>sizeof(int) + sizeof(char **)</code> 的大小。</p><p>5 将e从free_list中移除，<code>*new=e</code></p><p><code>static int env_setup_vm(struct Env *e); </code></p><p>初始化进程控制块的用户地址空间<br>1 申请一个page(物理页)作为页目录<br>2 (UTOP ~ UVPT)这一段虚拟地址空间对应的页表项</p><p><code>int envid2env(u_int envid, struct Env **penv, int checkperm)</code></p><p>根据一个进程的envid获取该进程控制块。</p><p>1 如果envid == 0，就返回当前进程控制块curenv</p><p>2 <code>mkenvid</code> 的算法中，envid 的低十位就是进程控制块的索引；通过 <code>ENVX</code> 宏获取 envid 对应的进程控制块相对于进程控制块数组的索引。</p><p>3 有效性检查</p><p>4 checkperm!=0时的亲缘关系检查</p><p><code>static void load_icode(struct Env *e, const void *binary, size_t size)</code></p><p>加载可执行文件binary到进程e的内存中<br>1 调用了 elf_from 函数从二进制数据中读取了页表信息,(简单地对二进制数据做类型转换，并检查是否确为 ELF 文件头)<br>2 遍历所有的程序头表,取出对应的程序头，如果其中的 p_type 类型为 PT_LOAD，说明其对应的程序需要被加载到内存中。我们调用 elf_load_seg 函数来进行加载<br>3 最后，我们将进程控制块中 trap frame 的 epc cp0 寄存器的值设置为 ELF 文件中设定的程序入口地址   </p><p><code>int elf_load_seg(Elf32_Phdr *ph, const void *bin, elf_mapper_t map_page, void *data)</code></p><p>//将elf文件的一个segment加载到内存<br>//将bin中的数据加载到指定位置<br>1 Elf32_Phdr *ph：指向 ELF 文件中一个程序段头部的指针，可获取程序段va等信息<br>2 按页 调用回调函数 map_page(data, va, offset, perm, bin, , len)</p><p><code>static int load_icode_mapper(void *data, u_long va, size_t offset, u_int perm, const void *src, size_t len)</code></p><p>回调函数，用于将数据映射到虚拟地址所在的页上1 data还原为进程控制块<code>Env*</code><br>2 申请空闲物理页p<br>3 如果存在需要拷贝的数据(src!= null)，用memcpy将src数据拷贝到p对应的内存<br>4 调用 page_insert 将虚拟地址映射到页上，需要env结构体中的信息，用来区别不同进程的相同虚拟地址</p><h4 id="env-run-进程运行与切换"><a href="#env-run-进程运行与切换" class="headerlink" title="env_run 进程运行与切换"></a><code>env_run</code> 进程运行与切换</h4><p>env_run 是进程运行使用的基本函数，实际上更多意味着<strong>进程的切换</strong>。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">env_run</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Env</span> <span class="token operator">*</span>e<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们是在什么情况下调用env_run的：</p><p>由于上一个进程的时间片用完了，Timer产生了时钟中断。所以我们陷入内核，因为需要运行/切换进程。在陷入内核的时候，我们把用户态的现场保存到了内核异常栈（<code>SAVE_ALL</code>）。</p><p>我们先在schedule函数里决定好下一个该跑的进程是哪个，决定好了是e，传给env_run，然后说：就是他，给我跑吧！也就是我们在处理中断异常的时候，调度到了这个进程e，现在我们要让他跑起来了。一旦能跑起来这个进程，我们这个中断也算是处理完了。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">env_run</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Env</span> <span class="token operator">*</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//omit: assert e is RUNNABLE</span><span class="token comment">/* Step 1: *   If 'curenv' is NULL, this is the first time through. *   If not, we may be switching from a previous env, so save its context into *   'curenv-&gt;env_tf' first. */</span><span class="token keyword">if</span> <span class="token punctuation">(</span>curenv<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//这时当前进程(curenv)还是previous env</span>curenv<span class="token operator">-&gt;</span>env_tf <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Trapframe</span> <span class="token operator">*</span><span class="token punctuation">)</span>KSTACKTOP <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//如果(切换进程前)curenv不是NULL，说明当前进程还是previous env</span><span class="token comment">//所以将previous env的上下文保存。当时陷入异常的时候我们把用户态的现场保存到了内核异常栈(SAVE_ALL)</span><span class="token comment">/* Step 2: Change 'curenv' to 'e'. */</span>curenv <span class="token operator">=</span> e<span class="token punctuation">;</span>curenv<span class="token operator">-&gt;</span>env_runs<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// lab6</span><span class="token comment">/* Step 3: Change 'cur_pgdir' to 'curenv-&gt;env_pgdir', switching to its address space. */</span><span class="token comment">/* Exercise 3.8: Your code here. (1/2) */</span>cur_pgdir <span class="token operator">=</span> curenv <span class="token operator">-&gt;</span>env_pgdir<span class="token punctuation">;</span><span class="token comment">/* Step 4: Use 'env_pop_tf' to restore the curenv's saved context (registers) and return/go * to user mode. * * Hint: *  - You should use 'curenv-&gt;env_asid' here. *  - 'env_pop_tf' is a 'noreturn' function: it restores PC from 'cp0_epc' thus not *    returning to the kernel caller, making 'env_run' a 'noreturn' function as well. */</span><span class="token comment">/* Exercise 3.8: Your code here. (2/2) */</span><span class="token function">env_pop_tf</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>curenv<span class="token operator">-&gt;</span>env_tf<span class="token punctuation">)</span><span class="token punctuation">,</span> curenv<span class="token operator">-&gt;</span>env_asid<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>1 保存当前进程的上下文信息。</strong> </p><blockquote><p>我们在本实验里的寄存器状态保存的地方是 <code>KSTACKTOP</code> 以下的一个 <code>sizeof(TrapFrame)</code>大小的区域中。当时异常刚发生的时候我们用SAVE_ALL将当时的上下文保存在了这里（内核的异常栈）。现在异常处理完了，现在这个进程的tf（无论这个进程是该被换成别的还是该再跑一个时间片）也应该恢复成当时刚陷入内核的样子，这样才能保证我陷入内核切换进程对于用户态来说什么都没发生的效果。</p></blockquote><p>所以说，我们将把 KSTACKTOP 之下的Trapframe 拷贝到当前进程的 env_tf 中，以达到保存进程上下文的效果。  </p><p>2 切换 curenv 为即将运行的进程。  </p><p>3 设置全局变量 cur_pgdir 为当前进程页目录地址，在 TLB 重填时将用到该全局变量。  </p><p>4 调用 env_pop_tf 函数，恢复现场、异常返回。  </p><h4 id="kern-entry-S——分发异常的程序"><a href="#kern-entry-S——分发异常的程序" class="headerlink" title="kern/entry.S——分发异常的程序:"></a><code>kern/entry.S</code>——<strong>分发异常的程序</strong>:</h4><p>当发生异常时，处理器会进入一个用于分发异常的程序。该程序放在某个固定的物理地址上，保证cpu能再检测到异常时正确地跳转。</p><p>检测<strong>发生了哪种异常，并调用相应的异常处理程序</strong>。  </p><p>实现两个函数：</p><p><code>tlb_miss_entry</code></p><p><code>exc_gen_entry</code>：异常分发代码。使用<code>SAVE_ALL</code>将所有的寄存器值存储到栈帧中。关闭中断且允许嵌套异常。</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">#include ....section .text.tlb_miss_entrytlb_miss_entry:j       exc_gen_entry.section .text.exc_gen_entryexc_gen_entry:SAVE_ALL #将所有的寄存器值存储到栈帧(内核异常栈)中mfc0    t0, CP0_STATUSand     t0, t0, ~(STATUS_UM | STATUS_EXL | STATUS_IE) # 清除Status寄存器中的 UM、EXL、IE位，以保持处理器处于内核态（UM==0）mtc0    t0, CP0_STATUS/* Exercise 3.9: Your code here. */mfc0 t0, CP0_CAUSEandi t0, 0x7c #获取 cause 寄存器的值，取其 2-6 位，这部分对应异常码ExcCode，用于区别不同的异常lw t0, exception_handlers(t0)jr t0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="时钟中断的初始化"><a href="#时钟中断的初始化" class="headerlink" title="时钟中断的初始化"></a>时钟中断的初始化</h4><p>CP0 内置了一个可产生中断的 Timer， MOS 即使用这个内置的 Timer 产生时钟中断。具体来说 CP0 中存在<strong>Count和Compare这2个寄存器</strong>，就是用于控制此内置 Timer 的寄存器。<code>include/kclock.h</code> 中的 <code>RESET_KCLOCK</code> 宏完成了对 CP0 中 Timer 的配置。  </p><h4 id="handle-int-函数"><a href="#handle-int-函数" class="headerlink" title="handle_int 函数"></a><code>handle_int</code> 函数</h4><p>对于时钟引起的中断，通过.text.exc_gen_entry代码段的分发，最终会调用 handle_int 函数进行处理。</p><p>handle_int 函数根据 Cause 寄存器的值判断是否是 Timer 对应的 7 号中断位引发的时钟中断，如果是，则执行中断服务函数 timer_irq，跳转到 schedule 中执行。这个函数就是我们将要补充的调度函数。  </p><h4 id="进程调度函数-schedue"><a href="#进程调度函数-schedue" class="headerlink" title="进程调度函数 schedue"></a>进程调度函数 <code>schedue</code></h4><h4 id="相关寄存器"><a href="#相关寄存器" class="headerlink" title="相关寄存器"></a>相关寄存器</h4><p>中断和异常用到了CPU中的协处理器（CP0）中的12号（SR），13号（Cause）和14号（EPC）寄存器。</p><table><thead><tr><th align="left">寄存器助记符</th><th align="left">CP0寄存器编号</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">SR</td><td align="left">12</td><td align="left">Status Reg，状态寄存器，包括中断引脚使能，其他CPU模式等位域</td></tr><tr><td align="left">Cause</td><td align="left">13</td><td align="left">记录导致异常的原因</td></tr><tr><td align="left">EPC</td><td align="left">14</td><td align="left">异常结束后程序恢复执行的位置</td></tr></tbody></table><p><strong>12号（状态寄存器）</strong></p><p><img src="/lab3%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20240427213721176.png" alt="image-20240427213721176"></p><p><strong>IE位(Interupt Enable)：</strong>中断位是否开启</p><p><strong>IM7</strong>位：7号中断（时钟中断）可以被相应</p><p><strong>如何判断CPU模式是内核态or其他CPU状态：</strong></p><p>只有Status寄存器中EXL位(Exception Level)=0 &amp;&amp; UM(User Mode)=1时，处理器处于用户模式。其它所有情况下，处理器均处于内核模式下。  </p><p>每当异常发生的时候， EXL会被自动设置为 1。</p><p>每当执行 eret 指令时， EXL 会被自动设置为 0。</p><p><strong>处理器寄存器状态的恢复</strong></p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">RESTORE_ALL # 寄存器恢复全部完成后eret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>TF 中记录的 Status 寄存器值</strong>将会在 RESTORE_ALL 中被写入<strong>处理器的 Status 寄存器</strong>。因此Status寄存器中的 UM、 IE 均已被设置为 1，表示在用户模式下且开启中断。为了防止RESTORE_ALL后使得处理器立即进入用户模式，从而无法继续执行内核特权指令，设置EXL位，直到运行上述代码到 eret 的时候将 EXL设置为0。（Set the EXL bit to ensure that the processor remains in kernel mode during context recovery.Additionally, set UM to 1 so that when ERET unsets EXL, the processor transitions to user mode）</p><h2 id="实验心得"><a href="#实验心得" class="headerlink" title="实验心得"></a>实验心得</h2><p>有了lab2的基础，本次实验在理解上稍微轻松一些，但整体上任务量还是有的。通过实验真正代码层面上的编写，我对理论学习时一些感觉比较模糊的知识点有了更清晰的认识，比如自映射部分；此外我对先前几次实验的理解也更进一步加深，比如pages相关函数的应用等，但每次重读指导书依然会有新的理解和体会，<del>或许这就是os的魅力吧</del>。</p><p>然而我在上机的过程中由于对代码结构不够了然于心，也出现了<del>很大</del>一些困难，我认为此后学习我更需要注重指导书内容的理解，需要多熟悉代码以及整个操作系统的结构，以及更深刻地理解函数之间的逻辑关系，才能在理解的基础上灵活运用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OS_lab2</title>
      <link href="/2024/03/21/lab2-shi-yan-bao-gao/"/>
      <url>/2024/03/21/lab2-shi-yan-bao-gao/</url>
      
        <content type="html"><![CDATA[<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h4 id="Thinking-2-1"><a href="#Thinking-2-1" class="headerlink" title="Thinking 2.1"></a>Thinking 2.1</h4><p><strong>Q:  请根据上述说明，回答问题：在编写的 C 程序中，指针变量中存储的地址被视为虚拟地址，还是物理地址？ MIPS 汇编程序中 lw 和 sw 指令使用的地址被视为虚拟地址，还是物理地址？</strong>  </p><p><strong>A:</strong>  均为虚拟地址。</p><h4 id="Thinking-2-2"><a href="#Thinking-2-2" class="headerlink" title="Thinking 2.2"></a>Thinking 2.2</h4><p><strong>Q:</strong>  </p><p><strong>• 从可重用性的角度，阐述用宏来实现链表的好处。</strong></p><p><strong>• 查看实验环境中的<code> /usr/include/sys/queue.h</code>，了解其中单向链表与循环链表的实现，比较它们与本实验中使用的双向链表，分析三者在插入与删除操作上的性能差异。</strong></p><p><strong>A:</strong> 宏定义使得我们在不必担心地址和栈的管理的情况下实现函数的功能，使得代码更为简洁和清晰，可读性和可维护性更强。</p><p><strong>单项链表：</strong>如果要在指定项之后插入，可以以O(1)直接进行，若是在指定项之前插入，或删除指定项，则需从头开始遍历以获得指定项的前一项。</p><p><strong>双向链表：</strong>由于可以直接获得某一项的前两项，所以指定项的前/后一项的插入和指定项删除都可以以O(1)实现。</p><p><strong>循环链表：</strong> 由于维护了一个指向尾部的指针，可以实现O(1)在tail和head之间插入；其余性质同单向链表。</p><h4 id="Thinking-2-3"><a href="#Thinking-2-3" class="headerlink" title="Thinking 2.3"></a>Thinking 2.3</h4><p><strong>Q: 请阅读 include/queue.h 以及 include/pmap.h, 将 Page_list 的结构梳理清楚，选择正确的展开结构。</strong></p><p><strong>A:</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">Page_list</span> <span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token punctuation">{</span>        <span class="token keyword">struct</span> <span class="token punctuation">{</span>            <span class="token keyword">struct</span> <span class="token class-name">Page</span> <span class="token operator">*</span>le_next<span class="token punctuation">;</span>            <span class="token keyword">struct</span> <span class="token class-name">Page</span> <span class="token operator">*</span><span class="token operator">*</span>le_prec<span class="token punctuation">;</span>        <span class="token punctuation">}</span> pp_link<span class="token punctuation">;</span>        u_short pp_ref<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token operator">*</span> lh_first<span class="token punctuation">;</span>   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Thinking-2-4"><a href="#Thinking-2-4" class="headerlink" title="Thinking 2.4"></a>Thinking 2.4</h4><p>**Q: ** </p><p><strong>• 请阅读上面有关 TLB 的描述，从虚拟内存和多进程操作系统的实现角度，阐述 ASID的必要性。</strong></p><p><strong>• 请阅读 MIPS 4Kc 文档《MIPS32® 4K™ Processor Core Family Software User’sManual》的 Section 3.3.1 与 Section 3.4，结合 ASID 段的位数，说明 4Kc 中可容纳不同的地址空间的最大数量</strong></p><p><strong>A:</strong></p><p>每个进程都有其对应的页表，ASID用于区分当前虚拟地址是在哪个进程中使用的，使得同一虚拟地址在不同地址空间正确被映射到不同的物理地址中。</p><p>ASID段共6位，因此4Kc中最多可容纳<code>2^6=64</code>个不同的地址空间。</p><h4 id="Thinking-2-5"><a href="#Thinking-2-5" class="headerlink" title="Thinking 2.5"></a>Thinking 2.5</h4><p><strong>• tlb_invalidate 和 tlb_out 的调用关系？</strong></p><p><code>tlb_invalidate</code> 调用了 <code>tlb_out</code>函数。</p><p><strong>• 请用一句话概括 tlb_invalidate 的作用。</strong></p><p>将该地址空间的va虚拟地址对应的表项清空。</p><p><strong>• 逐行解释 tlb_out 中的汇编代码。</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">LEAF</span><span class="token punctuation">(</span>tlb_out<span class="token punctuation">)</span><span class="token punctuation">.</span>set noreorder    mfc0    t0<span class="token punctuation">,</span> CP0_ENTRYHI <span class="token comment">//将EntryHi的原有值保存到t0寄存器</span>    mtc0    a0<span class="token punctuation">,</span> CP0_ENTRYHI <span class="token comment">//将a0中保存的旧表项的Key(VPN+ASID)写入EntryHi</span>    nop    <span class="token comment">/* Step 1: Use 'tlbp' to probe TLB entry */</span>    <span class="token comment">/* Exercise 2.8: Your code here. (1/2) */</span>    tlbp <span class="token comment">//根据EntryHi中的Key在TLB中找到相应表项，将表项索引存入Index</span>    nop    <span class="token comment">/* Step 2: Fetch the probe result from CP0.Index */</span>    mfc0    t1<span class="token punctuation">,</span> CP0_INDEX <span class="token comment">//将Index中的值存入t1寄存器</span><span class="token punctuation">.</span>set reorder    bltz    t1<span class="token punctuation">,</span> NO_SUCH_ENTRY <span class="token comment">//如果t1&lt;0，即没有在TLB中找到EntryHi对应的表项则跳转</span><span class="token punctuation">.</span>set noreorder    mtc0    zero<span class="token punctuation">,</span> CP0_ENTRYHI <span class="token comment">//将EntryHi，EntryLo0，EntryLo1寄存器赋值为0</span>    mtc0    zero<span class="token punctuation">,</span> CP0_ENTRYLO0    mtc0    zero<span class="token punctuation">,</span> CP0_ENTRYLO1    nop    <span class="token comment">/* Step 3: Use 'tlbwi' to write CP0.EntryHi/Lo into TLB at CP0.Index  */</span>    <span class="token comment">/* Exercise 2.8: Your code here. (2/2) */</span>    tlbwi <span class="token comment">//将清零后的EntryHi/Lo值写入对应Index的表项中</span><span class="token punctuation">.</span>set reorderNO_SUCH_ENTRY<span class="token operator">:</span>    mtc0    t0<span class="token punctuation">,</span> CP0_ENTRYHI <span class="token comment">//将EntryHi恢复为原始值</span>    j       ra <span class="token comment">//函数返回</span><span class="token function">END</span><span class="token punctuation">(</span>tlb_out<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Thinking-2-6"><a href="#Thinking-2-6" class="headerlink" title="Thinking 2.6"></a>Thinking 2.6</h4><p><strong>Q:  简单了解并叙述 X86 体系结构中的内存管理机制，比较 X86 和 MIPS 在内存管理上的区别</strong></p><p><strong>A:</strong> </p><ul><li>X86有三种不同的地址空间：逻辑地址，线性地址，物理地址。通过分段机制将逻辑地址转换为线性地址，线性地址经过分页机制的处理转换为物理地址。x86可能存在不分页的情况，但一定分段。MIPS则不分段，直接采用分页机制来管理内存。</li><li>TLB不命中时： MIPS 会触发TLB Refill 异常，内核的 <code>tlb_refill_handler</code> 会以 <code>pgd_current</code> 为当前进程的 <code>PGD</code> 基址，索引获得转换失败的虚址对应的 <code>PTE</code>，并将其填入TLB，然后CPU再用刚刚转换失败的虚拟地址重新访问以下TLB；X86 在 TLB 不命中时，是由硬件 MMU 以 CR3 为当前进程的 PGD 基址，索引获得 PFN 后，直接输出 PA。同时 MMU 会填充 TLB 以加快下次转换的速度。对于转换失败的虚址，MIPS使用<code>BadVAddr</code>寄存器存放，X86使用<code>CR2</code>存放。</li></ul><h4 id="Thinking-A-1"><a href="#Thinking-A-1" class="headerlink" title="Thinking A.1"></a>Thinking A.1</h4><p><strong>Q:  在现代的 64 位系统中，提供了 64 位的字长，但实际上不是 64 位页式存储系统。假设在 64 位系统中采用三级页表机制，页面大小 4KB。由于 64 位系统中字长为8B，且页目录也占用一页，因此页目录中有 512 个页目录项，因此每级页表都需要 9 位。因此在 64 位系统下，总共需要 3 × 9 + 12 = 39 位就可以实现三级页表机制，并不需要 64位。</strong></p><p><strong>现考虑上述 39 位的三级页式存储系统，虚拟地址空间为 512 GB，若三级页表的基地址为 PTbase，请计算：</strong><br><strong>• 三级页表页目录的基地址。</strong><br><strong>• 映射到页目录自身的页目录项（自映射）</strong></p><img src="lab2%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20240411125928105.png" alt="image-20240411125928105" style="zoom:50%;"><h2 id="难点分析"><a href="#难点分析" class="headerlink" title="难点分析"></a>难点分析</h2><p>页控制块是 <code>struct Page</code> 类型的结构体。每一个页控制块对应一个物理页。Page的链表宏展开后：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">Page</span> <span class="token punctuation">{</span><span class="token keyword">struct</span> <span class="token punctuation">{</span><span class="token keyword">struct</span> <span class="token class-name">Page</span> <span class="token operator">*</span>le_next<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">Page</span> <span class="token operator">*</span><span class="token operator">*</span>le_prev<span class="token punctuation">;</span><span class="token punctuation">}</span> pp_link<span class="token punctuation">;</span>u_short pp_ref<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>**空闲链表(page_free_list):**空闲物理页对应的 Page 结构体全部插入这个链表中  </p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">Page_list</span> page_free_list<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>pmap.h</code>中定义了：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">Page_list</span> <span class="token punctuation">{</span>                 <span class="token keyword">struct</span> <span class="token class-name">Page</span> <span class="token operator">*</span>lh_first<span class="token punctuation">;</span> <span class="token comment">//first element</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//由LIST_HEAD(Page_list, Page);定义</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>一些宏</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define PTE_ADDR(pte) (((u_long)(pte)) &amp; ~0xFFF)//获取页目录项对应的二级页表基地址，就是将页目录项内容的低12位抹零u_long page2ppn(struct Page *pp) {return pp - pages;}// 给定物理页pp，返回pp是第几个页static inline u_long page2pa(struct Page *pp) {return page2ppn(pp) &lt;&lt; PGSHIFT;}//给定物理页struct Page *pp，获取物理页pp的基地址：//先得到pp是第几个页，再乘上物理页大小    #define PPN(pa) (((u_long)(pa)) &gt;&gt; 12) //返回物理地址对应的页数static inline struct Page *pa2page(u_long pa) {if (PPN(pa) &gt;= npage) {panic("pa2page called with invalid pa: %x", pa);}return &amp;pages[PPN(pa)];} //给出某一页的pa，返回指向这个页的page指针static inline u_long page2kva(struct Page *pp) {return KADDR(page2pa(pp));}//page转化为在kseg0的虚拟地址判定一个页目录项是否有效：if(( (*pgdir_entryp)  &amp; PTE_V ) == 0) //(无效)获取对应二级页表基地址：Pte *pgtable = (Pte*) KADDR(PTE_ADDR(*pgdir_entryp));PTE_ADDR(*pgdir_entryp)将页目录项低12位抹零，获得二级页表基地址pa，再用KADDR()转换为kseg0下的va由上二级页表基地址，获取对应页表项：Pte* pgtable_entry = pgtable + PTX(va);//PTX即获取0-1023的偏移量，是va的12-21位判断是否有效同上得到页表项内容：*pgtable_entry抹去低12位perm，获得pa(物理页基地址，高20位)pp = pa2page(*pgtable_entry);//不抹也行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="运行时二级页表检索pgdir-walk"><a href="#运行时二级页表检索pgdir-walk" class="headerlink" title="运行时二级页表检索pgdir_walk"></a>运行时二级页表检索<code>pgdir_walk</code></h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">pgdir_walk</span><span class="token punctuation">(</span>Pde <span class="token operator">*</span>pgdir<span class="token punctuation">,</span> u_long va<span class="token punctuation">,</span> <span class="token keyword">int</span> create<span class="token punctuation">,</span> Pte <span class="token operator">*</span><span class="token operator">*</span>ppte<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>pgdir_walk</code>能够获取<code>va</code>对应的二级页表项，该函数使<code>*ppte</code>指向<code>va</code>虚拟地址对应的二级页表项。支持为这个页目录项申请一个新的物理页作为其映射的二级页表。</p><p>如果这个函数正常结束，就能赋给其相应参数指向二级页表项的指针（<code>pgtable</code> + <code>PTX(va)</code>）。</p><h4 id="增加地址映射-page-insert"><a href="#增加地址映射-page-insert" class="headerlink" title="增加地址映射 page_insert"></a>增加地址映射 <code>page_insert</code></h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">page_insert</span><span class="token punctuation">(</span>Pde <span class="token operator">*</span>pgdir<span class="token punctuation">,</span> u_int asid<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">Page</span> <span class="token operator">*</span>pp<span class="token punctuation">,</span> u_long va<span class="token punctuation">,</span> u_int perm<span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>增加地址映射，将va这一虚拟地址映射到内存控制块pp对应的物理页面。并将页表项权限更改为<code>perm</code></p><p>首先<strong>使用<code>pgdir_walk</code>获得二级页表项</strong>。值得注意的是，此时我们不应当再去考虑<code>pgdir_walk</code>的实现细节，我们只需要可以通过其获得二级页表基地址即可，应当时刻注意抽象、封装和接口。</p><p>然后分情况讨论：</p><ul><li>当该二级页表项有效时<ul><li>若当前映射的物理页面不是我们需要其映射的pp，则执行<code>page_remove</code>取消地址映射。</li><li>否则，更新权限位，并调用<code>tlb_invalidate</code>以使得下一次访问该va时会触发缺页异常并直接返回。</li></ul></li><li>当二级页表项无效或进行了<code>page_remove</code>，调用<code>tlb_invalidate</code>使得下一次访问该va时触发缺页异常。调用<code>pgdir_walk</code>得到二级页表项，将其内容设置为pp对应的物理地址并或上权限位。还需要注意要使<code>pp-&gt;pp_ref++</code></li></ul><h4 id="page-lookup"><a href="#page-lookup" class="headerlink" title="page_lookup"></a><code>page_lookup</code></h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">Page</span> <span class="token operator">*</span><span class="token function">page_lookup</span><span class="token punctuation">(</span>Pde <span class="token operator">*</span>pgdir<span class="token punctuation">,</span> u_long va<span class="token punctuation">,</span> Pte <span class="token operator">*</span><span class="token operator">*</span>ppte<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>返回**<code>va</code>映射的物理页面的页控制块**，同时将 <code>ppte</code> 指向的空间设为对应的二级页表项地址。</p><p>首先调用<code>pgdir_walk</code>获得<code>pte</code>，分情况讨论（值得注意的是，调用<code>pgdir_walk</code>的时候<code>create</code>置为<code>0</code>，即，如果页目录项非法，<strong>不</strong>新生成有效的二级页目录项）：</p><ul><li><code>pte</code>为0（无效）或<code>pte</code>判断<code>PTE_V</code>无效，直接返回0表示没找到</li><li><code>pte</code>有效，根据<code>pte</code>得到物理页框的指针作为返回值，同时将参数<code>Pte **ppte</code>赋值使得<code>ppte</code>指向的<code>pte</code>的值更新为本函数中调用<code>pgdir_walk</code>得到的页目录项指针，一个小细节是要判断<code>ppte!=0</code>即<code>ppte</code>不是空指针</li></ul><h4 id="page-remove取消地址映射函数"><a href="#page-remove取消地址映射函数" class="headerlink" title="page_remove取消地址映射函数"></a><code>page_remove</code>取消地址映射函数</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">page_remove</span><span class="token punctuation">(</span>Pde <span class="token operator">*</span>pgdir<span class="token punctuation">,</span> u_int asid<span class="token punctuation">,</span> u_long va<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>取消地址映射函数，删除pgdir对应的两级页表结构中va这一虚拟地址对物理地址的映射，如果存在这样的映射，相应的物理页面引用次数会减少。</p><p>利用上面的<code>page_lookup</code>函数找到va在pgdir下对应的物理页面，如果不为0（说明确实va映射到了物理地址）则使其<code>pp_ref</code>减1，如果减完之后为0，则说明不再有va映射到该物理页面，调用<code>page_free</code>将其插回<code>page_free_list</code>。将二级页表项内容设置为0，并调用<code>tlb_invalidate</code>使得再次访问该va时会引发缺页异常。</p><h2 id="实验心得"><a href="#实验心得" class="headerlink" title="实验心得"></a>实验心得</h2><p>lab2的工作主要涉及两点：两级页表机制的实现，和TLB的维护。总的来说任务量相比前两次实验有所增加，在刚开始实验的时候对各种复杂的链表宏和指针理解起来非常困难，<del>边写边理解的过程好像也很折磨</del></p><p>不过总的来说完成lab2让我对二级页表和tlb的具体实现有了基本的概念，也加深了我对指针的理解。通过实验也能和理论所学的东西结合起来，总之还是学到了很多东西。</p>]]></content>
      
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OO_Unit1</title>
      <link href="/2024/03/20/oo-unit1/"/>
      <url>/2024/03/20/oo-unit1/</url>
      
        <content type="html"><![CDATA[<h1 id="OO-Unit1-表达式化简"><a href="#OO-Unit1-表达式化简" class="headerlink" title="OO_Unit1: 表达式化简"></a>OO_Unit1: 表达式化简</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本单元OO作业主题是对给定表达式化简，第一次作业要求将含有一个<code>x</code>变量的表达式的所有括号展开。</p><p>解析输入的符合课程组给定文法的表达式，对表达式的结构进行解析后进行化简，我使用了递归下降的方法对表达式解析。事实上关于表达式的解析和化简都是基于逐层递归的思想进行的——首先，表达式的解析是从上到下进行解析，核心是<code>parseExpr-&gt;parseTerm-&gt;parseFac</code>，从而建起有这三个层次的表达式树；然后再进行表达式的化简计算，这一步就是从下往上计算，计算结果可以用<code>Ploy</code>存储，每一步计算返回一个<code>Poly</code>，首先计算合并用<code>*</code>连接的<code>Factor</code>，再合并用<code>+/-</code>连接的<code>Term</code>，最终得到了<code>Poly</code>进行输出就可以了。</p><p>我在完成本单元三次作业时的困难程度是递减的，第一次作业由于对递归下降思想完全没有概念，光是理解并思考完架构就花了两天时间，第二次作业增加了两大模块分别是<code>exp</code>因子和自定义函数，再加上由于我第一次作业的架构并没有很完善需要部分重构，工作量也蛮大的；至于第三次作业只有一个求导算子，在理解递归下降的思想的基础上很快就可以做完。</p><p>下面是我对三次作业的分析和总结。</p><h3 id="homework1"><a href="#homework1" class="headerlink" title="homework1"></a>homework1</h3><p>第一次作业的任务是展开一个单变量多项式，输出拆好括号并化简的表达式。</p><h4 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h4><h5 id="表达式的解析"><a href="#表达式的解析" class="headerlink" title="表达式的解析"></a>表达式的解析</h5><p>解析工作由词法分析器<code>Lexer</code>和解析器<code>Parser</code>构成。<code>Lexer</code>负责将表达式解析为数字/符号<code>+-*^()</code>/字母<code>x</code>等基本元素(token)，为Parser的解析工作提供了<code>next()</code>函数来获取每一个元素。</p><p>接下来就是<code>parser</code>进行解析，最终的返回的是一个<code>Expr</code>。</p><p>我的<code>Expr</code>类中包含了只储存了一个<code>Expr</code>和一个<code>Term</code>，以及连接两者的符号<code>op</code>，在解析时以<code>expr -&gt; expr + term</code>形式建立表达式树。这里有一些细节需要注意：</p><ul><li>由于计算表达式是从左往右计算的，因此不能将表达式解析为<code>expr -&gt;term+ expr</code>的形式，否则会违反运算顺序。例如在计算1-1+1时若按上述方法解析就会变成1-(1+1)。</li><li>但如果按照<code>exp -&gt; exp + term</code>解析，就需要在调用<code>parseExp()</code>函数内直接再调用<code>parseExp()</code>，从而陷入无限递归，解决方法是先调用<code>parseTerm</code>解析出<code>Term1</code>，将其向上转换为<code>Expr</code>。如果其后还有<code>+/-</code>，则继续调用parseTerm解析出<code>Term2</code>，更新要返回的<code>Expr=Expr+Term2</code>；如果没有<code>+/-</code>，即为递归边界，直接返回<code>Expr(Term1)</code>。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Expr</span> <span class="token function">parseExpr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">Term</span> term1 <span class="token operator">=</span> <span class="token function">parseTerm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Exp</span> expr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Expr</span><span class="token punctuation">(</span>term1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//向上转化为Expr，结构为Expr-&gt;Term</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>lexer<span class="token punctuation">.</span><span class="token function">peak</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"+"</span><span class="token punctuation">)</span> <span class="token operator">|</span> lexer<span class="token punctuation">.</span><span class="token function">peak</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"-"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">String</span> op <span class="token operator">=</span> lexer<span class="token punctuation">.</span><span class="token function">peak</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            lexer<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">Term</span> term2 <span class="token operator">=</span> <span class="token function">parseTerm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            expr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Expr</span><span class="token punctuation">(</span>expr<span class="token punctuation">,</span> term2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//expr -&gt; expr + term</span>            expr<span class="token punctuation">.</span><span class="token function">setOp</span><span class="token punctuation">(</span>op<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> expr<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>Term</code>的解析思路同上，我以<code>Term -&gt; Factor * Term</code>对<code>Term</code>进行解析。由于乘法计算无需考虑从左到右的顺序，先解析<code>Factor</code>是没问题的。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Term</span> <span class="token function">parseTerm</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">Term</span> term <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Term</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        term<span class="token punctuation">.</span><span class="token function">setFactor</span><span class="token punctuation">(</span><span class="token function">parseFactor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>lexer<span class="token punctuation">.</span><span class="token function">peak</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"*"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            lexer<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            term<span class="token punctuation">.</span><span class="token function">setTerm</span><span class="token punctuation">(</span><span class="token function">parseTerm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> term<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样解析表达式后建立的树是一个类似于二叉树的结构。</p><img src="https://s21.ax1x.com/2024/03/20/pFWTjVP.jpg" alt="" width="70%"><p>关于符号的处理，我在<code>expr -&gt; expr + term</code>这一步记录了符号，此外在每种<code>Factor</code>都添加了<code>sign</code>属性。事实上后者是没有必要的，由于只有<strong>在第一个因子/项之前，可以带一个正号或者负号</strong>，而预处理时我会将积压在每个项前连续的<code>+-</code>号处理掉，所以得到的表达式只需在以下两个位置加入符号判断：1.<code>Factor</code>乘积构成的<code>Term</code>前判断加减 2.至于因子前的符号，根据文法只需在<code>NumFac</code>前判断该数字的正负。</p><h5 id="表达式的化简"><a href="#表达式的化简" class="headerlink" title="表达式的化简"></a>表达式的化简</h5><p>化简是在解析建好的表达式树从底层逐层向上化简。</p><p>引入<code>Mono</code>类，里面只有一个<code>exponent</code>记录<code>x</code>的指数。</p><p>这一步封装我做的不好，当时的我写到这一步已经是周五了，没有引入<code>Poly</code>。我在<code>Expr</code>、<code>Term</code>和各种<code>Factor</code>类中都写了<code>simplify()</code>方法直接返回一个<code>HashMap&lt;BigInteger,Mono&gt;</code>（也就是之后的<code>toPoly</code>），从<code>Factor</code>开始向上化简，最终在main中调用<code>expr.simplify()</code>即可获得最终化简好的HashMap。</p><h4 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h4><img src="https://s21.ax1x.com/2024/03/21/pFfNkdK.jpg" alt="" width="80%"><h4 id="Bug分析"><a href="#Bug分析" class="headerlink" title="Bug分析"></a>Bug分析</h4><p>第一次作业我在预处理时加上了一个去除前导零的操作，事实上不仅<code>BigInteger</code>会自动处理前导零，而且我还把这个函数写错了，结果是数字只要有0就会被我删去一部分，纯纯的多写了个bug。这是一个比较严重的错误了，让我没想到的是强测居然只挂了一个点，真是对这个无比致命的错误来说非常的友好了orz 于是我也在第一次oo作业就获得极致的互hack乱砍体验，我用一些随机生成的数据便收获了约30%的命中率，甚至最后不知道自己在砍谁（bushi</p><p>修复bug就是把我那几行预处理删掉，至今有时想到这个错误还是不知道自己当时是怎么想的。。</p><h3 id="homework2"><a href="#homework2" class="headerlink" title="homework2"></a>homework2</h3><p>第二次作业增加了：1.自定义函数 2.指数函数因子。此外要求实现多层括号嵌套化简，这一点递归下降自然可以解决。</p><h4 id="设计思路-1"><a href="#设计思路-1" class="headerlink" title="设计思路"></a>设计思路</h4><p>多项式<code>Poly</code>类内用<code>ArrayList&lt;Mono&gt;</code>存储各个单项式，符号直接在<code>coe</code>中体现。</p><p>单项式Mono的结构调整如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Mono</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">BigInteger</span> coe<span class="token punctuation">;</span> <span class="token comment">//系数</span>    <span class="token keyword">private</span> <span class="token class-name">BigInteger</span> exponent<span class="token punctuation">;</span> <span class="token comment">//指数</span>    <span class="token keyword">private</span> <span class="token class-name">Poly</span> poly <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Poly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//exp(Poly)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h5><p>$$<br>Define: f(x_1,x_2,x_3)= Expr，将x扩展为x_1，x_2，x_3<br>$$</p><p>$$<br>Call: f(Factor_1, Factor_2, Factor_3)，此处Factor_i只包含x<br>$$</p><p>第二次作业在定义函数的时候保证不出现其他函数，但第三次作业可以在定义中调用之前定义过的函数。我在第二次作业中就实现了这个功能。</p><p>引入<code>FuncFac</code>类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FuncFac</span> <span class="token keyword">implements</span> <span class="token class-name">Factor</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> newFunc<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Expr</span> expr<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>为了保存和解析定义的函数，新建一个<code>Define</code>类来存储和解析自定义函数。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Define</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> defMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//储存读入的函数定义，Map：函数名-&gt;函数表达式，直接存储为String</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">ArrayList</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> paraMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//储存每个函数的形参列表：Map：函数名-&gt;[x1,x2,x3]</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">addFunc</span><span class="token punctuation">(</span><span class="token class-name">String</span> in<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 构造defMap</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">callFunc</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Factor</span><span class="token punctuation">&gt;</span></span> actualPara<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">//返回用实参代替、形参之后的函数调用形式</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我让<code>lexer</code>在处理过程中将整个函数调用<code>f(因子,因子,...)</code>作为一个<code>Token</code>，交给parser中的<code>parseFuncFac</code>函数解析。我们建立<code>ArrayList&lt;Factor&gt; actualPara</code>作为该函数的实参表，只要将括号内的由<code>,</code>隔开的各个因子解析出来放到List中就可以了。考虑到因子内可能依然含有<code>FuncFac</code>，我将括号里各个因子内部的,替换为不会出现的其他符号，再在分别解析因子的时候替换回来。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Factor</span> <span class="token function">parseFuncFac</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Factor</span><span class="token punctuation">&gt;</span></span> actualPara <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/*    * 将因子内的','换成其他字符    */</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> s <span class="token operator">:</span> str<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//将因子s中原本的,恢复</span>        <span class="token comment">//新建一个parser解析各个Factor</span>    <span class="token punctuation">}</span>    <span class="token comment">//解析name=f/g/h</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FuncFac</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> actualPara<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>至此再调用<code>FuncFac</code>的构造函数，解析<code>Define</code>中的<code>callFunc</code>返回的字符串，这样就得到解析好的函数的<code>Expr</code>了。</p><h5 id="表达式因子"><a href="#表达式因子" class="headerlink" title="表达式因子"></a>表达式因子</h5><p>格式是<code>exp(因子)</code>，注意这里的因子为<strong>不带指数的表达式因子</strong>时，该表达式因子两侧必要的一层括号。为此引入<code>ExpoFac</code>类。<code>parser</code>分别解析括号内的因子和括号外的指数即可。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ExpoFac</span> <span class="token keyword">implements</span> <span class="token class-name">Factor</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">Factor</span> factor<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">BigInteger</span> exp<span class="token punctuation">;</span><span class="token comment">//^a</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>作为<code>Factor</code>转化为<code>Poly</code>时，直接将指数<code>a</code>乘进<code>factor</code>。</p><h5 id="关于合并同类项"><a href="#关于合并同类项" class="headerlink" title="关于合并同类项"></a>关于合并同类项</h5><p>在计算的过程中<code>Poly</code>类中有一个<code>addMono</code>的方法，我直接遍历该<code>poly</code>的<code>MonoList</code>是否含有待加入<code>mono</code>的同类项，也就是需要重写<code>mono</code>的<code>equals</code>方法。<br>$$<br>Mono = Coe * x^{a} * exp (Poly)<br>$$</p><p>$$<br>Poly=\sum_{}^{}Mono<br>$$</p><p>要想判断两个<code>mono</code>是否可以合并，只需要比较<code>x</code>的指数<code>a</code>以及<code>e</code>指数上的<code>Poly</code>，这两者均相等就可以合并。作为<code>BigInteger</code>的<code>a</code>直接比较即可，而<code>Poly</code>的相等则需要我们再写相应的<code>equals</code>方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//Mono.java</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">myEqual</span><span class="token punctuation">(</span><span class="token class-name">Mono</span> mono<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//第一次调用Mono的equal，不需要看coe</span>    <span class="token keyword">return</span> exponent<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>mono<span class="token punctuation">.</span>exponent<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>poly<span class="token punctuation">,</span> mono<span class="token punctuation">.</span>poly<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那么<code>Poly</code>相等该如何判断呢？显然所有<code>Mono</code>相等时才能算是相等。这里我遇到了两个问题：</p><ul><li><p>对于<code>Poly</code>的比较我们实际上需要比较两个<code>List</code>中的元素是否完全一样，而<code>MonoList</code>中的<code>Mono</code>由于被add进来时顺序是未知的，那么这两个<code>List</code>该如何比较？</p><ul><li>我们第一次调用<code>mono</code>是否相等时是不需要比较<code>Coe</code>的。然而在比较<code>exp</code>指数上的内容时需要的是<code>mono</code>完全相等，系数也需要加入比较。否则如果按照最开始的<code>mono</code>比较策略就会出现将<code>exp(x)</code>和<code>exp((3*x))</code>合并的情况。</li></ul></li></ul><p>为了解决以上问题，我在<code>Poly</code>中重写了<code>equals</code>方法，返回的是同时比较<code>coe</code>，指数<code>a</code>和<code>poly</code>的结果。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//...</span>        <span class="token keyword">return</span> <span class="token class-name">Mono</span><span class="token punctuation">.</span><span class="token function">myEqual</span><span class="token punctuation">(</span>monos<span class="token punctuation">,</span> poly<span class="token punctuation">.</span>monos<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这需要我在<code>Mono</code>中写的另一个静态的用于比较的方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">myEqual</span><span class="token punctuation">(</span><span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Mono</span><span class="token punctuation">&gt;</span></span> m1<span class="token punctuation">,</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Mono</span><span class="token punctuation">&gt;</span></span> m2<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> m1<span class="token punctuation">.</span><span class="token function">containsAll</span><span class="token punctuation">(</span>m2<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> m2<span class="token punctuation">.</span><span class="token function">containsAll</span><span class="token punctuation">(</span>m1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里的<code>containsAll</code>会调用我重写的<code>Mono</code>的<code>equals</code>比较方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//...</span>        <span class="token class-name">Mono</span> mono <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Mono</span><span class="token punctuation">)</span> o<span class="token punctuation">;</span>        <span class="token keyword">return</span> exponent<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>mono<span class="token punctuation">.</span>exponent<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>coe<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>mono<span class="token punctuation">.</span>coe<span class="token punctuation">)</span>                <span class="token operator">&amp;&amp;</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>poly<span class="token punctuation">,</span> mono<span class="token punctuation">.</span>poly<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//此后调用的都是Poly的equals方法，需要比较系数</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里还有两个细节要注意：</p><p>1.在比较<code>Poly</code>之前还需要<code>removeZero()</code>操作，以除去<code>coe</code>为0的项。</p><p>2.关于深克隆：需要在<code>addMono</code>这个函数中深克隆。如果不进行深克隆，会出现把<code>Mono</code>直接放到<code>poly</code>相乘的结果中，之后<code>setCoe</code>的时候会由于指针指向同一个<code>Mono</code>而导致本来想修改的是答案<code>Poly</code>的系数，但顺便也把原先作为乘数<code>Poly</code>中的<code>Mono</code>也改了。我和这个问题从早上决斗到下午才改好。</p><p>结合这样一个例子就可以说明：<code>(exp(x)+1)^2</code>。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//Poly.java</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addMono</span><span class="token punctuation">(</span><span class="token class-name">Mono</span> mono<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">CloneNotSupportedException</span> <span class="token punctuation">{</span>    <span class="token comment">//计算Poly+Mono</span>    <span class="token class-name">Mono</span> monoClone <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Mono</span><span class="token punctuation">)</span> mono<span class="token punctuation">.</span><span class="token function">myClone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">if</span><span class="token punctuation">(</span>可以合并同类项<span class="token punctuation">)</span><span class="token punctuation">{</span>            m<span class="token punctuation">.</span><span class="token function">setCoe</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">getCoe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>mono<span class="token punctuation">.</span><span class="token function">getCoe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>monos<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>monoClone<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="结果输出"><a href="#结果输出" class="headerlink" title="结果输出"></a>结果输出</h5><p>我在<code>Mono</code>和<code>Poly</code>类中分别写了<code>toString</code>方法用于输出。</p><p>需要注意的是在<code>toString</code>的规范：只进行转换为字符串的操作。<strong>不要在<code>toString</code>里做一些改变对象内容的事请</strong>。如果在该函数中改变了对象中的内容可能会导致调试的时候结果正确而最后输出错误的情况。调试的时候对于对象会自动调用<code>toString</code>函数，如果没有写<code>toString</code>就会输出<code>@(toHex)HashCode</code>。</p><img src="https://s21.ax1x.com/2024/03/21/pFfGox1.png" alt="" width="90%"><h5 id="UML类图-1"><a href="#UML类图-1" class="headerlink" title="UML类图"></a>UML类图</h5><img src="https://s21.ax1x.com/2024/03/21/pFfNAIO.jpg" alt="" width="100%"><h3 id="homework3"><a href="#homework3" class="headerlink" title="homework3"></a>homework3</h3><h5 id="设计思路-2"><a href="#设计思路-2" class="headerlink" title="设计思路"></a>设计思路</h5><p>第三次作业增加了求导因子。第三次作业在我们之前的递归下降架构上很快就能写好。为此我加入<code>DiffFac</code>类。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DiffFac</span> <span class="token keyword">implements</span> <span class="token class-name">Factor</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">Expr</span> expr<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>先把每个因子的<code>toDiff()</code>写了，全部返回<code>Poly</code>。至于求导因子的嵌套需要如下处理。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token class-name">Poly</span> <span class="token function">toDiffPoly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">CloneNotSupportedException</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> expr<span class="token punctuation">.</span><span class="token function">toDiffPoly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toDiffPoly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>所以还要对<code>Mono</code>和<code>Poly</code>的求导，求导的过程也很直观。这里只要注意一下指数为0的时候返回<code>0</code>就可以了。</p><p>$$<br>Mono’ = (Coe*a) * x^{a-1} * exp (Poly)+Coe*x^{a}*exp(Poly)*Poly’<br>$$</p><p>$$<br>Poly’=\sum_{}^{}mono’<br>$$</p><h5 id="UML类图-2"><a href="#UML类图-2" class="headerlink" title="UML类图"></a>UML类图</h5><img src="https://s21.ax1x.com/2024/03/21/pFft829.png" alt="" width="100%"><h5 id="Bug分析-1"><a href="#Bug分析-1" class="headerlink" title="Bug分析"></a>Bug分析</h5><p>所幸后两次作业强测没有出现Bug，后两次发现的别人的Bug有：无法处理类似于<code>f((x)^2)</code>后面的指数，还有指数没改为<code>BigInteger</code>的，但由于cost我无法hack，以及一些tle。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><table><thead><tr><th>method</th><th>CogC</th><th align="left">ev(G)</th><th>iv(G)</th><th>v(G)</th></tr></thead><tbody><tr><td>Change.dealComa(String)</td><td>19.0</td><td align="left">1.0</td><td>6.0</td><td>10.0</td></tr><tr><td>Define.callFunc(String, ArrayList)</td><td>18.0</td><td align="left">3.0</td><td>7.0</td><td>13.0</td></tr><tr><td>Lexer.next()</td><td>8.0</td><td align="left">2.0</td><td>6.0</td><td>9.0</td></tr><tr><td>Poly.isSimple()</td><td>8.0</td><td align="left">4.0</td><td>6.0</td><td>6.0</td></tr><tr><td>Mono.toString()</td><td>7.0</td><td align="left">2.0</td><td>4.0</td><td>6.0</td></tr><tr><td>Parser.parseFactor()</td><td>7.0</td><td align="left">6.0</td><td>8.0</td><td>8.0</td></tr><tr><td>Lexer.getFunc()</td><td>6.0</td><td align="left">1.0</td><td>3.0</td><td>5.0</td></tr><tr><td>Parser.parseExpr()</td><td>6.0</td><td align="left">1.0</td><td>4.0</td><td>5.0</td></tr><tr><td>Term.toDiffPoly()</td><td>6.0</td><td align="left">1.0</td><td>4.0</td><td>4.0</td></tr><tr><td>Define.addFunc(String)</td><td>4.0</td><td align="left">1.0</td><td>3.0</td><td>5.0</td></tr><tr><td>Poly.addPoly(Poly, int)</td><td>4.0</td><td align="left">1.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Mono.equals(Object)</td><td>3.0</td><td align="left">3.0</td><td>3.0</td><td>5.0</td></tr><tr><td>Parser.parseNumFac()</td><td>3.0</td><td align="left">1.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Poly.addMono(Mono)</td><td>3.0</td><td align="left">3.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Poly.changeOrder()</td><td>3.0</td><td align="left">3.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Poly.mulPoly(Poly, Poly)</td><td>3.0</td><td align="left">1.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Poly.removeZero()</td><td>3.0</td><td align="left">1.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Poly.toString()</td><td>3.0</td><td align="left">2.0</td><td>3.0</td><td>4.0</td></tr><tr><td>ExprFac.toDiffPoly()</td><td>2.0</td><td align="left">2.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Lexer.getNumber()</td><td>2.0</td><td align="left">1.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Mono.toDiffPoly()</td><td>2.0</td><td align="left">1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Poly.addPolyNew(Poly, Poly)</td><td>2.0</td><td align="left">1.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Poly.equals(Object)</td><td>2.0</td><td align="left">3.0</td><td>1.0</td><td>3.0</td></tr><tr><td>Poly.powPoly(Poly, BigInteger)</td><td>2.0</td><td align="left">2.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Term.toPoly()</td><td>2.0</td><td align="left">2.0</td><td>2.0</td><td>3.0</td></tr><tr><td>VarFac.toDiffPoly()</td><td>2.0</td><td align="left">1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>ExpoFac.toPoly()</td><td>1.0</td><td align="left">2.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Expr.toDiffPoly()</td><td>1.0</td><td align="left">1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Expr.toPoly()</td><td>1.0</td><td align="left">1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Main.main(String[])</td><td>1.0</td><td align="left">1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Mono.isOnlyE()</td><td>1.0</td><td align="left">1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Mono.isOnlyX()</td><td>1.0</td><td align="left">1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Mono.myEqual(ArrayList, ArrayList)</td><td>1.0</td><td align="left">1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Mono.myEqual(Mono)</td><td>1.0</td><td align="left">1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Parser.parseExponent()</td><td>1.0</td><td align="left">1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Parser.parseFuncFac()</td><td>1.0</td><td align="left">1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Parser.parseTerm(int)</td><td>1.0</td><td align="left">1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Poly.myClone()</td><td>1.0</td><td align="left">1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Poly.toDiffPoly()</td><td>1.0</td><td align="left">1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Change.process(String)</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>DiffFac.DiffFac(Expr)</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>DiffFac.toDiffPoly()</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>DiffFac.toPoly()</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>ExpoFac.ExpoFac(Factor, BigInteger)</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>ExpoFac.toDiffPoly()</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Expr.Expr()</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Expr.addTerm(Term)</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>ExprFac.ExprFac(Expr, BigInteger)</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>ExprFac.toPoly()</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>FuncFac.FuncFac(String, ArrayList)</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>FuncFac.toDiffPoly()</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>FuncFac.toPoly()</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Lexer.Lexer(String)</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Lexer.peak()</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Mono.Mono(BigInteger, BigInteger)</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Mono.Mono(BigInteger, BigInteger, Poly)</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Mono.Mono(Poly)</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Mono.getCoe()</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Mono.getExponent()</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Mono.getPoly()</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Mono.mulMono(Mono, Mono)</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Mono.myClone()</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Mono.setCoe(BigInteger)</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Mono.setExponent(BigInteger)</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>NumFac.NumFac(BigInteger)</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>NumFac.toDiffPoly()</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>NumFac.toPoly()</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Parser.Parser(Lexer)</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Parser.parseDiffFac()</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Parser.parseExpoFac()</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Parser.parseExprFac()</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Parser.parseVarFac()</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Poly.Poly()</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Term.Term()</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Term.addFactor(Factor)</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Term.getSign()</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Term.setSign(int)</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>VarFac.VarFac(BigInteger)</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>VarFac.toPoly()</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Total</td><td>143.0</td><td align="left">104.0</td><td>159.0</td><td>185.0</td></tr><tr><td>Average</td><td>1.810</td><td align="left">1.316</td><td>2.013</td><td>2.342</td></tr></tbody></table><p>我在处理函数逗号的<code>dealComa</code>方法中引入了较为复杂的循环分支以支持处理嵌套函数，其实这里的嵌套交给parser也可以完成。还有就是<code>Define</code>中<code>callFunc</code>中我分别判断是<code>x/y/z</code>使得复杂度较高。我在<code>Mono</code>的<code>toString</code>中做了一些简化，同样需要各种判断。但除了<code>Lexer</code>和<code>ParseFactor</code>需要解析各种Token和因子，<code>if-else</code>难免较多之外，前面提到的还是可以进一步优化解耦使得框架更为清晰。</p><h3 id="总结与心得"><a href="#总结与心得" class="headerlink" title="总结与心得"></a>总结与心得</h3><ul><li><p>在优化方面我则基本没做，每次做完作业就都剩下<code>TODO</code>，甚至将正项提前这一基本的优化我也是第二次才做。</p></li><li><p>本单元第一次作业由于我封装的不够彻底，直到第二次作业才开始引入<code>Poly</code>类。好在思路还是统一的，并没有进行大规模的修改。</p></li></ul><p>本单元的递归下降方法要求我们写代码时头脑非常清晰，需要明确每一层递归到底发生了什么。我对面向对象思维的理解也更为深刻，在思考架构的时候尽量降低代码间的耦合度。此外我在判断对象相等时所用的<code>equals</code>和<code>HashCode</code>相关知识有了更进一步的了解，其中有很多更深刻的知识有待学习，总而言之还是很有收获的一次作业。</p>]]></content>
      
      
      
        <tags>
            
            <tag> OO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OO_Unit2</title>
      <link href="/2024/03/20/oo-unit3/"/>
      <url>/2024/03/20/oo-unit3/</url>
      
        <content type="html"><![CDATA[<h1 id="OO-Unit3-规格化设计"><a href="#OO-Unit3-规格化设计" class="headerlink" title="# OO_Unit3: 规格化设计"></a># OO_Unit3: 规格化设计</h1><h3 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h3><h4 id="hw9"><a href="#hw9" class="headerlink" title="hw9"></a>hw9</h4><p>在我的实现下，首先需要明确：并查集本身并不知道两个节点之间是否认识，通过<code>find</code>找到的父亲相等只代表两者是<strong>可达的</strong>(isCircle)。所以并查集的作用只是：<strong>判断两个人是否可达，而非是否认识，只是为了维护Block的个数。</strong></p><p>使用延迟重建整个并查集的思路：在MyNetwork类中设置一个脏位needRebuild，如果有删边操作就把脏位设置为true，这时认为整个并查集已经失效。</p><p>具体思路如下，是一个简单易行的做法。</p><table><thead><tr><th>指令</th><th>操作</th></tr></thead><tbody><tr><td>ar（加边）</td><td>如果脏位为0，则维护并查集（进行merge）；否则不维护</td></tr><tr><td>mr（删边）</td><td>将脏位设置为1，此时认为整个并查集已经失效</td></tr><tr><td>询问（isCircle和qbs）</td><td>如果脏位为1，重建整个并查集，否则并查集有效</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> OO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OO_Unit2</title>
      <link href="/2024/03/20/oo-unit2/"/>
      <url>/2024/03/20/oo-unit2/</url>
      
        <content type="html"><![CDATA[<h1 id="OO-Unit2-电梯调度"><a href="#OO-Unit2-电梯调度" class="headerlink" title="OO_Unit2: 电梯调度"></a>OO_Unit2: 电梯调度</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>OO第二单元主要是对多部电梯的运行进行模拟，要求我们使用多线程编程，难点在于理解线程交互过程，需要通过对合适的共享对象加锁来解决线程安全问题。多个线程的同步进行使得需要分析的情况变得复杂多变，而且错误是概率出现的，增加了作业完成和debug难度。随着作业结构越发复杂，更需要理清电梯调度的时序等多种细节，总之要清楚某些时刻电梯在干什么事儿才能尽量避免bug的出现。</p><h3 id="hw5"><a href="#hw5" class="headerlink" title="hw5"></a>hw5</h3><p>电梯第一次作业需要管理6部电梯，题目已经给出每个<code>Request</code>需要乘坐的电梯ID。本次作业我对多线程设计有了基本的概念，对synchronize同步块和锁的设置有了初步体会。此外我也意识到解耦的重要性，运用好面向对象思想，使用好的架构和明确的分工会让整个作业的构建和调试难度大大降低，同时也会让自己的思路更加清晰明确。</p><h4 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h4><h5 id="生产者-消费者模型"><a href="#生产者-消费者模型" class="headerlink" title="生产者-消费者模型"></a>生产者-消费者模型</h5><p>本次作业首先要解决的是如何将乘客请求正确分配给电梯。</p><p>我用<code>RequestTable</code>类来存储请求。该类实例化为以下两种请求队列：</p><ul><li><code>allRequest</code>：用于存放来自输入所有的请求。</li><li><code>ElevatorReqTable</code>：每个电梯都会实例化一个该电梯专有的请求，用于存放该电梯要处理的请求队列。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RequestTable</span> <span class="token punctuation">{</span>    <span class="token comment">//&lt;楼层序号，出发地在该楼层的请求&gt;</span>    <span class="token keyword">private</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">ArrayList</span><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> requestMap<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> isEnd<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我使用生产者-消费者模型，其中生产者是输入线程类<code>Input</code>，该类拥有实例<code>allRequest</code>，每当有请求输入进来就新建一个<code>Person</code>加入到<code>allRequest</code>中；消费者是<code>Elevator</code>类，每个实例化的电梯都有自己的<code>eleReqTable</code>作为待处理请求。此外输入线程类还负责在输入结束后将总请求队列的<code>isEnd</code>置1代表不再会有新请求，输入结束。</p><p><code>Manager</code>类在这里发挥分配请求的作用，同时拥有以上两种<code>RequestTable</code>。主要负责：</p><ul><li><p>如果<code>allRequest</code>中还有请求，则将其pop出来，按照所需乘坐的电梯id交给相应的电梯自己的<code>eleReqTable</code>。</p></li><li><p>如果<code>allRequest</code>中没有请求了而且<code>isEnd</code>为1，则将电梯的子table也设为结束结束本进程。</p></li></ul><p>至此电梯类通过成员变量<code>eleReqTable</code>获得了自己需要处理的请求。这时电梯需要根据自身状态以及请求决定其行为。</p><h5 id="电梯调度"><a href="#电梯调度" class="headerlink" title="电梯调度"></a>电梯调度</h5><p>我的电梯类有如下成员变量：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Elevator</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">,</span> <span class="token class-name">RequestTable</span> reqTable<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>reqTable <span class="token operator">=</span> reqTable<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>curFloor <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>curNum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//电梯内总人数</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>direction <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>destMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// HashMap&lt;Integer, ArrayList&lt;Person&gt;&gt;，当前在电梯内部的Person，按照目的地层数划分</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>strategy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Strategy</span><span class="token punctuation">(</span>reqTable<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>电梯会有如下的行为：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">move</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//电梯沿着原方向移动一层，改变curFloor即可</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token class-name">OpenAndClose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//电梯开门，人员先下后上getOut(),getIn()，关门</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//电梯转向，direction取反</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">getOut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//目的地为这一层的人全部出去，直接将destMap整个键删去</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">getIn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//从电梯请求队列移除，delRequest返回需要进入电梯的Person列表</span>        <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">&gt;</span></span> inPersonList <span class="token operator">=</span> reqTable<span class="token punctuation">.</span><span class="token function">delRequest</span><span class="token punctuation">(</span>curFloor<span class="token punctuation">,</span> <span class="token number">6</span> <span class="token operator">-</span> curNum<span class="token punctuation">,</span> direction<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Person</span> per <span class="token operator">:</span> inPersonList<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">//加入电梯的destMap</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>电梯该如何决定进行何种行为，需要引入<code>Strategy</code>策略类，该类中的一个<code>getAdvice</code>函数会将具体策略<code>(OPEN, MOVE, REVERSE, WAIT, END)</code>交给电梯。所以策略类需要获取当前电梯的请求队列，在之前电梯构造创建自己的<code>Strategy</code>时已经作为<code>Strategy</code>自己的成员变量传入了；至于当前电梯的状态则会在调用<code>getAdvice</code>函数时作为参数传入，具体来说就是：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Advice</span> <span class="token function">getAdvice</span><span class="token punctuation">(</span><span class="token keyword">int</span> curFloor<span class="token punctuation">,</span> <span class="token keyword">int</span> curNum<span class="token punctuation">,</span> <span class="token keyword">int</span> dir<span class="token punctuation">,</span>                       <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">ArrayList</span><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> destMap<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>接下来执行具体的电梯调度策略就行了，这里我选择了简单易行的LOOK算法。</p><h5 id="锁的设置"><a href="#锁的设置" class="headerlink" title="锁的设置"></a>锁的设置</h5><p>由于<code>RequestTable</code>类在多个线程中使用，因此对这个类的任何读写操作我都加了锁。此外，由于对<code>RequestTable</code>的任何读写操作我都在该类内完成，我的所有<code>synchronized</code>块全部而且仅出现在请求类中。具体来说，读写<code>RequestTable</code>类主要分为以下几种情况：</p><ul><li><code>addPerson</code>: 两类请求都要用，用于向请求队列中加入新的请求<code>(Person)</code>。</li><li>由主请求队列<code>allRequest</code>调用的：<ul><li><code>popPerson</code>: 从主请求中pop出一个Person用于分配给电梯子请求。</li></ul></li><li>由电梯的分请求队列<code>eleReqTable</code>调用的：<ul><li><code>delRequest</code>: 用于从电梯子请求队列中移除一些符合要求的请求，即代表这些Person进入电梯。</li></ul></li><li>上面的方法全都要加锁，此外还有一些判断Map是否为空，读和写<code>isEnd</code>和其他一些队列情况的方法，也需要上锁。这样我的读写全部封装在类内进行，外面只需要调用这些函数即可。</li></ul><p>至于<code>notifyAll</code>，当一个线程调用了某个对象的 <code>notifyAll()</code> 方法时，该对象上所有调用了 <code>wait()</code> 方法而被挂起的线程都将被唤醒，然后它们会竞争对象上的锁。考虑我整个程序中的两个需要<code>wait</code>的地方：</p><ul><li>主请求队列在<code>popPerson</code>时主请求队列空了，但输入还没有结束，也就是需要等待外部输入新的请求。在这种情况下：①若外部输入了新的请求，则会通过<code>addPerson</code>函数进行，所以<code>addPerson</code>我增加了<code>notifyAll()</code> 来唤醒。②如果不会再有新的输入，就会执行<code>setEnd</code>，所以在<code>setEnd</code>也增加<code>notifyAll()</code>。</li><li>在每个电梯的分请求队列中同理，不过主请求等待的是<code>Input</code>传入，分请求等待<code>Manager</code>的分配。</li></ul><p>所以我只在上述两个函数里进行了<code>notifyAll()</code>。</p><h4 id="Bug分析"><a href="#Bug分析" class="headerlink" title="Bug分析"></a>Bug分析</h4><p>强测和互测没有出现bug，需要注意的是：</p><ul><li>超载判断：我一开始在<code>Strategy</code>内判断需要是否需要开门的时候想着先下后上，因此没有在<code>getAdvice</code>中判断是否超载，只在电梯内执行<code>getIn</code>的时候进行了判断。但这造成了电梯一直在某层开关门停不下来的情况。原因是：<code>openToOut(...) | openToIn(...)</code>这一<code>|</code>关系代表着，在没有人在这一层要下电梯的时候才会进行判断有没有人要上电梯的操作，既然没人要下电梯就必然要判断是否超载，因为如果在这里不判断的话返回的就会是开门操作，开门又发现人进不去，于是就造成了上述的死循环。在<code>openToIn</code>中判断人数是否超载即可。</li><li>由于会对请求队列的<code>Map</code>进行是否为空的判断，在进行<code>Map</code>的删除时，我都进行了<strong>这个键对应的List是否为空</strong>的判断，如果为空就直接把这个键删除，这样保证在没有请求（请求被删干净）之后<code>Map</code>也是空的。</li></ul><h4 id="UML类图-amp-时序图"><a href="#UML类图-amp-时序图" class="headerlink" title="UML类图&amp;时序图"></a>UML类图&amp;时序图</h4><img src="https://s21.ax1x.com/2024/03/29/pFobQ81.png" width="100%"><img src="https://s21.ax1x.com/2024/04/19/pkSkfDH.png" style="zoom:50%;"><h3 id="hw6"><a href="#hw6" class="headerlink" title="hw6"></a>hw6</h3><h4 id="设计思路-1"><a href="#设计思路-1" class="headerlink" title="设计思路"></a>设计思路</h4><p>第二次迭代新增了电梯<code>RESET</code>功能，电梯接收到重置请求后尽快停下，将所有人放出后修改相关属性，再投入使用，此外还需要自行设计电梯的分配。为了杜绝自由竞争的使用，需要电梯接到请求后输出<code>RECEIVE</code>后才能进行合法移动。</p><h5 id="处理RESET请求"><a href="#处理RESET请求" class="headerlink" title="处理RESET请求"></a>处理RESET请求</h5><p>首先对于<code>RESET</code>的处理，调度器<code>Manager</code>类新增方法<code>resetElevator</code>，该方法修改需重置电梯对应<code>RequestTable</code>的<code>resetRequest</code>属性，使其从原先的<code>null</code>变成相应的重置请求。那么电梯便可以在<code>getAdvice</code>时获得<code>RESET</code>的建议，从而执行重置请求。注意请求表类中的<code>setResetReq</code>方法需要<code>notifyAll</code>。此外结束条件需要加上一条：所有电梯都不在reset才能结束。</p><p>需要注意的是电梯的<code>reset</code>执行顺序。如果先把<code>Person</code>扔回总表再输出，可能出现同一个人被<code>RECEIVE</code>两次的情况，所以要先立即输出<code>RESET_BEGIN</code>。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">allOut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//电梯内的乘客清空，扔回电梯请求队列</span>    <span class="token class-name">TimableOutput</span><span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"RESET_BEGIN-"</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">&gt;</span></span> personList <span class="token operator">=</span> reqTable<span class="token punctuation">.</span><span class="token function">delAllRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    allRequest<span class="token punctuation">.</span><span class="token function">getAllRequest</span><span class="token punctuation">(</span>personList<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//执行重置，sleep 1.2s</span>        <span class="token class-name">TimableOutput</span><span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"RESET_END-"</span> <span class="token operator">+</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>    reqTable<span class="token punctuation">.</span><span class="token function">setResetReq</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="电梯调度-1"><a href="#电梯调度-1" class="headerlink" title="电梯调度"></a>电梯调度</h5><p><code>import java.util.Random;</code></p><p>为了保证正确性我直接采用随机策略。在随机到一个电梯之后只要不在reset就返回其id，如果恰好所有电梯都在reset状态就睡一会儿。这个策略使我在互测从上午10点被hack到第二天下午5点钟，原因在于当只剩下一部电梯可运行时，我的调度策略会把所有请求全部给剩下一部电梯，导致<code>rtle</code>。修改也很简单，就是判断一下仅当<code>≥3</code>部电梯在运行时才进行任务分配。</p><h4 id="Bug分析-1"><a href="#Bug分析-1" class="headerlink" title="Bug分析"></a>Bug分析</h4><p>本次作业强测由于采取了随机策略分数不高但没有出现问题。互测则出现了上述未限流导致的一个问题。</p><p>此外，课下我在交中测时发现自己出现了近10s的cpu时间<del>但不知道为什么一直没ctle</del>，于是我开始寻找轮询的可能性。在使用idea自带的Profiler运行时我发现我的cpu浪费了大量资源在<code>Manager</code>的<code>run</code>方法中。打印输出发现在这个循环内出现了轮询的情况。当电梯输入全部结束且主请求表为空时，就会进入判断是否全都不在reset状态。如果得到了<code>false</code>，就会迅速无限重复上述过程造成了轮询，解决方法就是加一个else让程序睡过去。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>allRequest<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> allRequest<span class="token punctuation">.</span><span class="token function">isEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">allNotReset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">//...</span>                <span class="token comment">//输入结束，将所有子table设为结束，本进程结束</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token class-name">Person</span> per <span class="token operator">=</span> allRequest<span class="token punctuation">.</span><span class="token function">popPerson</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>per <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//将Person分配给电梯</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="UML类图-amp-时序图-1"><a href="#UML类图-amp-时序图-1" class="headerlink" title="UML类图&amp;时序图"></a>UML类图&amp;时序图</h4><img src="https://s21.ax1x.com/2024/04/15/pFvRJYQ.png"><img src="https://s21.ax1x.com/2024/04/19/pkSkWKe.png" style="zoom:50%;"><h3 id="hw7"><a href="#hw7" class="headerlink" title="hw7"></a>hw7</h3><p>第7次作业增加了双轿厢电梯的重置请求，复杂度进一步提高。</p><h4 id="设计思路-2"><a href="#设计思路-2" class="headerlink" title="设计思路"></a>设计思路</h4><p>本次作业我将<code>Manager</code>改为单例模式，这样做的好处是其他类需要使用总表<code>allRequest</code>的时候可以通过<code>Manager</code>直接获取，实现起来更加清晰和安全。此外前两次作业我在main函数让各个线程分别开始跑，本次作业改为层次化的<code>start</code>，使得程序层次更清晰。</p><p>我在<code>Manager</code>类中实现两类电梯的创建和管理。首先是<code>Manager</code>的构造方法负责创建总表，6个电梯的分请求表对象，以及6部电梯的启动。实际上我们在调度器<code>Manager</code>中并非直接管理电梯，甚至不需要专门设置管理<code>Elevator</code>电梯类的容器——我们实际上都是通过操作电梯所对应的<code>requestTable</code>来进行管理的。我先前使用<code>List</code>管理6个请求表，但考虑到之后有双轿厢电梯和普通电梯同时运行，本次作业我简单地使用<code>HashMap&lt;Integer, RequestTable&gt; requestMap</code>统一管理两种电梯。具体映射方法如下。初始就只需新建key为1-6的电梯请求表。查看给定<code>id</code>的电梯，如果是普通电梯就会存在<code>key=id</code>， 如果是双轿电梯则存在<code>key=id + 6</code>和<code>key=id + 12</code>。</p><table><thead><tr><th align="center">Key</th><th align="center">Value</th></tr></thead><tbody><tr><td align="center">1-6</td><td align="center">普通电梯1-6的请求表</td></tr><tr><td align="center">7-12</td><td align="center">双轿厢电梯A1-A6的请求表</td></tr><tr><td align="center">13-18</td><td align="center">双轿厢电梯B1-B6的请求表</td></tr></tbody></table><h5 id="双轿厢电梯RESET"><a href="#双轿厢电梯RESET" class="headerlink" title="双轿厢电梯RESET"></a>双轿厢电梯RESET</h5><p>这类请求相当于需要把原来的电梯直接弃用，再new两个新电梯。关于请求的设置思路与<code>NormalReset</code>相同，依然是在电梯相应的<code>requestTable</code>里修改属性，然后电梯通过<code>Advice</code>得到。不同的是原先的电梯线程执行完<code>dcReset</code>之后就可以光荣下岗了，我的实现中直接将其<code>break</code>掉，线程结束。</p><p>至于电梯的<code>dcReset</code>函数，同样需要将电梯里的人全都赶出去扔回总表，打印等流程，然后我令其调用<code>Manager</code>创建双轿厢电梯的方法，然后该电梯圆满完成任务。</p><p><code>createLine</code>新建双轿厢电梯，引入<code>Line</code>类实现双轿厢电梯的管理，在其中设置新电梯的相关属性并使其<code>start</code>即可。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">createLine</span><span class="token punctuation">(</span><span class="token class-name">DoubleCarResetRequest</span> dcReq<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//新创建 requestTableA，requestTableB</span>requestMap<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>eleId<span class="token punctuation">)</span><span class="token punctuation">;</span>    requestMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>eleId <span class="token operator">+</span> <span class="token number">6</span><span class="token punctuation">,</span> requestTableA<span class="token punctuation">)</span><span class="token punctuation">;</span>    requestMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>eleId <span class="token operator">+</span> <span class="token number">12</span><span class="token punctuation">,</span> requestTableB<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//...</span>   <span class="token comment">//新建Line</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="电梯防撞"><a href="#电梯防撞" class="headerlink" title="电梯防撞"></a>电梯防撞</h5><p>另一个重点就是如何避免电梯在A，B共享的停靠层相撞。引入<code>Floor</code>类作为一对双轿电梯的共享对象，在创建<code>Line</code>对象的时候将其作为电梯的属性分配给两个新电梯。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Floor</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> isOccupied<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">RequestTable</span> reqTableA<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">RequestTable</span> reqTableB<span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当双轿厢类型电梯在运行<code>move()</code>的时候需要特判一下：如果电梯下一步会<code>move</code>到换乘层，就需要判断<code>Floor</code>是否被占用。同样地使用<code>RequestTable</code>作为信息传递的媒介,新增<code>isNeedAway</code>属性即可。同样需要判断，如果双轿厢电梯离开了换乘层将<code>occupied</code>标志解除占用。</p><p>另一个重要的问题是如果电梯已经占有<code>floor</code>，移动到了换乘层，需要额外再获取一下Advice，如果这时候得到的是<code>OPEN</code>，就需要开门。</p><p>新增一个<code>AWAY</code>的<code>Advice</code>，如果这时有电梯在换乘层且挡道了就让其避开。最后，如果一个双轿厢电梯在得到结束的<code>Advice</code>时，如果还停在换乘层，同样让其<code>AWAY</code>以避免出现因电梯A停止运行而B电梯无法让A再避开的情况。</p><p><code>ADVICE</code>的优先级问题：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Strategy</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token class-name">Advice</span> <span class="token function">getAdvice</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>reqTable<span class="token punctuation">.</span><span class="token function">getNormalResetRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token class-name">Advice</span><span class="token punctuation">.</span><span class="token constant">RESET</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>reqTable<span class="token punctuation">.</span><span class="token function">getDcResetReq</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token class-name">Advice</span><span class="token punctuation">.</span><span class="token constant">DCRESET</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">openToOut</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">openToIn</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token class-name">OpenToTransfer</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token class-name">Advice</span><span class="token punctuation">.</span><span class="token constant">OPEN</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>curFloor <span class="token operator">==</span> transFloor <span class="token operator">&amp;&amp;</span> reqTable<span class="token punctuation">.</span><span class="token function">isNeedAway</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token class-name">Advice</span><span class="token punctuation">.</span><span class="token constant">AWAY</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>curNum <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token comment">//look算法...</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这一部分电梯的运行以及<code>Advice</code>的获取有很多细节要注意，一旦出现一些小问题就很容易出现电梯遁地，升天等停不下来的情况，不过相比死锁和轮询还是友好的。</p><p>至于互斥的实现，一开始的时候我使用了一种类似于下述代码的方法，先检查是否有占用标记，若没被占用留下标志。后来看到osppt明确说明了这样实现的问题，即：<code>Occupied</code>的读和写会出现一个空档，无法真正实现互斥。当时已经是周五晚，于是也直接通过<code>sleep</code>解决。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token class-name">Occupied</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token class-name">Occupied</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token comment">//访问Floor</span><span class="token class-name">Occupied</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="双轿厢电梯乘客换乘"><a href="#双轿厢电梯乘客换乘" class="headerlink" title="双轿厢电梯乘客换乘"></a>双轿厢电梯乘客换乘</h5><p>由于双轿厢电梯的出现，有些乘客一次分配是无法被送达目的地的。这时我会把人扔回总表。这时总表结束条件判断还需要新增一个条件，那就是所有需要换乘的乘客请求都完成。为此为<code>Person</code>新建<code>needTransfer</code>属性。在调度器中引入记录需要换乘的乘客数量<code>transferNum</code>。每当把一个<code>personRequest</code>分配给双轿电梯时，就需要判断一下这个A/B电梯是否能一趟把乘客送达。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">int</span> <span class="token function">getEleId</span><span class="token punctuation">(</span><span class="token class-name">Person</span> person<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> id <span class="token operator">=</span> random<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>requestMap<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//分配给单轿厢</span>            <span class="token comment">//... return id</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">//双轿电梯</span>            <span class="token keyword">int</span> tmp<span class="token punctuation">;</span><span class="token comment">//用于决定给A/B梯</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isChange</span><span class="token punctuation">(</span>from<span class="token punctuation">,</span> <span class="token keyword">to</span><span class="token punctuation">,</span> transFloor<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//不需要换乘</span>                <span class="token comment">//...确定tmp</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                transferNum<span class="token operator">++</span><span class="token punctuation">;</span>                person<span class="token punctuation">.</span><span class="token function">setNeedTransfer</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//该人分配给了双轿电梯，且需要换乘</span>                <span class="token comment">//...确定tmp</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> tmp <span class="token operator">*</span> <span class="token number">6</span> <span class="token operator">+</span> id<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在<code>Elevator</code>开关门的时候也需要更改：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token class-name">OpenAndClose</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//...</span>    <span class="token function">getOut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> curFloor <span class="token operator">==</span> transferFloor<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">transfer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token class-name">Advice</span> adv <span class="token operator">=</span> strategy<span class="token punctuation">.</span><span class="token function">getAdvice</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>adv <span class="token operator">==</span> <span class="token class-name">Advice</span><span class="token punctuation">.</span><span class="token constant">REVERSE</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token function">getIn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//...</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//将电梯里所有需要换乘的人放出去, 扔回总表</span>        <span class="token comment">//...遍历电梯内剩下的乘客</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>per<span class="token punctuation">.</span><span class="token function">isNeedTransfer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">//开门放人...</span>            per<span class="token punctuation">.</span><span class="token function">setFromFloor</span><span class="token punctuation">(</span>transferFloor<span class="token punctuation">)</span><span class="token punctuation">;</span>            per<span class="token punctuation">.</span><span class="token function">setNeedTransfer</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">Manager</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getAllRequestTable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addPerson</span><span class="token punctuation">(</span>per<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">Manager</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">decTransferNum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            listIter<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//把这个人删去</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>换乘函数<code>transfer</code>负责将电梯里所有需要换乘的人放出去, 扔回总表。这时，在我的实现下，最好先执行完<code>getOut()</code>，将所有本来就在该换乘层到达目的地的乘客送出去。这时双轿电梯剩下的乘客应该只剩下因被迫换乘而下电梯的乘客。依然要注意<code>Map</code>在对应键为空的时候要维护，将整个键也删除。</p><p>于是我在结束条件判断的时候，总共需要判断：①总表输入结束且总表为空 ②普通电梯不能在执行任意一种reset，且所有分请求表为空 ③需要换乘的乘客都送完了，<code>transferNum != 0</code>。这样结束条件的问题也解决了。</p><h4 id="Bug分析-2"><a href="#Bug分析-2" class="headerlink" title="Bug分析"></a>Bug分析</h4><p>本次作业强测和互测都没有出现bug。一些细节是：<br>我在对<code>RequestTable</code>的属性<code>(NormalResetReq，dcResetRequest，needAway)</code>进行<code>set</code>的时候都进行了<code>notifyAll</code>。对于第二次作业会被hack的数据，我继续采用sleep，也就是如果随机到的电梯刚好在reset就睡，然后获取新的随机id，随到一个能用的电梯为止。这样既保证了很难被hack，又保证了这样一个最基本的策略分数注定很低。</p><h4 id="UML类图-amp-时序图-2"><a href="#UML类图-amp-时序图-2" class="headerlink" title="UML类图&amp;时序图"></a>UML类图&amp;时序图</h4><img src="https://s21.ax1x.com/2024/04/15/pFvhq1J.png"><img src="https://s21.ax1x.com/2024/04/19/pkSkc8K.png" style="zoom:50%;"><h3 id="变和不变"><a href="#变和不变" class="headerlink" title="变和不变"></a>变和不变</h3><p>我在三次迭代中总体架构没有太大的变化，基本是直接在原先的架构上增加新的功能。首先<code>Input，Manager，Elevator</code>三个线程类的共嫩没有改变，<code>RequestTable</code>作为共享资源的性质及其传递信息的功能也没有改变。同样我的调度策略<del>由于没有</del>也没有变化。</p><p>为了实现新增的两种类型<code>RESET</code>，我在<code>Manager</code>中分别新增了相关的同步方法，通过请求表共享信息。另外电梯的策略以及<code>run</code>方法也要做相关调整。对于双轿厢电梯的重置还为<code>Person</code>类新增了属性以辨别乘客换乘请求是否结束。</p><h3 id="总结与心得"><a href="#总结与心得" class="headerlink" title="总结与心得"></a>总结与心得</h3><img src="https://s21.ax1x.com/2024/04/17/pFxI5aq.png" alt="final"><p>本单元让我对多线程有了深刻的体会，同时我也加强了合理进行规划设计，降低耦合，让线程间各司其职的意识，加深了我对面向对象思想的理解。我也又一次意识到保持代码的简洁和结构的清晰是多么重要。</p><p>传说中的电梯单元总算是快结束了，总体来看我三次作业的完成和debug过程果然是困难重重。之前我习惯性打断点调试的方法不再适用，我非常清晰地记得第三次迭代的周四周五的两点钟依然在宿舍debug，<del>看到错误的输出仿佛能听到我电梯相撞的声音。。</del>虽然最后没有出现很大的问题，但不足之处也很明显，就是为了保证最基本的正确性可以说是一点优化也没做了，几乎全是睡过去的。希望以后能在优化方面做得更好吧orz</p><p>最后，<strong>感谢X267三位神仙的巨大帮助orzzzzzzzz/(ㄒoㄒ)/~~</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> OO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OS_lab1</title>
      <link href="/2024/03/14/lab1-shi-yan-bao-gao/"/>
      <url>/2024/03/14/lab1-shi-yan-bao-gao/</url>
      
        <content type="html"><![CDATA[<h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><h5 id="Thinking-1-1"><a href="#Thinking-1-1" class="headerlink" title="Thinking 1.1"></a>Thinking 1.1</h5><p><strong>Q:</strong> 请阅读 附录中的编译链接详解，尝试分别使用实验环境中的原生x86工具链（gcc、ld、readelf、objdump 等）和 MIPS 交叉编译工具链（带有 mips-linux-gnu-前缀），重复其中的编译和解析过程，观察相应的结果，并解释其中向 objdump 传入的参数的含义。</p><p><strong>A:</strong> 执行<code>gcc -E hello.c</code>只进行预处理不编译：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">//...extern int printf (const char *__restrict __format, ...);//...# 3 "hello.c"int main() {    printf("Hello World!\n");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行<code>gcc -c hello.c</code>只编译不链接，对生成hello.o执行反汇编：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">objdump <span class="token parameter variable">-DS</span> hello.o<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>部分输出：</p><pre class="line-numbers language-none"><code class="language-none">git@22373537:~ $ objdump -DS hello.ohello.o：     文件格式 elf64-x86-64Disassembly of section .text:0000000000000000 &lt;main&gt;:   0:   f3 0f 1e fa             endbr64    4:   55                      push   %rbp   5:   48 89 e5                mov    %rsp,%rbp   8:   48 8d 05 00 00 00 00    lea    0x0(%rip),%rax        # f &lt;main+0xf&gt;   f:   48 89 c7                mov    %rax,%rdi  12:   e8 00 00 00 00          call   17 &lt;main+0x17&gt;  17:   b8 00 00 00 00          mov    $0x0,%eax  1c:   5d                      pop    %rbp  1d:   c3                      ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对正常编译（加上链接）生产的可执行文件进行反汇编，部分输出如下：</p><pre class="line-numbers language-none"><code class="language-none">git@22373537:~ $ objdump -DS hellohello：     文件格式 elf64-x86-64Disassembly of section .interp:.....0000000000001149 &lt;main&gt;:    1149:       f3 0f 1e fa             endbr64     114d:       55                      push   %rbp    114e:       48 89 e5                mov    %rsp,%rbp    1151:       48 8d 05 ac 0e 00 00    lea    0xeac(%rip),%rax        # 2004 &lt;_IO_stdin_used+0x4&gt;    1158:       48 89 c7                mov    %rax,%rdi    115b:       e8 f0 fe ff ff          call   1050 &lt;puts@plt&gt;    1160:       b8 00 00 00 00          mov    $0x0,%eax    1165:       5d                      pop    %rbp    1166:       c3                      ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果直接用MIPS交叉编译工具链编译<code>hello.c</code>，其生成的可执行文件的目标架构应该是 MIPS，需使用适用于 MIPS 架构的 objdump 版本。</p><pre class="line-numbers language-none"><code class="language-none">git@22373537:~ $ mips-linux-gnu-gcc hello.c -o hellogit@22373537:~ $ objdump -DShello：     文件格式 elf32-bigobjdump: can't disassemble for architecture UNKNOWN!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">git@22373537:~ $ mips-linux-gnu-objdump -DS hellohello：     文件格式 elf32-tradbigmipsDisassembly of section .interp:......004006e0 &lt;main&gt;:  4006e0:       27bdffe0        addiu   sp,sp,-32  4006e4:       afbf001c        sw      ra,28(sp)  4006e8:       afbe0018        sw      s8,24(sp)  4006ec:       03a0f025        move    s8,sp  4006f0:       3c1c0042        lui     gp,0x42  4006f4:       279c9010        addiu   gp,gp,-28656  4006f8:       afbc0010        sw      gp,16(sp)  4006fc:       3c020040        lui     v0,0x40  400700:       24440830        addiu   a0,v0,2096  400704:       8f828030        lw      v0,-32720(gp)  400708:       0040c825        move    t9,v0  40070c:       0320f809        jalr    t9  400710:       00000000        nop  400714:       8fdc0010        lw      gp,16(s8)  400718:       00001025        move    v0,zero  40071c:       03c0e825        move    sp,s8  400720:       8fbf001c        lw      ra,28(sp)  400724:       8fbe0018        lw      s8,24(sp)  400728:       27bd0020        addiu   sp,sp,32  40072c:       03e00008        jr      ra  400730:       00000000        nop  ......<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>objdump</code>参数的意义：</p><ul><li><code>-D</code> 选项表示进行反汇编。它告诉 <code>objdump</code> 将目标文件的机器代码转换为汇编代码。</li><li><code>-S</code> 选项表示 <code>objdump</code> 会在反汇编的过程中，将机器代码与源代码进行关联，并将C语言源代码行显示在反汇编结果中。</li></ul><h5 id="Thinking-1-2"><a href="#Thinking-1-2" class="headerlink" title="Thinking 1.2"></a>Thinking 1.2</h5><p><strong>Q:</strong> </p><p>• 尝试使用我们编写的 <code>readelf</code>程序，解析之前在<code> target</code>目录下生成的内核 ELF 文件。 </p><p>• 也许你会发现我们编写的<code>readelf </code>程序是不能解析<code>readelf</code>文件本身的，而我们刚才介绍的系统工具 <code>readelf</code> 则可以解析，这是为什么呢？（提示：尝试使用<code>readelf -h</code>，并阅读 <code>tools/readelf </code>目录下的 <code>Makefile</code>，观察 <code>readelf </code>与<code>hello</code>的不同）</p><p><strong>A:</strong></p><p>使用我们自己编写的<code>readelf</code>解析内核ELF文件的结果：</p><pre class="line-numbers language-none"><code class="language-none">git@22373537:~/22373537/tools/readelf (lab1)$ ./readelf ~/22373537/target/mos 0:0x01:0x804000002:0x804016f03:0x804017084:0x804017205:0x06:0x07:0x08:0x09:0x010:0x011:0x012:0x013:0x014:0x015:0x016:0x0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>-h表示显示 ELF 文件的文件头信息（header）</p><pre class="line-numbers language-none"><code class="language-none">-h --file-header       Display the ELF file header<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>readelf</code>可执行文件是64位格式的，而<code>hello</code>是32位的</p><img src="https://s21.ax1x.com/2024/03/15/pFgLs2Q.png" width="75%"><img src="https://s21.ax1x.com/2024/03/15/pFgLr8g.png" width="75%"><p><code>tools/readelf</code>目录下的Makefile文件：</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">readelf</span><span class="token punctuation">:</span> main.o readelf.o        <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$^</span> -o <span class="token variable">$@</span><span class="token target symbol">hello</span><span class="token punctuation">:</span> hello.c        <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$^</span> -o <span class="token variable">$@</span> -m32 -static -g <span class="token comment"># m32选项生成32位可执行文件</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们自己编写的<code>readelf.c</code>文件内数据类型前缀均为<code>ELF32</code>，因此可以解析的是32位的hello，却不能解析作为64位elf的自己。</p><h5 id="Thinking-1-3"><a href="#Thinking-1-3" class="headerlink" title="Thinking 1.3"></a>Thinking 1.3</h5><p><strong>Q:</strong> 在理论课上我们了解到，MIPS 体系结构上电时，启动入口地址为 <code>0xBFC00000</code>（其实启动入口地址是根据具体型号而定的，由硬件逻辑确定，也有可能不是这个地址，但 一定是一个确定的地址），但实验操作系统的内核入口并没有放在上电启动地址，而是按照内存布局图放置。思考为什么这样放置内核还能保证内核入口被正确跳转到？（提示：思考实验中启动过程的两阶段分别由谁执行。）</p><p><strong>A:</strong> 启动的第一阶段是硬件初始化，从ROM或FLASH加载bootloader，初始化硬件，然后为软件启动做准备，做一些载入内核等工作，完成后跳转到内核入口地址，即可将CPU控制权交给内核，进入第二阶段（内核启动）。</p><p>GEMU仿真器支持直接加载ELF文件内核，所以我们要做的启动流程简化为加载内核到内存，再跳转到内核入口即可。</p><p>在实验中我们用<code>kernel.lds</code>将内核加载到正确位置，通过<code>ENTRY(_start)</code>设置设置程序入口为 _start，保证正确地跳转到内核入口。</p><h3 id="难点分析"><a href="#难点分析" class="headerlink" title="难点分析"></a>难点分析</h3><p>我认为本次实验较难的部分主要是ELF文件的解析，还有就是补全<code>prinfk</code>要看懂每一部分在做什么，此外每个目录下的<code>Makefile</code>文件也值得认真琢磨。</p><p>本次lab1课下实验首先介绍了ELF文件的结构，包括：</p><p>1.<strong>ELF头（ELF Header）</strong>，即结构体<code>Elf32_Ehdr</code>，存放ELF文件信息</p><p>2.<strong>程序头表（Program Header Table）</strong>，含有段头表项（Segment Header），即结构体<code>Elf32_Phdr</code>作为段头表中的每个条目来存储</p><p>3.<strong>节头表（Section Header Table）</strong>，含有节头表项（Section Header），即结构体<code>Elf32_Shdr</code>作为节头表中的每个条目来存储</p><p>3.<strong>段（Segment）：</strong>包含多个节</p><p>4.<strong>节（Section）：</strong> 常见的节： <code>.text</code>（代码段）、<code>.data</code>（数据段）、<code>.bss</code>（未初始化的数据段）</p><p>通过编译链接我们用C语言写的readelf.c生成readelf这个可执行文件，后者可以对32位ELF格式的文件进行简单的解析。</p><p>介绍了MIPS虚拟内存布局以及内核所处的位置；介绍了<code>kernel.lds</code> 文件（链接脚本Linker Script），用于定义目标文件在内存中的布局和排列方式（如各个节的位置）及程序入口。</p><h3 id="实验体会"><a href="#实验体会" class="headerlink" title="实验体会"></a>实验体会</h3><p>本次实验我在理解指导书内容以及实验代码上花费了大量时间，需要在众多目录和文件中找到并理解彼此的关系。首先，自己对Makefile的变量定义等不够熟悉，需要明确的是Makefile用来组织实验编写的操作系统代码；我逐渐了解到我们所编写的操作系统内核实际上是在为程序的运行提供一个基础设施/平台，我们之前编写程序，下层有操作系统；当我们在构建操作系统时下层就直接是硬件了，QEMU则负责了模拟CPU和计算机硬件。</p>]]></content>
      
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OS_lab0</title>
      <link href="/2024/03/13/lab0-shi-yan-bao-gao/"/>
      <url>/2024/03/13/lab0-shi-yan-bao-gao/</url>
      
        <content type="html"><![CDATA[<h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><h5 id="Thinking-0-1"><a href="#Thinking-0-1" class="headerlink" title="Thinking 0.1"></a>Thinking 0.1</h5><p>不一样。</p><p>创建README.txt文件后（第一次执行add之前）状态为未跟踪（Untracked）。</p><p>add+commit之后修改README.txt内容，状态为修改状态，存在未暂存的变更（Modified）。</p><h5 id="Thinking-0-2"><a href="#Thinking-0-2" class="headerlink" title="Thinking 0.2"></a>Thinking 0.2</h5><p>思考一下箭头中的 add the file 、stage the file 和 commit 分别对应的是 Git 里的哪些命令呢？</p><p>add the file: <code>git add</code></p><p>stage the file: <code>git add</code></p><p>commit the file:  <code>git commit</code></p><h5 id="Thinking-0-3"><a href="#Thinking-0-3" class="headerlink" title="Thinking 0.3"></a>Thinking 0.3</h5><p>1.代码文件 print.c 被错误删除时，应当使用什么命令将其恢复？</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> checkout print.c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2.代码文件 print.c 被错误删除后，执行了 <code>git rm print.c </code>命令，此时应当 使用什么命令将其恢复？ </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> restore <span class="token parameter variable">--staged</span> print.c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3.无关文件 hello.txt 已经被添加到暂存区时，如何在不删除此文件的前提下将其移出暂存区？</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> <span class="token function">rm</span> <span class="token parameter variable">--cached</span> hello.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="Thinking-0-4"><a href="#Thinking-0-4" class="headerlink" title="Thinking 0.4"></a>Thinking 0.4</h5><p>提交日志</p><img src="https://s21.ax1x.com/2024/03/13/pFc1UQe.png" alt="git log" width="60%"><p>进行版本回退。执行命令 <code>git reset --hard HEAD^</code> 后</p><pre class="line-numbers language-none"><code class="language-none">git@22373537:~/learnGit(master)$ git reset --hard HEAD^HEAD 现在位于 21b5f83 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>再执行<code>git log</code>，发现只剩下message为1和2的提交</p><p>找到提交说明为 1 的哈希值，执行命令 <code>git reset --hard &lt;hash&gt;</code></p><pre class="line-numbers language-none"><code class="language-none">git@22373537:~/learnGit(master)$ git reset --hard ba88651a99d7bg1088240897+6f66796561430HEAD 现在位于 ba88651 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>现在已经回到了旧版本，为了再次回到新版本，执行 <code>git reset --hard &lt;hash&gt; </code> ，再执行 git log，发现与上面的提交日志相同</p><h5 id="Thinking-0-5"><a href="#Thinking-0-5" class="headerlink" title="Thinking 0.5"></a>Thinking 0.5</h5><p>注意：&gt;&gt;是追加，&gt;是覆盖</p><p><img src="C:\Users\86182\AppData\Roaming\Typora\typora-user-images\image-20240308173453711.png" alt=">和>>"></p><h5 id="Thinking-0-6"><a href="#Thinking-0-6" class="headerlink" title="Thinking 0.6"></a>Thinking 0.6</h5><p>command（创建该test文件的命令序列）</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">touch</span> <span class="token builtin class-name">test</span><span class="token function">chmod</span> +x <span class="token builtin class-name">test</span><span class="token builtin class-name">echo</span> <span class="token builtin class-name">echo</span> Shell Start<span class="token punctuation">..</span>. <span class="token operator">&gt;</span> <span class="token builtin class-name">test</span><span class="token builtin class-name">echo</span> <span class="token builtin class-name">echo</span> <span class="token builtin class-name">set</span> a <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&gt;&gt;</span> <span class="token builtin class-name">test</span><span class="token builtin class-name">echo</span> <span class="token assign-left variable">a</span><span class="token operator">=</span><span class="token number">1</span> <span class="token operator">&gt;&gt;</span> <span class="token builtin class-name">test</span><span class="token builtin class-name">echo</span> <span class="token builtin class-name">echo</span> <span class="token builtin class-name">set</span> b <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">&gt;&gt;</span> <span class="token builtin class-name">test</span><span class="token builtin class-name">echo</span> <span class="token assign-left variable">b</span><span class="token operator">=</span><span class="token number">2</span> <span class="token operator">&gt;&gt;</span> <span class="token builtin class-name">test</span><span class="token builtin class-name">echo</span> <span class="token builtin class-name">echo</span> <span class="token builtin class-name">set</span> c <span class="token operator">=</span> a+b <span class="token operator">&gt;&gt;</span> <span class="token builtin class-name">test</span><span class="token builtin class-name">echo</span> <span class="token string">'c=$[$a+$b]'</span> <span class="token operator">&gt;&gt;</span> <span class="token builtin class-name">test</span><span class="token builtin class-name">echo</span> <span class="token string">'echo c = $c'</span> <span class="token operator">&gt;&gt;</span> <span class="token builtin class-name">test</span><span class="token builtin class-name">echo</span> <span class="token builtin class-name">echo</span> save c to ./file1 <span class="token operator">&gt;&gt;</span> <span class="token builtin class-name">test</span><span class="token builtin class-name">echo</span> <span class="token string">'echo $c&gt;file1'</span> <span class="token operator">&gt;&gt;</span> <span class="token builtin class-name">test</span><span class="token builtin class-name">echo</span> <span class="token builtin class-name">echo</span> save b to ./file2 <span class="token operator">&gt;&gt;</span> <span class="token builtin class-name">test</span><span class="token builtin class-name">echo</span> <span class="token string">'echo $b&gt;file2'</span> <span class="token operator">&gt;&gt;</span> <span class="token builtin class-name">test</span><span class="token builtin class-name">echo</span> <span class="token builtin class-name">echo</span> save a to ./file3 <span class="token operator">&gt;&gt;</span> <span class="token builtin class-name">test</span><span class="token builtin class-name">echo</span> <span class="token string">'echo $a&gt;file3'</span> <span class="token operator">&gt;&gt;</span> <span class="token builtin class-name">test</span><span class="token builtin class-name">echo</span> <span class="token builtin class-name">echo</span> save file1 file2 file3 to file4 <span class="token operator">&gt;&gt;</span> <span class="token builtin class-name">test</span><span class="token builtin class-name">echo</span> <span class="token string">'cat file1&gt;file4'</span> <span class="token operator">&gt;&gt;</span> <span class="token builtin class-name">test</span><span class="token builtin class-name">echo</span> <span class="token string">'cat file2&gt;&gt;file4'</span> <span class="token operator">&gt;&gt;</span> <span class="token builtin class-name">test</span><span class="token builtin class-name">echo</span> <span class="token string">'cat file3&gt;&gt;file4'</span> <span class="token operator">&gt;&gt;</span> <span class="token builtin class-name">test</span><span class="token builtin class-name">echo</span> <span class="token builtin class-name">echo</span> save file4 to ./result <span class="token operator">&gt;&gt;</span> <span class="token builtin class-name">test</span><span class="token builtin class-name">echo</span> <span class="token string">'cat file4&gt;&gt;result'</span> <span class="token operator">&gt;&gt;</span> <span class="token builtin class-name">test</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>test</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> Shell Start<span class="token punctuation">..</span>.<span class="token builtin class-name">echo</span> <span class="token builtin class-name">set</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token assign-left variable">a</span><span class="token operator">=</span><span class="token number">1</span><span class="token builtin class-name">echo</span> <span class="token builtin class-name">set</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token assign-left variable">b</span><span class="token operator">=</span><span class="token number">2</span><span class="token builtin class-name">echo</span> <span class="token builtin class-name">set</span> c <span class="token operator">=</span> a+b<span class="token assign-left variable">c</span><span class="token operator">=</span>$<span class="token punctuation">[</span><span class="token variable">$a</span>+<span class="token variable">$b</span><span class="token punctuation">]</span><span class="token builtin class-name">echo</span> c <span class="token operator">=</span> <span class="token variable">$c</span><span class="token builtin class-name">echo</span> save c to ./file1<span class="token builtin class-name">echo</span> <span class="token variable">$c</span><span class="token operator">&gt;</span>file1<span class="token builtin class-name">echo</span> save b to ./file2<span class="token builtin class-name">echo</span> <span class="token variable">$b</span><span class="token operator">&gt;</span>file2<span class="token builtin class-name">echo</span> save a to ./file3<span class="token builtin class-name">echo</span> <span class="token variable">$a</span><span class="token operator">&gt;</span>file1<span class="token builtin class-name">echo</span> save file1 file2 file3 to file4<span class="token function">cat</span> file<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span>file4<span class="token function">cat</span> file<span class="token operator"><span class="token file-descriptor important">2</span>&gt;&gt;</span>file4<span class="token function">cat</span> file<span class="token operator"><span class="token file-descriptor important">3</span>&gt;&gt;</span>file4<span class="token builtin class-name">echo</span> save file4 to ./result<span class="token function">cat</span> file<span class="token operator"><span class="token file-descriptor important">4</span>&gt;&gt;</span>result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 控制台输出</p><pre class="line-numbers language-none"><code class="language-none">git@22373537:~/learnGit(master)$ ./testShell Start.set a=1set b=2set c= a+bc=3save c to ./file1save b to ./file2save a to ./file3save filel file2 file3 to file4save file4 to ./result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>result 内容</p><pre class="line-numbers language-none"><code class="language-none">321<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><img src="C:\Users\86182\AppData\Roaming\Typora\typora-user-images\image-20240310233959207.png" alt="image-20240310233959207" style="float : left;zoom:47%;"><p><code>echo 'c=$[$a+$b]'</code>  用单引号防止Shell解释变量。或用<code>\</code>转义：<code>echo "c=\$[\$a+\$b]"</code>，反正双引号不行。<code>echo 'echo c = $c' </code>同理。</p><p>命令<code>echo echo $c &gt; file1</code>将字符串”echo $c”写入file1文件。</p><p>命令<code>echo `echo $c&gt; file1` </code> 反引号进行命令替换，被替换后本身不输出内容，故输出echo自带的换行。</p><h5 id="Exercise-0-3"><a href="#Exercise-0-3" class="headerlink" title="Exercise 0.3"></a>Exercise 0.3</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">grep</span> <span class="token parameter variable">-n</span> <span class="token string">"<span class="token variable">$2</span>"</span> <span class="token variable">$1</span> <span class="token operator">|</span> <span class="token function">cut</span> -d: <span class="token parameter variable">-f1</span> <span class="token operator">&gt;</span> <span class="token variable">$3</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>-f1</code> 表示提取每行的第1个字段</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">grep</span> <span class="token parameter variable">-n</span> <span class="token string">"<span class="token variable">$2</span>"</span> <span class="token variable">$1</span> <span class="token operator">|</span> <span class="token function">awk</span> -F: <span class="token string">'{print $1}'</span> <span class="token operator">&gt;</span> <span class="token variable">$3</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>-F </code>选项用来指定用于分隔的字符，默认是空格。所以该命令的 $1 就是用“:”分隔 的第1项了。</p><h5 id="Exercise-0-4"><a href="#Exercise-0-4" class="headerlink" title="Exercise 0.4"></a>Exercise 0.4</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">from</span><span class="token operator">=</span><span class="token variable">$2</span><span class="token assign-left variable">to</span><span class="token operator">=</span><span class="token variable">$3</span><span class="token function">sed</span> <span class="token parameter variable">-i</span> <span class="token string">"s/<span class="token variable">${from}</span>/<span class="token variable">${to}</span>/g"</span> <span class="token variable">$1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里必须是双引号，因为要解析里面的变量（变量在单引号中不会被展开）。</p><h3 id="难点分析"><a href="#难点分析" class="headerlink" title="难点分析"></a>难点分析</h3><ul><li><p>最初我对grep，sed，awk各自的功能不够了解导致不知道该使用哪种指令来处理文本。grep搜索匹配某个模式的行，sed对文本进行各种编辑操作，awk可以分割字段处理且可以执行更为复杂的操作。</p></li><li><p>单双引号和反引号的使用：</p><p>单引号内所有字符都被当作普通字符对待，而双引号会解析变量和特殊字符（如<code>$</code>,<code>\</code>）</p><p>反引号或 <code>$()</code> 进行命令替换。执行命令，并将命令的输出插入到命令行中。</p></li><li><p>对git理解不够深入，还需要勤加练习。shell语言中的各种括号语法也需要注意，感觉有很多细节还是与平时使用的高级语言有不小的差异。</p></li></ul><h3 id="实验体会"><a href="#实验体会" class="headerlink" title="实验体会"></a>实验体会</h3><p>学习了一些基本的bash指令，vim编辑器的使用，Makefile的编写，git的基本操作等等，补充了一些编译链接和MIPS的相关知识。</p><p>本次实验学习了很多工具的使用，东西比较杂，可以说是为以后的lab打好基础。然而我感觉自己很多操作依然不够熟练，此后还是要争取花更多时间学习os（悲</p><h3 id="Lab0上机"><a href="#Lab0上机" class="headerlink" title="Lab0上机"></a>Lab0上机</h3><h4 id="exam"><a href="#exam" class="headerlink" title="exam"></a>exam</h4><p> <code>gcc -c</code> (只编译不链接，生成目标文件）默认情况下，目标文件命名为源文件的名称的扩展名（例如<code>.c</code>）替换为<code>.o</code>。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gcc <span class="token parameter variable">-c</span> *.c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="extra"><a href="#extra" class="headerlink" title="extra"></a>extra</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># Your code here. (3/3)</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">0</span><span class="token keyword">while</span> <span class="token variable"><span class="token punctuation">((</span>$PID <span class="token operator">&gt;</span> $i<span class="token punctuation">))</span></span><span class="token keyword">do</span><span class="token function">awk</span> <span class="token parameter variable">-v</span> <span class="token assign-left variable">input</span><span class="token operator">=</span><span class="token variable">$PID</span>  <span class="token string">'input==$2 {print $3}'</span> <span class="token string">"<span class="token variable">$FILE</span>"</span><span class="token assign-left variable">PID</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">awk</span> <span class="token parameter variable">-v</span> <span class="token assign-left variable">input</span><span class="token operator">=</span>$PID  <span class="token string">'input==$2 {print $3}'</span> <span class="token string">"<span class="token variable">$FILE</span>"</span><span class="token variable">`</span></span><span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我一开始的时候写错了input==$2写错了</p>]]></content>
      
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HelloBlog</title>
      <link href="/2023/02/04/helloblog/"/>
      <url>/2023/02/04/helloblog/</url>
      
        <content type="html"><![CDATA[<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h2 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h2><p>whale梦拓是个好梦拓。</p>]]></content>
      
      
      
        <tags>
            
            <tag> try </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
