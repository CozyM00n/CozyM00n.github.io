<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>阳阳中考加油</title>
      <link href="/2024/06/09/yang-yang-zhong-kao-jia-you/"/>
      <url>/2024/06/09/yang-yang-zhong-kao-jia-you/</url>
      
        <content type="html"><![CDATA[<blockquote><h4 id="“请相信自己，你拥有足够的实力去迎接这一挑战。“"><a href="#“请相信自己，你拥有足够的实力去迎接这一挑战。“" class="headerlink" title="“请相信自己，你拥有足够的实力去迎接这一挑战。“"></a>“请相信自己，你拥有足够的实力去迎接这一挑战。“</h4></blockquote><p>人生用来体验，而非用来演绎完美。</p><p>一生一次的中考不是用来紧张焦虑的，请尽管放下<strong>所有的顾虑和无论任何人给予的压力</strong>，享受过程~</p><p>请放平心态，做到全力以赴，剩下交给命运和时间。这样，当你回头再看这段时光，无论结果如何，也能自豪地说出”尽力了，不遗憾“——这便是我认为最好的状态了。</p><p>一切都会是最好的安排。请务必<strong>相信自己</strong>，走过的每一步走算数！</p><p>祝旗开得胜，中考加油！！！</p><img src="https://s21.ax1x.com/2024/06/09/pkNEP7d.jpg" style="zoom:30%;">]]></content>
      
      
      
        <tags>
            
            <tag> 中考加油 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OO_Unit3</title>
      <link href="/2024/05/16/oo-unit3/"/>
      <url>/2024/05/16/oo-unit3/</url>
      
        <content type="html"><![CDATA[<h1 id="OO-Unit3-规格化设计"><a href="#OO-Unit3-规格化设计" class="headerlink" title="OO_Unit3: 规格化设计"></a>OO_Unit3: 规格化设计</h1><h3 id="测试分析"><a href="#测试分析" class="headerlink" title="测试分析"></a>测试分析</h3><h4 id="黑箱测试"><a href="#黑箱测试" class="headerlink" title="黑箱测试"></a>黑箱测试</h4><p>黑箱测试只根据软件的功能需求和规格说明来设计测试用例，测试人员不需要了解程序的内部结构或实现细节。测试的目的是验证软件的功能是否符合预期。由于只需要了解需求和规格说明，并基于此编写测试用例即可。</p><p>此测试方法更接近用户的视角，能发现功能性缺陷，类似于oo中强测；然而可能无法覆盖所有代码路径，导致一些内部缺陷未被发现，且测试数据依赖需求文档和规格说明的准确性和完整性。</p><h4 id="白箱测试"><a href="#白箱测试" class="headerlink" title="白箱测试"></a>白箱测试</h4><p>白箱测试通过检查代码、控制流和数据流来设计测试用例。测试的目的是验证代码的正确性和逻辑。测试人员必须熟悉程序的代码和内部结构，测试用例也是根据代码结构、逻辑路径、条件和分支等编写的；主要测试内部逻辑：验证代码实现是否正确，包括逻辑错误、路径覆盖、循环、条件判断等。可以通过静态分析工具或覆盖率分析工具确保所有代码路径都经过测试。</p><p>此方法可以发现隐藏在代码中的逻辑错误和缺陷，提供详细的代码覆盖信息，帮助提高代码质量，有助于优化代码，提升性能；但需要测试人员具备编程和代码分析能力，测试用例编写相对复杂且耗时，且难以模拟用户的实际使用场景。</p><p>在实际的软件测试中，黑箱测试和白箱测试通常结合使用，互为补充。黑箱测试从功能和需求的角度出发，确保软件功能正确；白箱测试从代码实现的角度出发，确保代码质量和逻辑正确。通过综合使用两种测试方法，可以更全面地发现软件中的缺陷，提高软件的可靠性和稳定性。</p><h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><p>对软件中的最小可测试部分（比如一个函数或方法）进行测试，以确保其功能正确。</p><ul><li><strong>粒度最小</strong>：测试的对象是代码的最小单元，可以快速得到反馈。</li><li><strong>白箱测试</strong>：通常由开发人员编写，自动化测试代码的内部逻辑，比如我们作业的Junit。</li></ul><h4 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h4><p>通过测试软件的功能和行为，验证其是否满足需求和规格说明；目的是确保软件功能按预期工作，验证功能需求和业务规则的实现。</p><ul><li><p><strong>黑箱测试</strong>：不关注内部实现，只关注输入输出和功能表现。</p></li><li><p><strong>基于需求</strong>：测试用例根据需求文档和规格说明编写。</p></li><li><p><strong>用户视角</strong>：模拟用户操作，验证软件的功能。</p></li></ul><h4 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h4><p>在单元测试的基础上，将多个单元模块集成在一起进行测试，验证模块组合后的功能和性能，以确保它们之间的<strong>接口和交互</strong>正确。用于测试模块之间的交互和接口，可以包含黑箱和白箱测试的元素。</p><h4 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h4><p>通过施加超出正常工作负荷的压力，测试系统在极端条件下的表现和稳定性。通常是施加高负载、高并发等极端条件，关注系统的响应时间、吞吐量、稳定性等性能指标。类似于我们平时强测和互测中构造出一些极端的数据刀人或者测试自己程序的性能。</p><h4 id="回归测试"><a href="#回归测试" class="headerlink" title="回归测试"></a>回归测试</h4><p>指在软件发生变更后（如修复缺陷、添加新功能、优化代码），重新测试系统，以确保变更没有引入新的缺陷。对已有功能的再测试，涵盖受变更影响的所有功能模块。目的是确保新代码的变更没有破坏已有功能，验证缺陷修复和新功能实现的正确性。</p><p>每种测试类型在软件开发和测试过程中都有其特定的作用和目标，结合使用这些测试方法，可以全面保障软件的质量和可靠性。</p><h4 id="数据构造策略"><a href="#数据构造策略" class="headerlink" title="数据构造策略"></a>数据构造策略</h4><p><strong>手捏数据：</strong>实际上有很多bug是一些很简单的数据就可以测试出来的，并不需要很复杂的数据。就算是用数据生成器得到的几千行输入，我们也希望能将其简化以减轻debug盯着屏幕的痛苦。比如在hw9的<code>qbs</code>指令，我们就可以通过先简单地构造出少量块分离和合并的基础数据，从而明确自己的程序是在何种情况下会发生问题，而没有必要对着几千行的数据发愁。</p><p>对于一些函数如果有tle的忧虑可以尽量优化算法，但鉴于与本单元主题关系不大，好像对今年对时间的要求没有卡的那么死。比如我的<code>valueSum</code>没有采用动态维护，cpu时间最长似乎是4-5s的样子。</p><p>还有就是生成更强的数据时注意一些边界条件的设定，比如Tag的除0，id为负等等，还是得细心阅读jml，好好检查。</p><h3 id="规格与实现分离"><a href="#规格与实现分离" class="headerlink" title="规格与实现分离"></a>规格与实现分离</h3><p>本次单元三次作业强测互测都没有出现问题。然而，在完成作业的时候总会怀疑各种地方会不会超时，也不知道课程组会卡时间到什么程度，然后就权衡很久该采用什么策略…..</p><p>需要注意的是规格和实现分离，课程组给的jml实际上只是用最朴素直接的语言告诉程序的设计者最终需要怎么样的需求，至于具体如何实现，则完全和jml的表述无关，完全由我们自己来决定每个功能如何实现。</p><p>比如，为了实现$$O(1)$$的复杂度进行查找，我们大量使用了Map这一数据结构。我在实现并查集时单独引入了类<code>DisjiontSet</code>，在实现<code>dijkstra</code>查找最短路径的时候引入了<code>Node</code>类来记录各个节点，这也充分体现了规格和具体实现分离的思想。</p><h3 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h3><h4 id="hw9"><a href="#hw9" class="headerlink" title="hw9"></a>hw9</h4><p>在我的实现下，首先需要明确：并查集本身并不知道两个节点之间是否认识，通过<code>find</code>找到的父亲相等只代表两者是<strong>可达的</strong>(isCircle)。所以并查集的作用只是：<strong>判断两个人是否可达，而非是否认识，只是为了维护Block的个数。</strong></p><p>使用延迟重建整个并查集的思路：在MyNetwork类中设置一个脏位<code>needRebuild</code>，如果有删边操作就把脏位设置为<code>true</code>，这时认为整个并查集已经失效。</p><p>具体思路如下，是一个简单易行的做法。</p><table><thead><tr><th>指令</th><th>操作</th></tr></thead><tbody><tr><td>ar（加边）</td><td>如果脏位为0，则维护并查集（进行merge）；否则不维护</td></tr><tr><td>mr（删边）</td><td>将脏位设置为1，此时认为整个并查集已经失效</td></tr><tr><td>询问（isCircle和qbs）</td><td>如果脏位为1，重建整个并查集，否则并查集有效</td></tr></tbody></table><h4 id="hw10"><a href="#hw10" class="headerlink" title="hw10"></a>hw10</h4><p>主要加了一个<code>queryShortestPath</code>指令，我采用了迪杰斯特拉计算最短路径的方法。缺点就是跑一遍的话出发点到所有路径的最短距离都跑出来了，但实际上只会用到一个。所以我设置了一个脏位。每次跑出来的结果用一个Map来存储：<code>&lt;出发点id，&lt;其他所有点，出发点到该点的距离&gt;&gt;</code>，对以下两种指令的应对方法如下：</p><ul><li><p><code>ar</code>：只加了孤立点，到任何点的距离都为正无穷，反映到之前存储的map就是不存在key，抛异常即可</p></li><li><p><code>mr(删边情况)/ar</code>：设置脏位，下次查询需要重新跑dijkstra。</p></li></ul><p>其余一些询问的指令我都采用了动态维护，但由于<code>valueSum</code>有些麻烦就摆烂了，遍历了下熟人，复杂度$$O(mn)$$</p><h4 id="hw11"><a href="#hw11" class="headerlink" title="hw11"></a>hw11</h4><p>最愉快的一集，<del>舍友一晚上写完了甚至不敢相信自己</del>。只增加了一些常规的操作，只要按照jml细心地一步一步写问题就不大。</p><p>然而后来自己的代码超过500行了，为了满足checkStyle无奈只能新建一个类再继续写。。</p><h3 id="Junit测试"><a href="#Junit测试" class="headerlink" title="Junit测试"></a>Junit测试</h3><p>需要每次作业为一个函数写Junit测试。</p><p>Junit主要涉及<strong>数据构造</strong>和<strong>规格检查</strong>。由于我没有尝试在本地对我的Junit代码进行测试，导致我在编写Junit测试的时候心里完全没底，也只能通过交上去的反馈判断正误。</p><p>对于构造数据，在第一次作业我尝试使用了多次跑随机数据，效果也还好；不过后来都是只构造了一组较为复杂的数据。至于规格检查，由于不知道课程组提供的错误代码究竟会错到什么程度，我们必须按照jml规格一个字不差地进行最全面的检查。</p><h3 id="学习体会"><a href="#学习体会" class="headerlink" title="学习体会"></a>学习体会</h3><p>转眼间oo第三单元也接近尾声，相比前两个单元较大的思维量，这一单元更多注重的是代码的严谨和质量。jml类似于逻辑表达式的方式非常严谨，但也导致（对我来说）可读性不那么强。这一单元下来我也掌握了基于jml规格的项目开发流程，学会了最基本jml的阅读和书写，了解并实践了测试的流程，并且体会到了规格与设计分离的思想。</p><p>感谢267的3位神仙舍友以及提供评测机的大佬们orzzz</p>]]></content>
      
      
      
        <tags>
            
            <tag> OO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OO_Unit1</title>
      <link href="/2024/03/20/oo-unit1/"/>
      <url>/2024/03/20/oo-unit1/</url>
      
        <content type="html"><![CDATA[<h1 id="OO-Unit1-表达式化简"><a href="#OO-Unit1-表达式化简" class="headerlink" title="OO_Unit1: 表达式化简"></a>OO_Unit1: 表达式化简</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本单元OO作业主题是对给定表达式化简，第一次作业要求将含有一个<code>x</code>变量的表达式的所有括号展开。</p><p>解析输入的符合课程组给定文法的表达式，对表达式的结构进行解析后进行化简，我使用了递归下降的方法对表达式解析。事实上关于表达式的解析和化简都是基于逐层递归的思想进行的——首先，表达式的解析是从上到下进行解析，核心是<code>parseExpr-&gt;parseTerm-&gt;parseFac</code>，从而建起有这三个层次的表达式树；然后再进行表达式的化简计算，这一步就是从下往上计算，计算结果可以用<code>Ploy</code>存储，每一步计算返回一个<code>Poly</code>，首先计算合并用<code>*</code>连接的<code>Factor</code>，再合并用<code>+/-</code>连接的<code>Term</code>，最终得到了<code>Poly</code>进行输出就可以了。</p><p>我在完成本单元三次作业时的困难程度是递减的，第一次作业由于对递归下降思想完全没有概念，光是理解并思考完架构就花了两天时间，第二次作业增加了两大模块分别是<code>exp</code>因子和自定义函数，再加上由于我第一次作业的架构并没有很完善需要部分重构，工作量也蛮大的；至于第三次作业只有一个求导算子，在理解递归下降的思想的基础上很快就可以做完。</p><p>下面是我对三次作业的分析和总结。</p><h3 id="homework1"><a href="#homework1" class="headerlink" title="homework1"></a>homework1</h3><p>第一次作业的任务是展开一个单变量多项式，输出拆好括号并化简的表达式。</p><h4 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h4><h5 id="表达式的解析"><a href="#表达式的解析" class="headerlink" title="表达式的解析"></a>表达式的解析</h5><p>解析工作由词法分析器<code>Lexer</code>和解析器<code>Parser</code>构成。<code>Lexer</code>负责将表达式解析为数字/符号<code>+-*^()</code>/字母<code>x</code>等基本元素(token)，为Parser的解析工作提供了<code>next()</code>函数来获取每一个元素。</p><p>接下来就是<code>parser</code>进行解析，最终的返回的是一个<code>Expr</code>。</p><p>我的<code>Expr</code>类中包含了只储存了一个<code>Expr</code>和一个<code>Term</code>，以及连接两者的符号<code>op</code>，在解析时以<code>expr -&gt; expr + term</code>形式建立表达式树。这里有一些细节需要注意：</p><ul><li>由于计算表达式是从左往右计算的，因此不能将表达式解析为<code>expr -&gt;term+ expr</code>的形式，否则会违反运算顺序。例如在计算1-1+1时若按上述方法解析就会变成1-(1+1)。</li><li>但如果按照<code>exp -&gt; exp + term</code>解析，就需要在调用<code>parseExp()</code>函数内直接再调用<code>parseExp()</code>，从而陷入无限递归，解决方法是先调用<code>parseTerm</code>解析出<code>Term1</code>，将其向上转换为<code>Expr</code>。如果其后还有<code>+/-</code>，则继续调用parseTerm解析出<code>Term2</code>，更新要返回的<code>Expr=Expr+Term2</code>；如果没有<code>+/-</code>，即为递归边界，直接返回<code>Expr(Term1)</code>。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Expr</span> <span class="token function">parseExpr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">Term</span> term1 <span class="token operator">=</span> <span class="token function">parseTerm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Exp</span> expr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Expr</span><span class="token punctuation">(</span>term1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//向上转化为Expr，结构为Expr-&gt;Term</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>lexer<span class="token punctuation">.</span><span class="token function">peak</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"+"</span><span class="token punctuation">)</span> <span class="token operator">|</span> lexer<span class="token punctuation">.</span><span class="token function">peak</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"-"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">String</span> op <span class="token operator">=</span> lexer<span class="token punctuation">.</span><span class="token function">peak</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            lexer<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">Term</span> term2 <span class="token operator">=</span> <span class="token function">parseTerm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            expr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Expr</span><span class="token punctuation">(</span>expr<span class="token punctuation">,</span> term2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//expr -&gt; expr + term</span>            expr<span class="token punctuation">.</span><span class="token function">setOp</span><span class="token punctuation">(</span>op<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> expr<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>Term</code>的解析思路同上，我以<code>Term -&gt; Factor * Term</code>对<code>Term</code>进行解析。由于乘法计算无需考虑从左到右的顺序，先解析<code>Factor</code>是没问题的。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Term</span> <span class="token function">parseTerm</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">Term</span> term <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Term</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        term<span class="token punctuation">.</span><span class="token function">setFactor</span><span class="token punctuation">(</span><span class="token function">parseFactor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>lexer<span class="token punctuation">.</span><span class="token function">peak</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"*"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            lexer<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            term<span class="token punctuation">.</span><span class="token function">setTerm</span><span class="token punctuation">(</span><span class="token function">parseTerm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> term<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样解析表达式后建立的树是一个类似于二叉树的结构。</p><img src="https://s21.ax1x.com/2024/03/20/pFWTjVP.jpg" alt="" width="70%"><p>关于符号的处理，我在<code>expr -&gt; expr + term</code>这一步记录了符号，此外在每种<code>Factor</code>都添加了<code>sign</code>属性。事实上后者是没有必要的，由于只有<strong>在第一个因子/项之前，可以带一个正号或者负号</strong>，而预处理时我会将积压在每个项前连续的<code>+-</code>号处理掉，所以得到的表达式只需在以下两个位置加入符号判断：1.<code>Factor</code>乘积构成的<code>Term</code>前判断加减 2.至于因子前的符号，根据文法只需在<code>NumFac</code>前判断该数字的正负。</p><h5 id="表达式的化简"><a href="#表达式的化简" class="headerlink" title="表达式的化简"></a>表达式的化简</h5><p>化简是在解析建好的表达式树从底层逐层向上化简。</p><p>引入<code>Mono</code>类，里面只有一个<code>exponent</code>记录<code>x</code>的指数。</p><p>这一步封装我做的不好，当时的我写到这一步已经是周五了，没有引入<code>Poly</code>。我在<code>Expr</code>、<code>Term</code>和各种<code>Factor</code>类中都写了<code>simplify()</code>方法直接返回一个<code>HashMap&lt;BigInteger,Mono&gt;</code>（也就是之后的<code>toPoly</code>），从<code>Factor</code>开始向上化简，最终在main中调用<code>expr.simplify()</code>即可获得最终化简好的HashMap。</p><h4 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h4><img src="https://s21.ax1x.com/2024/03/21/pFfNkdK.jpg" alt="" width="80%"><h4 id="Bug分析"><a href="#Bug分析" class="headerlink" title="Bug分析"></a>Bug分析</h4><p>第一次作业我在预处理时加上了一个去除前导零的操作，事实上不仅<code>BigInteger</code>会自动处理前导零，而且我还把这个函数写错了，结果是数字只要有0就会被我删去一部分，纯纯的多写了个bug。这是一个比较严重的错误了，让我没想到的是强测居然只挂了一个点，真是对这个无比致命的错误来说非常的友好了orz 于是我也在第一次oo作业就获得极致的互hack乱砍体验，我用一些随机生成的数据便收获了约30%的命中率，甚至最后不知道自己在砍谁（bushi</p><p>修复bug就是把我那几行预处理删掉，至今有时想到这个错误还是不知道自己当时是怎么想的。。</p><h3 id="homework2"><a href="#homework2" class="headerlink" title="homework2"></a>homework2</h3><p>第二次作业增加了：1.自定义函数 2.指数函数因子。此外要求实现多层括号嵌套化简，这一点递归下降自然可以解决。</p><h4 id="设计思路-1"><a href="#设计思路-1" class="headerlink" title="设计思路"></a>设计思路</h4><p>多项式<code>Poly</code>类内用<code>ArrayList&lt;Mono&gt;</code>存储各个单项式，符号直接在<code>coe</code>中体现。</p><p>单项式Mono的结构调整如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Mono</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">BigInteger</span> coe<span class="token punctuation">;</span> <span class="token comment">//系数</span>    <span class="token keyword">private</span> <span class="token class-name">BigInteger</span> exponent<span class="token punctuation">;</span> <span class="token comment">//指数</span>    <span class="token keyword">private</span> <span class="token class-name">Poly</span> poly <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Poly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//exp(Poly)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h5><p>$$<br>Define: f(x_1,x_2,x_3)= Expr，将x扩展为x_1，x_2，x_3<br>$$</p><p>$$<br>Call: f(Factor_1, Factor_2, Factor_3)，此处Factor_i只包含x<br>$$</p><p>第二次作业在定义函数的时候保证不出现其他函数，但第三次作业可以在定义中调用之前定义过的函数。我在第二次作业中就实现了这个功能。</p><p>引入<code>FuncFac</code>类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FuncFac</span> <span class="token keyword">implements</span> <span class="token class-name">Factor</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> newFunc<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Expr</span> expr<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>为了保存和解析定义的函数，新建一个<code>Define</code>类来存储和解析自定义函数。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Define</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> defMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//储存读入的函数定义，Map：函数名-&gt;函数表达式，直接存储为String</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">ArrayList</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> paraMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//储存每个函数的形参列表：Map：函数名-&gt;[x1,x2,x3]</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">addFunc</span><span class="token punctuation">(</span><span class="token class-name">String</span> in<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 构造defMap</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">callFunc</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Factor</span><span class="token punctuation">&gt;</span></span> actualPara<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">//返回用实参代替、形参之后的函数调用形式</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我让<code>lexer</code>在处理过程中将整个函数调用<code>f(因子,因子,...)</code>作为一个<code>Token</code>，交给parser中的<code>parseFuncFac</code>函数解析。我们建立<code>ArrayList&lt;Factor&gt; actualPara</code>作为该函数的实参表，只要将括号内的由<code>,</code>隔开的各个因子解析出来放到List中就可以了。考虑到因子内可能依然含有<code>FuncFac</code>，我将括号里各个因子内部的,替换为不会出现的其他符号，再在分别解析因子的时候替换回来。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Factor</span> <span class="token function">parseFuncFac</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Factor</span><span class="token punctuation">&gt;</span></span> actualPara <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/*    * 将因子内的','换成其他字符    */</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> s <span class="token operator">:</span> str<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//将因子s中原本的,恢复</span>        <span class="token comment">//新建一个parser解析各个Factor</span>    <span class="token punctuation">}</span>    <span class="token comment">//解析name=f/g/h</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FuncFac</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> actualPara<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>至此再调用<code>FuncFac</code>的构造函数，解析<code>Define</code>中的<code>callFunc</code>返回的字符串，这样就得到解析好的函数的<code>Expr</code>了。</p><h5 id="表达式因子"><a href="#表达式因子" class="headerlink" title="表达式因子"></a>表达式因子</h5><p>格式是<code>exp(因子)</code>，注意这里的因子为<strong>不带指数的表达式因子</strong>时，该表达式因子两侧必要的一层括号。为此引入<code>ExpoFac</code>类。<code>parser</code>分别解析括号内的因子和括号外的指数即可。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ExpoFac</span> <span class="token keyword">implements</span> <span class="token class-name">Factor</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">Factor</span> factor<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">BigInteger</span> exp<span class="token punctuation">;</span><span class="token comment">//^a</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>作为<code>Factor</code>转化为<code>Poly</code>时，直接将指数<code>a</code>乘进<code>factor</code>。</p><h5 id="关于合并同类项"><a href="#关于合并同类项" class="headerlink" title="关于合并同类项"></a>关于合并同类项</h5><p>在计算的过程中<code>Poly</code>类中有一个<code>addMono</code>的方法，我直接遍历该<code>poly</code>的<code>MonoList</code>是否含有待加入<code>mono</code>的同类项，也就是需要重写<code>mono</code>的<code>equals</code>方法。<br>$$<br>Mono = Coe * x^{a} * exp (Poly)<br>$$</p><p>$$<br>Poly=\sum_{}^{}Mono<br>$$</p><p>要想判断两个<code>mono</code>是否可以合并，只需要比较<code>x</code>的指数<code>a</code>以及<code>e</code>指数上的<code>Poly</code>，这两者均相等就可以合并。作为<code>BigInteger</code>的<code>a</code>直接比较即可，而<code>Poly</code>的相等则需要我们再写相应的<code>equals</code>方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//Mono.java</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">myEqual</span><span class="token punctuation">(</span><span class="token class-name">Mono</span> mono<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//第一次调用Mono的equal，不需要看coe</span>    <span class="token keyword">return</span> exponent<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>mono<span class="token punctuation">.</span>exponent<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>poly<span class="token punctuation">,</span> mono<span class="token punctuation">.</span>poly<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那么<code>Poly</code>相等该如何判断呢？显然所有<code>Mono</code>相等时才能算是相等。这里我遇到了两个问题：</p><ul><li><p>对于<code>Poly</code>的比较我们实际上需要比较两个<code>List</code>中的元素是否完全一样，而<code>MonoList</code>中的<code>Mono</code>由于被add进来时顺序是未知的，那么这两个<code>List</code>该如何比较？</p><ul><li>我们第一次调用<code>mono</code>是否相等时是不需要比较<code>Coe</code>的。然而在比较<code>exp</code>指数上的内容时需要的是<code>mono</code>完全相等，系数也需要加入比较。否则如果按照最开始的<code>mono</code>比较策略就会出现将<code>exp(x)</code>和<code>exp((3*x))</code>合并的情况。</li></ul></li></ul><p>为了解决以上问题，我在<code>Poly</code>中重写了<code>equals</code>方法，返回的是同时比较<code>coe</code>，指数<code>a</code>和<code>poly</code>的结果。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//...</span>        <span class="token keyword">return</span> <span class="token class-name">Mono</span><span class="token punctuation">.</span><span class="token function">myEqual</span><span class="token punctuation">(</span>monos<span class="token punctuation">,</span> poly<span class="token punctuation">.</span>monos<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这需要我在<code>Mono</code>中写的另一个静态的用于比较的方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">myEqual</span><span class="token punctuation">(</span><span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Mono</span><span class="token punctuation">&gt;</span></span> m1<span class="token punctuation">,</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Mono</span><span class="token punctuation">&gt;</span></span> m2<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> m1<span class="token punctuation">.</span><span class="token function">containsAll</span><span class="token punctuation">(</span>m2<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> m2<span class="token punctuation">.</span><span class="token function">containsAll</span><span class="token punctuation">(</span>m1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里的<code>containsAll</code>会调用我重写的<code>Mono</code>的<code>equals</code>比较方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//...</span>        <span class="token class-name">Mono</span> mono <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Mono</span><span class="token punctuation">)</span> o<span class="token punctuation">;</span>        <span class="token keyword">return</span> exponent<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>mono<span class="token punctuation">.</span>exponent<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>coe<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>mono<span class="token punctuation">.</span>coe<span class="token punctuation">)</span>                <span class="token operator">&amp;&amp;</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>poly<span class="token punctuation">,</span> mono<span class="token punctuation">.</span>poly<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//此后调用的都是Poly的equals方法，需要比较系数</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里还有两个细节要注意：</p><p>1.在比较<code>Poly</code>之前还需要<code>removeZero()</code>操作，以除去<code>coe</code>为0的项。</p><p>2.关于深克隆：需要在<code>addMono</code>这个函数中深克隆。如果不进行深克隆，会出现把<code>Mono</code>直接放到<code>poly</code>相乘的结果中，之后<code>setCoe</code>的时候会由于指针指向同一个<code>Mono</code>而导致本来想修改的是答案<code>Poly</code>的系数，但顺便也把原先作为乘数<code>Poly</code>中的<code>Mono</code>也改了。我和这个问题从早上决斗到下午才改好。</p><p>结合这样一个例子就可以说明：<code>(exp(x)+1)^2</code>。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//Poly.java</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addMono</span><span class="token punctuation">(</span><span class="token class-name">Mono</span> mono<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">CloneNotSupportedException</span> <span class="token punctuation">{</span>    <span class="token comment">//计算Poly+Mono</span>    <span class="token class-name">Mono</span> monoClone <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Mono</span><span class="token punctuation">)</span> mono<span class="token punctuation">.</span><span class="token function">myClone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">if</span><span class="token punctuation">(</span>可以合并同类项<span class="token punctuation">)</span><span class="token punctuation">{</span>            m<span class="token punctuation">.</span><span class="token function">setCoe</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">getCoe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>mono<span class="token punctuation">.</span><span class="token function">getCoe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>monos<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>monoClone<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="结果输出"><a href="#结果输出" class="headerlink" title="结果输出"></a>结果输出</h5><p>我在<code>Mono</code>和<code>Poly</code>类中分别写了<code>toString</code>方法用于输出。</p><p>需要注意的是在<code>toString</code>的规范：只进行转换为字符串的操作。<strong>不要在<code>toString</code>里做一些改变对象内容的事请</strong>。如果在该函数中改变了对象中的内容可能会导致调试的时候结果正确而最后输出错误的情况。调试的时候对于对象会自动调用<code>toString</code>函数，如果没有写<code>toString</code>就会输出<code>@(toHex)HashCode</code>。</p><img src="https://s21.ax1x.com/2024/03/21/pFfGox1.png" alt="" width="90%"><h5 id="UML类图-1"><a href="#UML类图-1" class="headerlink" title="UML类图"></a>UML类图</h5><img src="https://s21.ax1x.com/2024/03/21/pFfNAIO.jpg" alt="" width="100%"><h3 id="homework3"><a href="#homework3" class="headerlink" title="homework3"></a>homework3</h3><h5 id="设计思路-2"><a href="#设计思路-2" class="headerlink" title="设计思路"></a>设计思路</h5><p>第三次作业增加了求导因子。第三次作业在我们之前的递归下降架构上很快就能写好。为此我加入<code>DiffFac</code>类。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DiffFac</span> <span class="token keyword">implements</span> <span class="token class-name">Factor</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">Expr</span> expr<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>先把每个因子的<code>toDiff()</code>写了，全部返回<code>Poly</code>。至于求导因子的嵌套需要如下处理。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token class-name">Poly</span> <span class="token function">toDiffPoly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">CloneNotSupportedException</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> expr<span class="token punctuation">.</span><span class="token function">toDiffPoly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toDiffPoly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>所以还要对<code>Mono</code>和<code>Poly</code>的求导，求导的过程也很直观。这里只要注意一下指数为0的时候返回<code>0</code>就可以了。</p><p>$$<br>Mono’ = (Coe*a) * x^{a-1} * exp (Poly)+Coe*x^{a}*exp(Poly)*Poly’<br>$$</p><p>$$<br>Poly’=\sum_{}^{}mono’<br>$$</p><h5 id="UML类图-2"><a href="#UML类图-2" class="headerlink" title="UML类图"></a>UML类图</h5><img src="https://s21.ax1x.com/2024/03/21/pFft829.png" alt="" width="100%"><h5 id="Bug分析-1"><a href="#Bug分析-1" class="headerlink" title="Bug分析"></a>Bug分析</h5><p>所幸后两次作业强测没有出现Bug，后两次发现的别人的Bug有：无法处理类似于<code>f((x)^2)</code>后面的指数，还有指数没改为<code>BigInteger</code>的，但由于cost我无法hack，以及一些tle。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><table><thead><tr><th>method</th><th>CogC</th><th align="left">ev(G)</th><th>iv(G)</th><th>v(G)</th></tr></thead><tbody><tr><td>Change.dealComa(String)</td><td>19.0</td><td align="left">1.0</td><td>6.0</td><td>10.0</td></tr><tr><td>Define.callFunc(String, ArrayList)</td><td>18.0</td><td align="left">3.0</td><td>7.0</td><td>13.0</td></tr><tr><td>Lexer.next()</td><td>8.0</td><td align="left">2.0</td><td>6.0</td><td>9.0</td></tr><tr><td>Poly.isSimple()</td><td>8.0</td><td align="left">4.0</td><td>6.0</td><td>6.0</td></tr><tr><td>Mono.toString()</td><td>7.0</td><td align="left">2.0</td><td>4.0</td><td>6.0</td></tr><tr><td>Parser.parseFactor()</td><td>7.0</td><td align="left">6.0</td><td>8.0</td><td>8.0</td></tr><tr><td>Lexer.getFunc()</td><td>6.0</td><td align="left">1.0</td><td>3.0</td><td>5.0</td></tr><tr><td>Parser.parseExpr()</td><td>6.0</td><td align="left">1.0</td><td>4.0</td><td>5.0</td></tr><tr><td>Term.toDiffPoly()</td><td>6.0</td><td align="left">1.0</td><td>4.0</td><td>4.0</td></tr><tr><td>Define.addFunc(String)</td><td>4.0</td><td align="left">1.0</td><td>3.0</td><td>5.0</td></tr><tr><td>Poly.addPoly(Poly, int)</td><td>4.0</td><td align="left">1.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Mono.equals(Object)</td><td>3.0</td><td align="left">3.0</td><td>3.0</td><td>5.0</td></tr><tr><td>Parser.parseNumFac()</td><td>3.0</td><td align="left">1.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Poly.addMono(Mono)</td><td>3.0</td><td align="left">3.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Poly.changeOrder()</td><td>3.0</td><td align="left">3.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Poly.mulPoly(Poly, Poly)</td><td>3.0</td><td align="left">1.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Poly.removeZero()</td><td>3.0</td><td align="left">1.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Poly.toString()</td><td>3.0</td><td align="left">2.0</td><td>3.0</td><td>4.0</td></tr><tr><td>ExprFac.toDiffPoly()</td><td>2.0</td><td align="left">2.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Lexer.getNumber()</td><td>2.0</td><td align="left">1.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Mono.toDiffPoly()</td><td>2.0</td><td align="left">1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Poly.addPolyNew(Poly, Poly)</td><td>2.0</td><td align="left">1.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Poly.equals(Object)</td><td>2.0</td><td align="left">3.0</td><td>1.0</td><td>3.0</td></tr><tr><td>Poly.powPoly(Poly, BigInteger)</td><td>2.0</td><td align="left">2.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Term.toPoly()</td><td>2.0</td><td align="left">2.0</td><td>2.0</td><td>3.0</td></tr><tr><td>VarFac.toDiffPoly()</td><td>2.0</td><td align="left">1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>ExpoFac.toPoly()</td><td>1.0</td><td align="left">2.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Expr.toDiffPoly()</td><td>1.0</td><td align="left">1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Expr.toPoly()</td><td>1.0</td><td align="left">1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Main.main(String[])</td><td>1.0</td><td align="left">1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Mono.isOnlyE()</td><td>1.0</td><td align="left">1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Mono.isOnlyX()</td><td>1.0</td><td align="left">1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Mono.myEqual(ArrayList, ArrayList)</td><td>1.0</td><td align="left">1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Mono.myEqual(Mono)</td><td>1.0</td><td align="left">1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Parser.parseExponent()</td><td>1.0</td><td align="left">1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Parser.parseFuncFac()</td><td>1.0</td><td align="left">1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Parser.parseTerm(int)</td><td>1.0</td><td align="left">1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Poly.myClone()</td><td>1.0</td><td align="left">1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Poly.toDiffPoly()</td><td>1.0</td><td align="left">1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Change.process(String)</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>DiffFac.DiffFac(Expr)</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>DiffFac.toDiffPoly()</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>DiffFac.toPoly()</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>ExpoFac.ExpoFac(Factor, BigInteger)</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>ExpoFac.toDiffPoly()</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Expr.Expr()</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Expr.addTerm(Term)</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>ExprFac.ExprFac(Expr, BigInteger)</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>ExprFac.toPoly()</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>FuncFac.FuncFac(String, ArrayList)</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>FuncFac.toDiffPoly()</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>FuncFac.toPoly()</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Lexer.Lexer(String)</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Lexer.peak()</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Mono.Mono(BigInteger, BigInteger)</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Mono.Mono(BigInteger, BigInteger, Poly)</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Mono.Mono(Poly)</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Mono.getCoe()</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Mono.getExponent()</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Mono.getPoly()</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Mono.mulMono(Mono, Mono)</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Mono.myClone()</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Mono.setCoe(BigInteger)</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Mono.setExponent(BigInteger)</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>NumFac.NumFac(BigInteger)</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>NumFac.toDiffPoly()</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>NumFac.toPoly()</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Parser.Parser(Lexer)</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Parser.parseDiffFac()</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Parser.parseExpoFac()</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Parser.parseExprFac()</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Parser.parseVarFac()</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Poly.Poly()</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Term.Term()</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Term.addFactor(Factor)</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Term.getSign()</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Term.setSign(int)</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>VarFac.VarFac(BigInteger)</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>VarFac.toPoly()</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Total</td><td>143.0</td><td align="left">104.0</td><td>159.0</td><td>185.0</td></tr><tr><td>Average</td><td>1.810</td><td align="left">1.316</td><td>2.013</td><td>2.342</td></tr></tbody></table><p>我在处理函数逗号的<code>dealComa</code>方法中引入了较为复杂的循环分支以支持处理嵌套函数，其实这里的嵌套交给parser也可以完成。还有就是<code>Define</code>中<code>callFunc</code>中我分别判断是<code>x/y/z</code>使得复杂度较高。我在<code>Mono</code>的<code>toString</code>中做了一些简化，同样需要各种判断。但除了<code>Lexer</code>和<code>ParseFactor</code>需要解析各种Token和因子，<code>if-else</code>难免较多之外，前面提到的还是可以进一步优化解耦使得框架更为清晰。</p><h3 id="总结与心得"><a href="#总结与心得" class="headerlink" title="总结与心得"></a>总结与心得</h3><ul><li><p>在优化方面我则基本没做，每次做完作业就都剩下<code>TODO</code>，甚至将正项提前这一基本的优化我也是第二次才做。</p></li><li><p>本单元第一次作业由于我封装的不够彻底，直到第二次作业才开始引入<code>Poly</code>类。好在思路还是统一的，并没有进行大规模的修改。</p></li></ul><p>本单元的递归下降方法要求我们写代码时头脑非常清晰，需要明确每一层递归到底发生了什么。我对面向对象思维的理解也更为深刻，在思考架构的时候尽量降低代码间的耦合度。此外我在判断对象相等时所用的<code>equals</code>和<code>HashCode</code>相关知识有了更进一步的了解，其中有很多更深刻的知识有待学习，总而言之还是很有收获的一次作业。</p>]]></content>
      
      
      
        <tags>
            
            <tag> OO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OO_Unit2</title>
      <link href="/2024/03/20/oo-unit2/"/>
      <url>/2024/03/20/oo-unit2/</url>
      
        <content type="html"><![CDATA[<h1 id="OO-Unit2-电梯调度"><a href="#OO-Unit2-电梯调度" class="headerlink" title="OO_Unit2: 电梯调度"></a>OO_Unit2: 电梯调度</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>OO第二单元主要是对多部电梯的运行进行模拟，要求我们使用多线程编程，难点在于理解线程交互过程，需要通过对合适的共享对象加锁来解决线程安全问题。多个线程的同步进行使得需要分析的情况变得复杂多变，而且错误是概率出现的，增加了作业完成和debug难度。随着作业结构越发复杂，更需要理清电梯调度的时序等多种细节，总之要清楚某些时刻电梯在干什么事儿才能尽量避免bug的出现。</p><h3 id="hw5"><a href="#hw5" class="headerlink" title="hw5"></a>hw5</h3><p>电梯第一次作业需要管理6部电梯，题目已经给出每个<code>Request</code>需要乘坐的电梯ID。本次作业我对多线程设计有了基本的概念，对synchronize同步块和锁的设置有了初步体会。此外我也意识到解耦的重要性，运用好面向对象思想，使用好的架构和明确的分工会让整个作业的构建和调试难度大大降低，同时也会让自己的思路更加清晰明确。</p><h4 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h4><h5 id="生产者-消费者模型"><a href="#生产者-消费者模型" class="headerlink" title="生产者-消费者模型"></a>生产者-消费者模型</h5><p>本次作业首先要解决的是如何将乘客请求正确分配给电梯。</p><p>我用<code>RequestTable</code>类来存储请求。该类实例化为以下两种请求队列：</p><ul><li><code>allRequest</code>：用于存放来自输入所有的请求。</li><li><code>ElevatorReqTable</code>：每个电梯都会实例化一个该电梯专有的请求，用于存放该电梯要处理的请求队列。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RequestTable</span> <span class="token punctuation">{</span>    <span class="token comment">//&lt;楼层序号，出发地在该楼层的请求&gt;</span>    <span class="token keyword">private</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">ArrayList</span><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> requestMap<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> isEnd<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我使用生产者-消费者模型，其中生产者是输入线程类<code>Input</code>，该类拥有实例<code>allRequest</code>，每当有请求输入进来就新建一个<code>Person</code>加入到<code>allRequest</code>中；消费者是<code>Elevator</code>类，每个实例化的电梯都有自己的<code>eleReqTable</code>作为待处理请求。此外输入线程类还负责在输入结束后将总请求队列的<code>isEnd</code>置1代表不再会有新请求，输入结束。</p><p><code>Manager</code>类在这里发挥分配请求的作用，同时拥有以上两种<code>RequestTable</code>。主要负责：</p><ul><li><p>如果<code>allRequest</code>中还有请求，则将其pop出来，按照所需乘坐的电梯id交给相应的电梯自己的<code>eleReqTable</code>。</p></li><li><p>如果<code>allRequest</code>中没有请求了而且<code>isEnd</code>为1，则将电梯的子table也设为结束结束本进程。</p></li></ul><p>至此电梯类通过成员变量<code>eleReqTable</code>获得了自己需要处理的请求。这时电梯需要根据自身状态以及请求决定其行为。</p><h5 id="电梯调度"><a href="#电梯调度" class="headerlink" title="电梯调度"></a>电梯调度</h5><p>我的电梯类有如下成员变量：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Elevator</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">,</span> <span class="token class-name">RequestTable</span> reqTable<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>reqTable <span class="token operator">=</span> reqTable<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>curFloor <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>curNum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//电梯内总人数</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>direction <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>destMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// HashMap&lt;Integer, ArrayList&lt;Person&gt;&gt;，当前在电梯内部的Person，按照目的地层数划分</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>strategy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Strategy</span><span class="token punctuation">(</span>reqTable<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>电梯会有如下的行为：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">move</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//电梯沿着原方向移动一层，改变curFloor即可</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token class-name">OpenAndClose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//电梯开门，人员先下后上getOut(),getIn()，关门</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//电梯转向，direction取反</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">getOut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//目的地为这一层的人全部出去，直接将destMap整个键删去</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">getIn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//从电梯请求队列移除，delRequest返回需要进入电梯的Person列表</span>        <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">&gt;</span></span> inPersonList <span class="token operator">=</span> reqTable<span class="token punctuation">.</span><span class="token function">delRequest</span><span class="token punctuation">(</span>curFloor<span class="token punctuation">,</span> <span class="token number">6</span> <span class="token operator">-</span> curNum<span class="token punctuation">,</span> direction<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Person</span> per <span class="token operator">:</span> inPersonList<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">//加入电梯的destMap</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>电梯该如何决定进行何种行为，需要引入<code>Strategy</code>策略类，该类中的一个<code>getAdvice</code>函数会将具体策略<code>(OPEN, MOVE, REVERSE, WAIT, END)</code>交给电梯。所以策略类需要获取当前电梯的请求队列，在之前电梯构造创建自己的<code>Strategy</code>时已经作为<code>Strategy</code>自己的成员变量传入了；至于当前电梯的状态则会在调用<code>getAdvice</code>函数时作为参数传入，具体来说就是：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Advice</span> <span class="token function">getAdvice</span><span class="token punctuation">(</span><span class="token keyword">int</span> curFloor<span class="token punctuation">,</span> <span class="token keyword">int</span> curNum<span class="token punctuation">,</span> <span class="token keyword">int</span> dir<span class="token punctuation">,</span>                       <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">ArrayList</span><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> destMap<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>接下来执行具体的电梯调度策略就行了，这里我选择了简单易行的LOOK算法。</p><h5 id="锁的设置"><a href="#锁的设置" class="headerlink" title="锁的设置"></a>锁的设置</h5><p>由于<code>RequestTable</code>类在多个线程中使用，因此对这个类的任何读写操作我都加了锁。此外，由于对<code>RequestTable</code>的任何读写操作我都在该类内完成，我的所有<code>synchronized</code>块全部而且仅出现在请求类中。具体来说，读写<code>RequestTable</code>类主要分为以下几种情况：</p><ul><li><code>addPerson</code>: 两类请求都要用，用于向请求队列中加入新的请求<code>(Person)</code>。</li><li>由主请求队列<code>allRequest</code>调用的：<ul><li><code>popPerson</code>: 从主请求中pop出一个Person用于分配给电梯子请求。</li></ul></li><li>由电梯的分请求队列<code>eleReqTable</code>调用的：<ul><li><code>delRequest</code>: 用于从电梯子请求队列中移除一些符合要求的请求，即代表这些Person进入电梯。</li></ul></li><li>上面的方法全都要加锁，此外还有一些判断Map是否为空，读和写<code>isEnd</code>和其他一些队列情况的方法，也需要上锁。这样我的读写全部封装在类内进行，外面只需要调用这些函数即可。</li></ul><p>至于<code>notifyAll</code>，当一个线程调用了某个对象的 <code>notifyAll()</code> 方法时，该对象上所有调用了 <code>wait()</code> 方法而被挂起的线程都将被唤醒，然后它们会竞争对象上的锁。考虑我整个程序中的两个需要<code>wait</code>的地方：</p><ul><li>主请求队列在<code>popPerson</code>时主请求队列空了，但输入还没有结束，也就是需要等待外部输入新的请求。在这种情况下：①若外部输入了新的请求，则会通过<code>addPerson</code>函数进行，所以<code>addPerson</code>我增加了<code>notifyAll()</code> 来唤醒。②如果不会再有新的输入，就会执行<code>setEnd</code>，所以在<code>setEnd</code>也增加<code>notifyAll()</code>。</li><li>在每个电梯的分请求队列中同理，不过主请求等待的是<code>Input</code>传入，分请求等待<code>Manager</code>的分配。</li></ul><p>所以我只在上述两个函数里进行了<code>notifyAll()</code>。</p><h4 id="Bug分析"><a href="#Bug分析" class="headerlink" title="Bug分析"></a>Bug分析</h4><p>强测和互测没有出现bug，需要注意的是：</p><ul><li>超载判断：我一开始在<code>Strategy</code>内判断需要是否需要开门的时候想着先下后上，因此没有在<code>getAdvice</code>中判断是否超载，只在电梯内执行<code>getIn</code>的时候进行了判断。但这造成了电梯一直在某层开关门停不下来的情况。原因是：<code>openToOut(...) | openToIn(...)</code>这一<code>|</code>关系代表着，在没有人在这一层要下电梯的时候才会进行判断有没有人要上电梯的操作，既然没人要下电梯就必然要判断是否超载，因为如果在这里不判断的话返回的就会是开门操作，开门又发现人进不去，于是就造成了上述的死循环。在<code>openToIn</code>中判断人数是否超载即可。</li><li>由于会对请求队列的<code>Map</code>进行是否为空的判断，在进行<code>Map</code>的删除时，我都进行了<strong>这个键对应的List是否为空</strong>的判断，如果为空就直接把这个键删除，这样保证在没有请求（请求被删干净）之后<code>Map</code>也是空的。</li></ul><h4 id="UML类图-amp-时序图"><a href="#UML类图-amp-时序图" class="headerlink" title="UML类图&amp;时序图"></a>UML类图&amp;时序图</h4><img src="https://s21.ax1x.com/2024/03/29/pFobQ81.png" width="100%"><img src="https://s21.ax1x.com/2024/04/19/pkSkfDH.png" style="zoom:50%;"><h3 id="hw6"><a href="#hw6" class="headerlink" title="hw6"></a>hw6</h3><h4 id="设计思路-1"><a href="#设计思路-1" class="headerlink" title="设计思路"></a>设计思路</h4><p>第二次迭代新增了电梯<code>RESET</code>功能，电梯接收到重置请求后尽快停下，将所有人放出后修改相关属性，再投入使用，此外还需要自行设计电梯的分配。为了杜绝自由竞争的使用，需要电梯接到请求后输出<code>RECEIVE</code>后才能进行合法移动。</p><h5 id="处理RESET请求"><a href="#处理RESET请求" class="headerlink" title="处理RESET请求"></a>处理RESET请求</h5><p>首先对于<code>RESET</code>的处理，调度器<code>Manager</code>类新增方法<code>resetElevator</code>，该方法修改需重置电梯对应<code>RequestTable</code>的<code>resetRequest</code>属性，使其从原先的<code>null</code>变成相应的重置请求。那么电梯便可以在<code>getAdvice</code>时获得<code>RESET</code>的建议，从而执行重置请求。注意请求表类中的<code>setResetReq</code>方法需要<code>notifyAll</code>。此外结束条件需要加上一条：所有电梯都不在reset才能结束。</p><p>需要注意的是电梯的<code>reset</code>执行顺序。如果先把<code>Person</code>扔回总表再输出，可能出现同一个人被<code>RECEIVE</code>两次的情况，所以要先立即输出<code>RESET_BEGIN</code>。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">allOut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//电梯内的乘客清空，扔回电梯请求队列</span>    <span class="token class-name">TimableOutput</span><span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"RESET_BEGIN-"</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">&gt;</span></span> personList <span class="token operator">=</span> reqTable<span class="token punctuation">.</span><span class="token function">delAllRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    allRequest<span class="token punctuation">.</span><span class="token function">getAllRequest</span><span class="token punctuation">(</span>personList<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//执行重置，sleep 1.2s</span>        <span class="token class-name">TimableOutput</span><span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"RESET_END-"</span> <span class="token operator">+</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>    reqTable<span class="token punctuation">.</span><span class="token function">setResetReq</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="电梯调度-1"><a href="#电梯调度-1" class="headerlink" title="电梯调度"></a>电梯调度</h5><p><code>import java.util.Random;</code></p><p>为了保证正确性我直接采用随机策略。在随机到一个电梯之后只要不在reset就返回其id，如果恰好所有电梯都在reset状态就睡一会儿。这个策略使我在互测从上午10点被hack到第二天下午5点钟，原因在于当只剩下一部电梯可运行时，我的调度策略会把所有请求全部给剩下一部电梯，导致<code>rtle</code>。修改也很简单，就是判断一下仅当<code>≥3</code>部电梯在运行时才进行任务分配。</p><h4 id="Bug分析-1"><a href="#Bug分析-1" class="headerlink" title="Bug分析"></a>Bug分析</h4><p>本次作业强测由于采取了随机策略分数不高但没有出现问题。互测则出现了上述未限流导致的一个问题。</p><p>此外，课下我在交中测时发现自己出现了近10s的cpu时间<del>但不知道为什么一直没ctle</del>，于是我开始寻找轮询的可能性。在使用idea自带的Profiler运行时我发现我的cpu浪费了大量资源在<code>Manager</code>的<code>run</code>方法中。打印输出发现在这个循环内出现了轮询的情况。当电梯输入全部结束且主请求表为空时，就会进入判断是否全都不在reset状态。如果得到了<code>false</code>，就会迅速无限重复上述过程造成了轮询，解决方法就是加一个else让程序睡过去。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>allRequest<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> allRequest<span class="token punctuation">.</span><span class="token function">isEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">allNotReset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">//...</span>                <span class="token comment">//输入结束，将所有子table设为结束，本进程结束</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token class-name">Person</span> per <span class="token operator">=</span> allRequest<span class="token punctuation">.</span><span class="token function">popPerson</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>per <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//将Person分配给电梯</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="UML类图-amp-时序图-1"><a href="#UML类图-amp-时序图-1" class="headerlink" title="UML类图&amp;时序图"></a>UML类图&amp;时序图</h4><img src="https://s21.ax1x.com/2024/04/15/pFvRJYQ.png"><img src="https://s21.ax1x.com/2024/04/19/pkSkWKe.png" style="zoom:50%;"><h3 id="hw7"><a href="#hw7" class="headerlink" title="hw7"></a>hw7</h3><p>第7次作业增加了双轿厢电梯的重置请求，复杂度进一步提高。</p><h4 id="设计思路-2"><a href="#设计思路-2" class="headerlink" title="设计思路"></a>设计思路</h4><p>本次作业我将<code>Manager</code>改为单例模式，这样做的好处是其他类需要使用总表<code>allRequest</code>的时候可以通过<code>Manager</code>直接获取，实现起来更加清晰和安全。此外前两次作业我在main函数让各个线程分别开始跑，本次作业改为层次化的<code>start</code>，使得程序层次更清晰。</p><p>我在<code>Manager</code>类中实现两类电梯的创建和管理。首先是<code>Manager</code>的构造方法负责创建总表，6个电梯的分请求表对象，以及6部电梯的启动。实际上我们在调度器<code>Manager</code>中并非直接管理电梯，甚至不需要专门设置管理<code>Elevator</code>电梯类的容器——我们实际上都是通过操作电梯所对应的<code>requestTable</code>来进行管理的。我先前使用<code>List</code>管理6个请求表，但考虑到之后有双轿厢电梯和普通电梯同时运行，本次作业我简单地使用<code>HashMap&lt;Integer, RequestTable&gt; requestMap</code>统一管理两种电梯。具体映射方法如下。初始就只需新建key为1-6的电梯请求表。查看给定<code>id</code>的电梯，如果是普通电梯就会存在<code>key=id</code>， 如果是双轿电梯则存在<code>key=id + 6</code>和<code>key=id + 12</code>。</p><table><thead><tr><th align="center">Key</th><th align="center">Value</th></tr></thead><tbody><tr><td align="center">1-6</td><td align="center">普通电梯1-6的请求表</td></tr><tr><td align="center">7-12</td><td align="center">双轿厢电梯A1-A6的请求表</td></tr><tr><td align="center">13-18</td><td align="center">双轿厢电梯B1-B6的请求表</td></tr></tbody></table><h5 id="双轿厢电梯RESET"><a href="#双轿厢电梯RESET" class="headerlink" title="双轿厢电梯RESET"></a>双轿厢电梯RESET</h5><p>这类请求相当于需要把原来的电梯直接弃用，再new两个新电梯。关于请求的设置思路与<code>NormalReset</code>相同，依然是在电梯相应的<code>requestTable</code>里修改属性，然后电梯通过<code>Advice</code>得到。不同的是原先的电梯线程执行完<code>dcReset</code>之后就可以光荣下岗了，我的实现中直接将其<code>break</code>掉，线程结束。</p><p>至于电梯的<code>dcReset</code>函数，同样需要将电梯里的人全都赶出去扔回总表，打印等流程，然后我令其调用<code>Manager</code>创建双轿厢电梯的方法，然后该电梯圆满完成任务。</p><p><code>createLine</code>新建双轿厢电梯，引入<code>Line</code>类实现双轿厢电梯的管理，在其中设置新电梯的相关属性并使其<code>start</code>即可。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">createLine</span><span class="token punctuation">(</span><span class="token class-name">DoubleCarResetRequest</span> dcReq<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//新创建 requestTableA，requestTableB</span>requestMap<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>eleId<span class="token punctuation">)</span><span class="token punctuation">;</span>    requestMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>eleId <span class="token operator">+</span> <span class="token number">6</span><span class="token punctuation">,</span> requestTableA<span class="token punctuation">)</span><span class="token punctuation">;</span>    requestMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>eleId <span class="token operator">+</span> <span class="token number">12</span><span class="token punctuation">,</span> requestTableB<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//...</span>   <span class="token comment">//新建Line</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="电梯防撞"><a href="#电梯防撞" class="headerlink" title="电梯防撞"></a>电梯防撞</h5><p>另一个重点就是如何避免电梯在A，B共享的停靠层相撞。引入<code>Floor</code>类作为一对双轿电梯的共享对象，在创建<code>Line</code>对象的时候将其作为电梯的属性分配给两个新电梯。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Floor</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> isOccupied<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">RequestTable</span> reqTableA<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">RequestTable</span> reqTableB<span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当双轿厢类型电梯在运行<code>move()</code>的时候需要特判一下：如果电梯下一步会<code>move</code>到换乘层，就需要判断<code>Floor</code>是否被占用。同样地使用<code>RequestTable</code>作为信息传递的媒介,新增<code>isNeedAway</code>属性即可。同样需要判断，如果双轿厢电梯离开了换乘层将<code>occupied</code>标志解除占用。</p><p>另一个重要的问题是如果电梯已经占有<code>floor</code>，移动到了换乘层，需要额外再获取一下Advice，如果这时候得到的是<code>OPEN</code>，就需要开门。</p><p>新增一个<code>AWAY</code>的<code>Advice</code>，如果这时有电梯在换乘层且挡道了就让其避开。最后，如果一个双轿厢电梯在得到结束的<code>Advice</code>时，如果还停在换乘层，同样让其<code>AWAY</code>以避免出现因电梯A停止运行而B电梯无法让A再避开的情况。</p><p><code>ADVICE</code>的优先级问题：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Strategy</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token class-name">Advice</span> <span class="token function">getAdvice</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>reqTable<span class="token punctuation">.</span><span class="token function">getNormalResetRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token class-name">Advice</span><span class="token punctuation">.</span><span class="token constant">RESET</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>reqTable<span class="token punctuation">.</span><span class="token function">getDcResetReq</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token class-name">Advice</span><span class="token punctuation">.</span><span class="token constant">DCRESET</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">openToOut</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">openToIn</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token class-name">OpenToTransfer</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token class-name">Advice</span><span class="token punctuation">.</span><span class="token constant">OPEN</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>curFloor <span class="token operator">==</span> transFloor <span class="token operator">&amp;&amp;</span> reqTable<span class="token punctuation">.</span><span class="token function">isNeedAway</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token class-name">Advice</span><span class="token punctuation">.</span><span class="token constant">AWAY</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>curNum <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token comment">//look算法...</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这一部分电梯的运行以及<code>Advice</code>的获取有很多细节要注意，一旦出现一些小问题就很容易出现电梯遁地，升天等停不下来的情况，不过相比死锁和轮询还是友好的。</p><p>至于互斥的实现，一开始的时候我使用了一种类似于下述代码的方法，先检查是否有占用标记，若没被占用留下标志。后来看到osppt明确说明了这样实现的问题，即：<code>Occupied</code>的读和写会出现一个空档，无法真正实现互斥。当时已经是周五晚，于是也直接通过<code>sleep</code>解决。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token class-name">Occupied</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token class-name">Occupied</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token comment">//访问Floor</span><span class="token class-name">Occupied</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="双轿厢电梯乘客换乘"><a href="#双轿厢电梯乘客换乘" class="headerlink" title="双轿厢电梯乘客换乘"></a>双轿厢电梯乘客换乘</h5><p>由于双轿厢电梯的出现，有些乘客一次分配是无法被送达目的地的。这时我会把人扔回总表。这时总表结束条件判断还需要新增一个条件，那就是所有需要换乘的乘客请求都完成。为此为<code>Person</code>新建<code>needTransfer</code>属性。在调度器中引入记录需要换乘的乘客数量<code>transferNum</code>。每当把一个<code>personRequest</code>分配给双轿电梯时，就需要判断一下这个A/B电梯是否能一趟把乘客送达。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">int</span> <span class="token function">getEleId</span><span class="token punctuation">(</span><span class="token class-name">Person</span> person<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> id <span class="token operator">=</span> random<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>requestMap<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//分配给单轿厢</span>            <span class="token comment">//... return id</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">//双轿电梯</span>            <span class="token keyword">int</span> tmp<span class="token punctuation">;</span><span class="token comment">//用于决定给A/B梯</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isChange</span><span class="token punctuation">(</span>from<span class="token punctuation">,</span> <span class="token keyword">to</span><span class="token punctuation">,</span> transFloor<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//不需要换乘</span>                <span class="token comment">//...确定tmp</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                transferNum<span class="token operator">++</span><span class="token punctuation">;</span>                person<span class="token punctuation">.</span><span class="token function">setNeedTransfer</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//该人分配给了双轿电梯，且需要换乘</span>                <span class="token comment">//...确定tmp</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> tmp <span class="token operator">*</span> <span class="token number">6</span> <span class="token operator">+</span> id<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在<code>Elevator</code>开关门的时候也需要更改：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token class-name">OpenAndClose</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//...</span>    <span class="token function">getOut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> curFloor <span class="token operator">==</span> transferFloor<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">transfer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token class-name">Advice</span> adv <span class="token operator">=</span> strategy<span class="token punctuation">.</span><span class="token function">getAdvice</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>adv <span class="token operator">==</span> <span class="token class-name">Advice</span><span class="token punctuation">.</span><span class="token constant">REVERSE</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token function">getIn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//...</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//将电梯里所有需要换乘的人放出去, 扔回总表</span>        <span class="token comment">//...遍历电梯内剩下的乘客</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>per<span class="token punctuation">.</span><span class="token function">isNeedTransfer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">//开门放人...</span>            per<span class="token punctuation">.</span><span class="token function">setFromFloor</span><span class="token punctuation">(</span>transferFloor<span class="token punctuation">)</span><span class="token punctuation">;</span>            per<span class="token punctuation">.</span><span class="token function">setNeedTransfer</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">Manager</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getAllRequestTable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addPerson</span><span class="token punctuation">(</span>per<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">Manager</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">decTransferNum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            listIter<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//把这个人删去</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>换乘函数<code>transfer</code>负责将电梯里所有需要换乘的人放出去, 扔回总表。这时，在我的实现下，最好先执行完<code>getOut()</code>，将所有本来就在该换乘层到达目的地的乘客送出去。这时双轿电梯剩下的乘客应该只剩下因被迫换乘而下电梯的乘客。依然要注意<code>Map</code>在对应键为空的时候要维护，将整个键也删除。</p><p>于是我在结束条件判断的时候，总共需要判断：①总表输入结束且总表为空 ②普通电梯不能在执行任意一种reset，且所有分请求表为空 ③需要换乘的乘客都送完了，<code>transferNum != 0</code>。这样结束条件的问题也解决了。</p><h4 id="Bug分析-2"><a href="#Bug分析-2" class="headerlink" title="Bug分析"></a>Bug分析</h4><p>本次作业强测和互测都没有出现bug。一些细节是：<br>我在对<code>RequestTable</code>的属性<code>(NormalResetReq，dcResetRequest，needAway)</code>进行<code>set</code>的时候都进行了<code>notifyAll</code>。对于第二次作业会被hack的数据，我继续采用sleep，也就是如果随机到的电梯刚好在reset就睡，然后获取新的随机id，随到一个能用的电梯为止。这样既保证了很难被hack，又保证了这样一个最基本的策略分数注定很低。</p><h4 id="UML类图-amp-时序图-2"><a href="#UML类图-amp-时序图-2" class="headerlink" title="UML类图&amp;时序图"></a>UML类图&amp;时序图</h4><img src="https://s21.ax1x.com/2024/04/15/pFvhq1J.png"><img src="https://s21.ax1x.com/2024/04/19/pkSkc8K.png" style="zoom:50%;"><h3 id="变和不变"><a href="#变和不变" class="headerlink" title="变和不变"></a>变和不变</h3><p>我在三次迭代中总体架构没有太大的变化，基本是直接在原先的架构上增加新的功能。首先<code>Input，Manager，Elevator</code>三个线程类的共嫩没有改变，<code>RequestTable</code>作为共享资源的性质及其传递信息的功能也没有改变。同样我的调度策略<del>由于没有</del>也没有变化。</p><p>为了实现新增的两种类型<code>RESET</code>，我在<code>Manager</code>中分别新增了相关的同步方法，通过请求表共享信息。另外电梯的策略以及<code>run</code>方法也要做相关调整。对于双轿厢电梯的重置还为<code>Person</code>类新增了属性以辨别乘客换乘请求是否结束。</p><h3 id="总结与心得"><a href="#总结与心得" class="headerlink" title="总结与心得"></a>总结与心得</h3><img src="https://s21.ax1x.com/2024/04/17/pFxI5aq.png" alt="final"><p>本单元让我对多线程有了深刻的体会，同时我也加强了合理进行规划设计，降低耦合，让线程间各司其职的意识，加深了我对面向对象思想的理解。我也又一次意识到保持代码的简洁和结构的清晰是多么重要。</p><p>传说中的电梯单元总算是快结束了，总体来看我三次作业的完成和debug过程果然是困难重重。之前我习惯性打断点调试的方法不再适用，我非常清晰地记得第三次迭代的周四周五的两点钟依然在宿舍debug，<del>看到错误的输出仿佛能听到我电梯相撞的声音。。</del>虽然最后没有出现很大的问题，但不足之处也很明显，就是为了保证最基本的正确性可以说是一点优化也没做了，几乎全是睡过去的。希望以后能在优化方面做得更好吧orz</p><p>最后，<strong>感谢X267三位神仙的巨大帮助orzzzzzzzz/(ㄒoㄒ)/~~</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> OO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HelloBlog</title>
      <link href="/2023/02/04/helloblog/"/>
      <url>/2023/02/04/helloblog/</url>
      
        <content type="html"><![CDATA[<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h2 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h2><p>whale梦拓是个好梦拓。</p>]]></content>
      
      
      
        <tags>
            
            <tag> try </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
