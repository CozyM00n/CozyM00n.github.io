<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>OS_lab3</title>
      <link href="/2024/04/14/lab3-shi-yan-bao-gao/"/>
      <url>/2024/04/14/lab3-shi-yan-bao-gao/</url>
      
        <content type="html"><![CDATA[<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h4 id="Thinking-3-1"><a href="#Thinking-3-1" class="headerlink" title="Thinking 3.1"></a>Thinking 3.1</h4><p><strong>Q:  Thinking 3.1 请结合 MOS 中的页目录自映射应用解释代码中 <code>e-&gt;env_pgdir[PDX(UVPT)]= PADDR(e-&gt;env_pgdir) | PTE_V</code> 的含义</strong>  </p><p><strong>A:</strong>  </p><p>该语句实现了自映射。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">e<span class="token operator">-&gt;</span>env_pgdir<span class="token punctuation">[</span><span class="token function">PDX</span><span class="token punctuation">(</span>UVPT<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">PADDR</span><span class="token punctuation">(</span>e<span class="token operator">-&gt;</span>env_pgdir<span class="token punctuation">)</span> <span class="token operator">|</span> PTE_V<span class="token punctuation">;</span><span class="token comment">//实现了映射：虚拟地址UVPT &lt;-&gt; 该进程页目录自身的pa</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这使得UVPT这个虚拟地址对应的页目录项，该页目录项不再对应二级页表，而是指向页目录自身。</p><blockquote><p>自映射的作用：在用户空间划分出一部分，使得用户可以通过访问这部分空间得到二级页表以及页目录中的内容。</p><p>具体来说，<code>UVPT</code>以上的4KB空间(1024个页表的大小)被标记为 <code>User VPT</code>。我们用这部分虚拟地址<code>va</code>访存的话过程如下：</p><p>首先，这个地址会经过页目录，<code>PDX(va)</code> 的结果和 <code>UVPT</code> 相同，我们进入到索引对应的二级页表——由于上述自映射，我们得到的还是<strong>页目录自身</strong>。</p><p>好的，我们在页目录中重新来一遍，这次通过 <code>PTX(va)</code> 计算索引，结果就不一定还是页目录项了。我们找到了一个物理页，取出了其中的数据。可是等等，这个物理页却不再是一般的物理页了，而是<strong>作为二级页表的物理页</strong>。这样我们就<strong>取到了二级页表的内容</strong>。</p><p>另外假如我们恰好取得的 <code>PTX(va)</code> 值与 <code>PDX(va)</code> 相同，那么我们绕了两圈，最终还是处在页目录之中，这样我们就<strong>取到了页目录的内容</strong>。</p></blockquote><h4 id="Thinking-3-2"><a href="#Thinking-3-2" class="headerlink" title="Thinking 3.2"></a>Thinking 3.2</h4><p><strong>Q:</strong>  </p><p><strong><code>elf_load_seg</code> 以函数指针的形式，接受外部自定义的回调函数 <code>map_page</code>。 请你找到与之相关的 <code>data</code> 这一参数在此处的来源，并思考它的作用。没有这个参数可不可以？为什么？</strong> </p><p><strong>A:</strong> </p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//lib/elfloader.c</span><span class="token keyword">int</span> <span class="token function">elf_load_seg</span><span class="token punctuation">(</span>Elf32_Phdr <span class="token operator">*</span>ph<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>bin<span class="token punctuation">,</span> <span class="token class-name">elf_mapper_t</span> map_page<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>data<span class="token punctuation">)</span>    <span class="token comment">//kern/env.c</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">load_icode</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Env</span> <span class="token operator">*</span>e<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>binary<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">const</span> Elf32_Ehdr <span class="token operator">*</span>ehdr <span class="token operator">=</span> <span class="token function">elf_from</span><span class="token punctuation">(</span>binary<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//...for循环遍历所有的程序头表</span>    <span class="token comment">//如果其对应的程序需要被加载到内存，则调用elf_load_seg进行加载</span><span class="token function">panic_on</span><span class="token punctuation">(</span><span class="token function">elf_load_seg</span><span class="token punctuation">(</span>ph<span class="token punctuation">,</span> binary <span class="token operator">+</span> ph<span class="token operator">-&gt;</span>p_offset<span class="token punctuation">,</span> load_icode_mapper<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//...</span>e<span class="token operator">-&gt;</span>env_tf<span class="token punctuation">.</span>cp0_epc <span class="token operator">=</span> ehdr <span class="token operator">-&gt;</span> e_entry<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">load_icode_mapper</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>data<span class="token punctuation">,</span> u_long va<span class="token punctuation">,</span> <span class="token class-name">size_t</span> offset<span class="token punctuation">,</span>                              u_int perm<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>src<span class="token punctuation">,</span> <span class="token class-name">size_t</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//该函数 将数据映射到虚拟地址所在的页上</span><span class="token keyword">struct</span> <span class="token class-name">Env</span> <span class="token operator">*</span>env <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Env</span> <span class="token operator">*</span><span class="token punctuation">)</span>data<span class="token punctuation">;</span> <span class="token comment">//将 data 还原为进程控制块</span>    <span class="token comment">//...</span>    <span class="token keyword">return</span> <span class="token function">page_insert</span><span class="token punctuation">(</span>env<span class="token operator">-&gt;</span>env_pgdir<span class="token punctuation">,</span> env<span class="token operator">-&gt;</span>env_asid<span class="token punctuation">,</span> p<span class="token punctuation">,</span> va<span class="token punctuation">,</span> perm<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//env可区别不同进程的相同虚拟地址</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>elf_load_seg</code> 函数根据程序头表中的信息将<code>bin</code>中的数据加载到指定位置。其中<code>void* data</code>是回调函数需要使用的参数。<code>elf_load_seg</code> 函数在<code>load_icode</code>函数中被调用。</p><p>这里的<code>struct Env *e</code>是<code>load_icode</code>函数的传入参数，<code>env_create</code>中我们用<code>env_alloc</code>分配到新的Env，调用<code>load_icode</code>函数来为进程加载 ELF 程序。</p><p>所以，这个<code>data</code>参数作为待加载的进程管理块指针是必要的，它被传入回调函数<code>load_icode_mapper()</code>，用来告知后者加载到哪个进程的虚拟内存中。</p><h4 id="Thinking-3-3"><a href="#Thinking-3-3" class="headerlink" title="Thinking 3.3"></a>Thinking 3.3</h4><p>**Q:  结合 elf_load_seg 的参数和实现，考虑该函数需要处理哪些页面加载的情况。 **</p><p><strong>A:</strong></p><ul><li>(1) 段起始地址未页面对齐</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">u_long offset <span class="token operator">=</span> va <span class="token operator">-</span> <span class="token function">ROUNDDOWN</span><span class="token punctuation">(</span>va<span class="token punctuation">,</span> PAGE_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>offset <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//先映射到内存的页中</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token function">map_page</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> va<span class="token punctuation">,</span> offset<span class="token punctuation">,</span> perm<span class="token punctuation">,</span> bin<span class="token punctuation">,</span>  <span class="token function">MIN</span><span class="token punctuation">(</span>bin_size<span class="token punctuation">,</span> PAGE_SIZE <span class="token operator">-</span> offset<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> r<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>(2) 处理数据中间完整的部分，通过循环不断将数据加载到页上。</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> offset <span class="token operator">?</span> <span class="token function">MIN</span><span class="token punctuation">(</span>bin_size<span class="token punctuation">,</span> PAGE_SIZE <span class="token operator">-</span> offset<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> bin_size<span class="token punctuation">;</span> i <span class="token operator">+=</span> PAGE_SIZE<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token function">map_page</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> va <span class="token operator">+</span> i<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> perm<span class="token punctuation">,</span> bin <span class="token operator">+</span> i<span class="token punctuation">,</span> <span class="token function">MIN</span><span class="token punctuation">(</span>bin_size <span class="token operator">-</span> i<span class="token punctuation">,</span> PAGE_SIZE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">return</span> r<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>(3) 段大小大于数据大小的情况，补充空页面</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> sgsize<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token function">map_page</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> va <span class="token operator">+</span> i<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> perm<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token function">MIN</span><span class="token punctuation">(</span>sgsize <span class="token operator">-</span> i<span class="token punctuation">,</span> PAGE_SIZE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">return</span> r<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    i <span class="token operator">+=</span> PAGE_SIZE<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Thinking-3-4"><a href="#Thinking-3-4" class="headerlink" title="Thinking 3.4"></a>Thinking 3.4</h4><p>**Q: ** </p><blockquote><p>这里的 <code>env_tf.cp0_epc</code> 字段指示了进程恢复运行时 PC 应恢复到的位置。我们要运行的进程的代码段预先被载入到了内存中，且程序入口为 <code>e_entry</code>，当我们运行进程时，CPU 将自动从PC 所指的位置开始执行二进制码。</p></blockquote><p><strong>思考上面这一段话，并根据自己在 Lab2 中的理解，回答： 你认为这里的 <code>env_tf.cp0_epc</code> 存储的是物理地址还是虚拟地址?</strong></p><p><strong>A:</strong>  虚拟地址。对于每个用户进程来说<code>entry_point</code>都应该是一样的（如果不手动进行设置的话），虚拟地址能够实现程序的每次执行都从一个固定的地址开始。</p><h4 id="Thinking-3-5"><a href="#Thinking-3-5" class="headerlink" title="Thinking 3.5"></a>Thinking 3.5</h4><p>**Q: **</p><p><strong>试找出 0、1、2、3 号异常处理函数的具体实现位置。8 号异常（系统调用） 涉及的 do_syscall() 函数将在 Lab4 中实现</strong></p><p><strong>A:</strong></p><p>0 号异常 的处理函数为 <code>handle_int</code>，表示中断，由时钟中断、控制台中断等中断造成<br>1 号异常 的处理函数为 <code>handle_mod</code>，表示存储异常，进行存储操作时该页被标记为只读<br>2 号异常 的处理函数为<code>handle_tlb</code>，表示 TLB load 异常<br>3 号异常 的处理函数为<code>handle_tlb</code>，表示 TLB store 异常</p><p><code>kern/genex.S</code></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;asm/asm.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stackframe.h&gt;</span></span><span class="token punctuation">.</span>macro BUILD_HANDLER exception handler<span class="token function">NESTED</span><span class="token punctuation">(</span>handle_\exception<span class="token punctuation">,</span> TF_SIZE <span class="token operator">+</span> <span class="token number">8</span><span class="token punctuation">,</span> zero<span class="token punctuation">)</span>    move    a0<span class="token punctuation">,</span> sp    addiu   sp<span class="token punctuation">,</span> sp<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">8</span>    jal     \handler    addiu   sp<span class="token punctuation">,</span> sp<span class="token punctuation">,</span> <span class="token number">8</span>    j       ret_from_exception<span class="token function">END</span><span class="token punctuation">(</span>handle_\exception<span class="token punctuation">)</span><span class="token punctuation">.</span>endm<span class="token punctuation">.</span>text<span class="token function">FEXPORT</span><span class="token punctuation">(</span>ret_from_exception<span class="token punctuation">)</span>    RESTORE_ALL    eret<span class="token function">NESTED</span><span class="token punctuation">(</span>handle_int<span class="token punctuation">,</span> TF_SIZE<span class="token punctuation">,</span> zero<span class="token punctuation">)</span> <span class="token comment">// handle_int 实现</span>    mfc0    t0<span class="token punctuation">,</span> CP0_CAUSE    mfc0    t2<span class="token punctuation">,</span> CP0_STATUS    and     t0<span class="token punctuation">,</span> t2    andi    t1<span class="token punctuation">,</span> t0<span class="token punctuation">,</span> STATUS_IM7    bnez    t1<span class="token punctuation">,</span> timer_irqtimer_irq<span class="token operator">:</span>    li      a0<span class="token punctuation">,</span> <span class="token number">0</span>    j       schedule<span class="token function">END</span><span class="token punctuation">(</span>handle_int<span class="token punctuation">)</span>BUILD_HANDLER tlb do_tlb_refill <span class="token comment">// kern/tlbex.c</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token operator">!</span><span class="token function">defined</span><span class="token punctuation">(</span>LAB<span class="token punctuation">)</span> <span class="token operator">||</span> LAB <span class="token operator">&gt;=</span> <span class="token number">4</span></span></span>BUILD_HANDLER mod do_tlb_mod <span class="token comment">// kern/tlbex.c</span>BUILD_HANDLER sys do_syscall <span class="token comment">// kern/syscall_all.c</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>BUILD_HANDLER reserved do_reserved <span class="token comment">// kern/traps.c</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Thinking-3-6"><a href="#Thinking-3-6" class="headerlink" title="Thinking 3.6"></a>Thinking 3.6</h4><p><strong>Q:  阅读 <code>entry.S</code>、<code>genex.S</code> 和 <code>env_asm.S</code> 这几个文件，并尝试说出时钟中断 在哪些时候开启，在哪些时候关闭。</strong></p><p><strong>A:</strong> </p><h2 id="难点分析"><a href="#难点分析" class="headerlink" title="难点分析"></a>难点分析</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">Env</span> <span class="token operator">*</span><span class="token function">env_create</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>binary<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">,</span> <span class="token keyword">int</span> priority<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">struct</span> <span class="token class-name">Env</span> <span class="token operator">*</span>e<span class="token punctuation">;</span><span class="token comment">/* Step 1: Use 'env_alloc' to alloc a new env. */</span><span class="token comment">/* Exercise 3.7: Your code here. (1/3) */</span><span class="token function">env_alloc</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>e<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* Step 2: Assign the 'priority' to 'e' and mark its 'env_status' as runnable. */</span><span class="token comment">/* Exercise 3.7: Your code here. (2/3) */</span>e<span class="token operator">-&gt;</span>env_pri <span class="token operator">=</span> priority<span class="token punctuation">;</span>e<span class="token operator">-&gt;</span>env_status <span class="token operator">=</span> ENV_RUNNABLE<span class="token punctuation">;</span><span class="token comment">/* Step 3: Use 'load_icode' to load the image from 'binary', and insert 'e' into * 'env_sched_list' using 'TAILQ_INSERT_HEAD'. */</span><span class="token comment">/* Exercise 3.7: Your code here. (3/3) */</span><span class="token function">load_icode</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> binary<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">TAILQ_INSERT_HEAD</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>env_sched_list<span class="token punctuation">,</span> e<span class="token punctuation">,</span> env_sched_link<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> e<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C" data-language="C"><code class="language-C">PCB(进程控制块)由ENV结构体实现#define LIST_ENTRY(type)                                                                   struct {                           struct type *le_next;  /* next element */ struct type **le_prev; /* address of previous next element */     }LIST_ENTRY(Env) env_link;/-----------------------/void env_init(void);1.初始化2个list2.创建一个 “模板页目录”，设置该页将 pages 和 envs （即所有页控制块和所有进程控制块的内存空间）（内核）分别映射到 UPAGES 和 UENVS （用户）的空间中.并且在后续进程创建新的页目录时，也要首先复制模板页目录中的内容。使得用户程序也能够通过 UPAGES 和 UENVS 的用户地址空间获取 Page 和 Env 的信息。即：映射：UTOP 到 UVPT 的虚拟地址空间 &lt;-&gt; 内核数组pages, envs/*************************/struct Env *env_create(const void *binary, size_t size, int priority);在mips_init中调用，用于创建一个进程    /************************/int env_alloc(struct Env **new, u_int parent_id);1 从env_free_list获取一个空的PCB : struct Env *e;2 env_setup_vm(e); 始化新进程的地址空间3 初始化Env结构体的一些变量4 将e从free_list中移除，*new=e    /**********************/static int env_setup_vm(struct Env *e); //初始化进程控制块的用户地址空间1 申请一个page(物理页)作为页目录2 (UTOP ~ UVPT)这一段虚拟地址空间对应的页表项    /***************************/static void load_icode(struct Env *e, const void *binary, size_t size)加载可执行文件binary到进程e的内存中1 调用了 elf_from 函数从二进制数据中读取了页表信息,(简单地对二进制数据做类型转换，并检查是否确为 ELF 文件头)2 遍历所有的程序头表,取出对应的程序头，如果其中的 p_type 类型为 PT_LOAD，说明其对应的程序需要被加载到内存中。我们调用 elf_load_seg 函数来进行加载3 最后，我们将进程控制块中 trap frame 的 epc cp0 寄存器的值设置为 ELF 文件中设定的程序入口地址               /**********定义在lib中************/     int elf_load_seg(Elf32_Phdr *ph, const void *bin,    \                     elf_mapper_t map_page, void *data)    //将elf文件的一个segment加载到内存    //将bin中的数据加载到指定位置    1 Elf32_Phdr *ph：指向 ELF 文件中一个程序段头部的指针，可获取程序段va等信息    2 按页 调用回调函数 map_page(data, va, offset, perm, bin, ?? len)    elf_mapper_t map_page     //是一个回调函数，用于将数据映射到虚拟地址所在的页上    static int load_icode_mapper(void *data, u_long va, size_t offset,                                  u_int perm, const void *src, size_t len)    1 data还原为进程控制块Env*    2 申请空闲物理页p    3 如果存在需要拷贝的数据(src!= null)，用memcpy将src数据拷贝到p对应的内存    4 调用 page_insert 将虚拟地址映射到页上，需要env结构体中的信息，用来区别不同进程的相同虚拟地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>IE:中断使能,1代表中断开启</p><h2 id="实验心得"><a href="#实验心得" class="headerlink" title="实验心得"></a>实验心得</h2>]]></content>
      
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OS_lab2</title>
      <link href="/2024/03/21/lab2-shi-yan-bao-gao/"/>
      <url>/2024/03/21/lab2-shi-yan-bao-gao/</url>
      
        <content type="html"><![CDATA[<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h4 id="Thinking-2-1"><a href="#Thinking-2-1" class="headerlink" title="Thinking 2.1"></a>Thinking 2.1</h4><p><strong>Q:  请根据上述说明，回答问题：在编写的 C 程序中，指针变量中存储的地址被视为虚拟地址，还是物理地址？ MIPS 汇编程序中 lw 和 sw 指令使用的地址被视为虚拟地址，还是物理地址？</strong>  </p><p><strong>A:</strong>  均为虚拟地址。</p><h4 id="Thinking-2-2"><a href="#Thinking-2-2" class="headerlink" title="Thinking 2.2"></a>Thinking 2.2</h4><p><strong>Q:</strong>  </p><p><strong>• 从可重用性的角度，阐述用宏来实现链表的好处。</strong></p><p><strong>• 查看实验环境中的<code> /usr/include/sys/queue.h</code>，了解其中单向链表与循环链表的实现，比较它们与本实验中使用的双向链表，分析三者在插入与删除操作上的性能差异。</strong></p><p><strong>A:</strong> 宏定义使得我们在不必担心地址和栈的管理的情况下实现函数的功能，使得代码更为简洁和清晰，可读性和可维护性更强。</p><p><strong>单项链表：</strong>如果要在指定项之后插入，可以以O(1)直接进行，若是在指定项之前插入，或删除指定项，则需从头开始遍历以获得指定项的前一项。</p><p><strong>双向链表：</strong>由于可以直接获得某一项的前两项，所以指定项的前/后一项的插入和指定项删除都可以以O(1)实现。</p><p><strong>循环链表：</strong> 由于维护了一个指向尾部的指针，可以实现O(1)在tail和head之间插入；其余性质同单向链表。</p><h4 id="Thinking-2-3"><a href="#Thinking-2-3" class="headerlink" title="Thinking 2.3"></a>Thinking 2.3</h4><p><strong>Q: 请阅读 include/queue.h 以及 include/pmap.h, 将 Page_list 的结构梳理清楚，选择正确的展开结构。</strong></p><p><strong>A:</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">Page_list</span> <span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token punctuation">{</span>        <span class="token keyword">struct</span> <span class="token punctuation">{</span>            <span class="token keyword">struct</span> <span class="token class-name">Page</span> <span class="token operator">*</span>le_next<span class="token punctuation">;</span>            <span class="token keyword">struct</span> <span class="token class-name">Page</span> <span class="token operator">*</span><span class="token operator">*</span>le_prec<span class="token punctuation">;</span>        <span class="token punctuation">}</span> pp_link<span class="token punctuation">;</span>        u_short pp_ref<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token operator">*</span> lh_first<span class="token punctuation">;</span>   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Thinking-2-4"><a href="#Thinking-2-4" class="headerlink" title="Thinking 2.4"></a>Thinking 2.4</h4><p>**Q: ** </p><p><strong>• 请阅读上面有关 TLB 的描述，从虚拟内存和多进程操作系统的实现角度，阐述 ASID的必要性。</strong></p><p><strong>• 请阅读 MIPS 4Kc 文档《MIPS32® 4K™ Processor Core Family Software User’sManual》的 Section 3.3.1 与 Section 3.4，结合 ASID 段的位数，说明 4Kc 中可容纳不同的地址空间的最大数量</strong></p><p><strong>A:</strong></p><p>每个进程都有其对应的页表，ASID用于区分当前虚拟地址是在哪个进程中使用的，使得同一虚拟地址在不同地址空间正确被映射到不同的物理地址中。</p><p>ASID段共6位，因此4Kc中最多可容纳<code>2^6=64</code>个不同的地址空间。</p><h4 id="Thinking-2-5"><a href="#Thinking-2-5" class="headerlink" title="Thinking 2.5"></a>Thinking 2.5</h4><p><strong>• tlb_invalidate 和 tlb_out 的调用关系？</strong></p><p><code>tlb_invalidate</code> 调用了 <code>tlb_out</code>函数。</p><p><strong>• 请用一句话概括 tlb_invalidate 的作用。</strong></p><p>将该地址空间的va虚拟地址对应的表项清空。</p><p><strong>• 逐行解释 tlb_out 中的汇编代码。</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">LEAF</span><span class="token punctuation">(</span>tlb_out<span class="token punctuation">)</span><span class="token punctuation">.</span>set noreorder    mfc0    t0<span class="token punctuation">,</span> CP0_ENTRYHI <span class="token comment">//将EntryHi的原有值保存到t0寄存器</span>    mtc0    a0<span class="token punctuation">,</span> CP0_ENTRYHI <span class="token comment">//将a0中保存的旧表项的Key(VPN+ASID)写入EntryHi</span>    nop    <span class="token comment">/* Step 1: Use 'tlbp' to probe TLB entry */</span>    <span class="token comment">/* Exercise 2.8: Your code here. (1/2) */</span>    tlbp <span class="token comment">//根据EntryHi中的Key在TLB中找到相应表项，将表项索引存入Index</span>    nop    <span class="token comment">/* Step 2: Fetch the probe result from CP0.Index */</span>    mfc0    t1<span class="token punctuation">,</span> CP0_INDEX <span class="token comment">//将Index中的值存入t1寄存器</span><span class="token punctuation">.</span>set reorder    bltz    t1<span class="token punctuation">,</span> NO_SUCH_ENTRY <span class="token comment">//如果t1&lt;0，即没有在TLB中找到EntryHi对应的表项则跳转</span><span class="token punctuation">.</span>set noreorder    mtc0    zero<span class="token punctuation">,</span> CP0_ENTRYHI <span class="token comment">//将EntryHi，EntryLo0，EntryLo1寄存器赋值为0</span>    mtc0    zero<span class="token punctuation">,</span> CP0_ENTRYLO0    mtc0    zero<span class="token punctuation">,</span> CP0_ENTRYLO1    nop    <span class="token comment">/* Step 3: Use 'tlbwi' to write CP0.EntryHi/Lo into TLB at CP0.Index  */</span>    <span class="token comment">/* Exercise 2.8: Your code here. (2/2) */</span>    tlbwi <span class="token comment">//将清零后的EntryHi/Lo值写入对应Index的表项中</span><span class="token punctuation">.</span>set reorderNO_SUCH_ENTRY<span class="token operator">:</span>    mtc0    t0<span class="token punctuation">,</span> CP0_ENTRYHI <span class="token comment">//将EntryHi恢复为原始值</span>    j       ra <span class="token comment">//函数返回</span><span class="token function">END</span><span class="token punctuation">(</span>tlb_out<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Thinking-2-6"><a href="#Thinking-2-6" class="headerlink" title="Thinking 2.6"></a>Thinking 2.6</h4><p><strong>Q:  简单了解并叙述 X86 体系结构中的内存管理机制，比较 X86 和 MIPS 在内存管理上的区别</strong></p><p><strong>A:</strong> </p><ul><li>X86有三种不同的地址空间：逻辑地址，线性地址，物理地址。通过分段机制将逻辑地址转换为线性地址，线性地址经过分页机制的处理转换为物理地址。x86可能存在不分页的情况，但一定分段。MIPS则不分段，直接采用分页机制来管理内存。</li><li>TLB不命中时： MIPS 会触发TLB Refill 异常，内核的 <code>tlb_refill_handler</code> 会以 <code>pgd_current</code> 为当前进程的 <code>PGD</code> 基址，索引获得转换失败的虚址对应的 <code>PTE</code>，并将其填入TLB，然后CPU再用刚刚转换失败的虚拟地址重新访问以下TLB；X86 在 TLB 不命中时，是由硬件 MMU 以 CR3 为当前进程的 PGD 基址，索引获得 PFN 后，直接输出 PA。同时 MMU 会填充 TLB 以加快下次转换的速度。对于转换失败的虚址，MIPS使用<code>BadVAddr</code>寄存器存放，X86使用<code>CR2</code>存放。</li></ul><h4 id="Thinking-A-1"><a href="#Thinking-A-1" class="headerlink" title="Thinking A.1"></a>Thinking A.1</h4><p><strong>Q:  在现代的 64 位系统中，提供了 64 位的字长，但实际上不是 64 位页式存储系统。假设在 64 位系统中采用三级页表机制，页面大小 4KB。由于 64 位系统中字长为8B，且页目录也占用一页，因此页目录中有 512 个页目录项，因此每级页表都需要 9 位。因此在 64 位系统下，总共需要 3 × 9 + 12 = 39 位就可以实现三级页表机制，并不需要 64位。</strong></p><p><strong>现考虑上述 39 位的三级页式存储系统，虚拟地址空间为 512 GB，若三级页表的基地址为 PTbase，请计算：</strong><br><strong>• 三级页表页目录的基地址。</strong><br><strong>• 映射到页目录自身的页目录项（自映射）</strong></p><img src="lab2%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20240411125928105.png" alt="image-20240411125928105" style="zoom:50%;"><h2 id="难点分析"><a href="#难点分析" class="headerlink" title="难点分析"></a>难点分析</h2><p>页控制块是 <code>struct Page</code> 类型的结构体。每一个页控制块对应一个物理页。Page的链表宏展开后：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">Page</span> <span class="token punctuation">{</span><span class="token keyword">struct</span> <span class="token punctuation">{</span><span class="token keyword">struct</span> <span class="token class-name">Page</span> <span class="token operator">*</span>le_next<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">Page</span> <span class="token operator">*</span><span class="token operator">*</span>le_prev<span class="token punctuation">;</span><span class="token punctuation">}</span> pp_link<span class="token punctuation">;</span>u_short pp_ref<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>**空闲链表(page_free_list):**空闲物理页对应的 Page 结构体全部插入这个链表中  </p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">Page_list</span> page_free_list<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>pmap.h</code>中定义了：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">Page_list</span> <span class="token punctuation">{</span>                 <span class="token keyword">struct</span> <span class="token class-name">Page</span> <span class="token operator">*</span>lh_first<span class="token punctuation">;</span> <span class="token comment">//first element</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//由LIST_HEAD(Page_list, Page);定义</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>一些宏</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define PTE_ADDR(pte) (((u_long)(pte)) &amp; ~0xFFF)//获取页目录项对应的二级页表基地址，就是将页目录项内容的低12位抹零u_long page2ppn(struct Page *pp) {return pp - pages;}// 给定物理页pp，返回pp是第几个页static inline u_long page2pa(struct Page *pp) {return page2ppn(pp) &lt;&lt; PGSHIFT;}//给定物理页struct Page *pp，获取物理页pp的基地址：//先得到pp是第几个页，再乘上物理页大小    #define PPN(pa) (((u_long)(pa)) &gt;&gt; 12) //返回物理地址对应的页数static inline struct Page *pa2page(u_long pa) {if (PPN(pa) &gt;= npage) {panic("pa2page called with invalid pa: %x", pa);}return &amp;pages[PPN(pa)];} //给出某一页的pa，返回指向这个页的page指针static inline u_long page2kva(struct Page *pp) {return KADDR(page2pa(pp));}//page转化为在kseg0的虚拟地址判定一个页目录项是否有效：if(( (*pgdir_entryp)  &amp; PTE_V ) == 0) //(无效)获取对应二级页表基地址：Pte *pgtable = (Pte*) KADDR(PTE_ADDR(*pgdir_entryp));PTE_ADDR(*pgdir_entryp)将页目录项低12位抹零，获得二级页表基地址pa，再用KADDR()转换为kseg0下的va由上二级页表基地址，获取对应页表项：Pte* pgtable_entry = pgtable + PTX(va);//PTX即获取0-1023的偏移量，是va的12-21位判断是否有效同上得到页表项内容：*pgtable_entry抹去低12位perm，获得pa(物理页基地址，高20位)pp = pa2page(*pgtable_entry);//不抹也行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="实验心得"><a href="#实验心得" class="headerlink" title="实验心得"></a>实验心得</h2><p>lab2的工作主要涉及两点：两级页表机制的实现，和TLB的维护。总的来说任务量相比前两次实验有所增加，在刚开始实验的时候对各种复杂的链表宏和指针理解起来非常困难，<del>边写边理解的过程好像也很折磨</del></p><p>不过总的来说完成lab2让我对二级页表和tlb的具体实现有了基本的概念，也加深了我对指针的理解。通过实验也能和理论所学的东西结合起来，总之还是学到了很多东西。</p>]]></content>
      
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OO_Unit1</title>
      <link href="/2024/03/20/oo-unit1/"/>
      <url>/2024/03/20/oo-unit1/</url>
      
        <content type="html"><![CDATA[<h1 id="OO-Unit1-表达式化简"><a href="#OO-Unit1-表达式化简" class="headerlink" title="OO_Unit1: 表达式化简"></a>OO_Unit1: 表达式化简</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本单元OO作业主题是对给定表达式化简，第一次作业要求将含有一个<code>x</code>变量的表达式的所有括号展开。</p><p>解析输入的符合课程组给定文法的表达式，对表达式的结构进行解析后进行化简，我使用了递归下降的方法对表达式解析。事实上关于表达式的解析和化简都是基于逐层递归的思想进行的——首先，表达式的解析是从上到下进行解析，核心是<code>parseExpr-&gt;parseTerm-&gt;parseFac</code>，从而建起有这三个层次的表达式树；然后再进行表达式的化简计算，这一步就是从下往上计算，计算结果可以用<code>Ploy</code>存储，每一步计算返回一个<code>Poly</code>，首先计算合并用<code>*</code>连接的<code>Factor</code>，再合并用<code>+/-</code>连接的<code>Term</code>，最终得到了<code>Poly</code>进行输出就可以了。</p><p>我在完成本单元三次作业时的困难程度是递减的，第一次作业由于对递归下降思想完全没有概念，光是理解并思考完架构就花了两天时间，第二次作业增加了两大模块分别是<code>exp</code>因子和自定义函数，再加上由于我第一次作业的架构并没有很完善需要部分重构，工作量也蛮大的；至于第三次作业只有一个求导算子，在理解递归下降的思想的基础上很快就可以做完。</p><p>下面是我对三次作业的分析和总结。</p><h3 id="homework1"><a href="#homework1" class="headerlink" title="homework1"></a>homework1</h3><p>第一次作业的任务是展开一个单变量多项式，输出拆好括号并化简的表达式。</p><h4 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h4><h5 id="表达式的解析"><a href="#表达式的解析" class="headerlink" title="表达式的解析"></a>表达式的解析</h5><p>解析工作由词法分析器<code>Lexer</code>和解析器<code>Parser</code>构成。<code>Lexer</code>负责将表达式解析为数字/符号<code>+-*^()</code>/字母<code>x</code>等基本元素(token)，为Parser的解析工作提供了<code>next()</code>函数来获取每一个元素。</p><p>接下来就是<code>parser</code>进行解析，最终的返回的是一个<code>Expr</code>。</p><p>我的<code>Expr</code>类中包含了只储存了一个<code>Expr</code>和一个<code>Term</code>，以及连接两者的符号<code>op</code>，在解析时以<code>expr -&gt; expr + term</code>形式建立表达式树。这里有一些细节需要注意：</p><ul><li>由于计算表达式是从左往右计算的，因此不能将表达式解析为<code>expr -&gt;term+ expr</code>的形式，否则会违反运算顺序。例如在计算1-1+1时若按上述方法解析就会变成1-(1+1)。</li><li>但如果按照<code>exp -&gt; exp + term</code>解析，就需要在调用<code>parseExp()</code>函数内直接再调用<code>parseExp()</code>，从而陷入无限递归，解决方法是先调用<code>parseTerm</code>解析出<code>Term1</code>，将其向上转换为<code>Expr</code>。如果其后还有<code>+/-</code>，则继续调用parseTerm解析出<code>Term2</code>，更新要返回的<code>Expr=Expr+Term2</code>；如果没有<code>+/-</code>，即为递归边界，直接返回<code>Expr(Term1)</code>。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Expr</span> <span class="token function">parseExpr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">Term</span> term1 <span class="token operator">=</span> <span class="token function">parseTerm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Exp</span> expr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Expr</span><span class="token punctuation">(</span>term1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//向上转化为Expr，结构为Expr-&gt;Term</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>lexer<span class="token punctuation">.</span><span class="token function">peak</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"+"</span><span class="token punctuation">)</span> <span class="token operator">|</span> lexer<span class="token punctuation">.</span><span class="token function">peak</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"-"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">String</span> op <span class="token operator">=</span> lexer<span class="token punctuation">.</span><span class="token function">peak</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            lexer<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">Term</span> term2 <span class="token operator">=</span> <span class="token function">parseTerm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            expr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Expr</span><span class="token punctuation">(</span>expr<span class="token punctuation">,</span> term2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//expr -&gt; expr + term</span>            expr<span class="token punctuation">.</span><span class="token function">setOp</span><span class="token punctuation">(</span>op<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> expr<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>Term</code>的解析思路同上，我以<code>Term -&gt; Factor * Term</code>对<code>Term</code>进行解析。由于乘法计算无需考虑从左到右的顺序，先解析<code>Factor</code>是没问题的。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Term</span> <span class="token function">parseTerm</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">Term</span> term <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Term</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        term<span class="token punctuation">.</span><span class="token function">setFactor</span><span class="token punctuation">(</span><span class="token function">parseFactor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>lexer<span class="token punctuation">.</span><span class="token function">peak</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"*"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            lexer<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            term<span class="token punctuation">.</span><span class="token function">setTerm</span><span class="token punctuation">(</span><span class="token function">parseTerm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> term<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样解析表达式后建立的树是一个类似于二叉树的结构。</p><img src="https://s21.ax1x.com/2024/03/20/pFWTjVP.jpg" alt="" width="70%"><p>关于符号的处理，我在<code>expr -&gt; expr + term</code>这一步记录了符号，此外在每种<code>Factor</code>都添加了<code>sign</code>属性。事实上后者是没有必要的，由于只有<strong>在第一个因子/项之前，可以带一个正号或者负号</strong>，而预处理时我会将积压在每个项前连续的<code>+-</code>号处理掉，所以得到的表达式只需在以下两个位置加入符号判断：1.<code>Factor</code>乘积构成的<code>Term</code>前判断加减 2.至于因子前的符号，根据文法只需在<code>NumFac</code>前判断该数字的正负。</p><h5 id="表达式的化简"><a href="#表达式的化简" class="headerlink" title="表达式的化简"></a>表达式的化简</h5><p>化简是在解析建好的表达式树从底层逐层向上化简。</p><p>引入<code>Mono</code>类，里面只有一个<code>exponent</code>记录<code>x</code>的指数。</p><p>这一步封装我做的不好，当时的我写到这一步已经是周五了，没有引入<code>Poly</code>。我在<code>Expr</code>、<code>Term</code>和各种<code>Factor</code>类中都写了<code>simplify()</code>方法直接返回一个<code>HashMap&lt;BigInteger,Mono&gt;</code>（也就是之后的<code>toPoly</code>），从<code>Factor</code>开始向上化简，最终在main中调用<code>expr.simplify()</code>即可获得最终化简好的HashMap。</p><h4 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h4><img src="https://s21.ax1x.com/2024/03/21/pFfNkdK.jpg" alt="" width="80%"><h4 id="Bug分析"><a href="#Bug分析" class="headerlink" title="Bug分析"></a>Bug分析</h4><p>第一次作业我在预处理时加上了一个去除前导零的操作，事实上不仅<code>BigInteger</code>会自动处理前导零，而且我还把这个函数写错了，结果是数字只要有0就会被我删去一部分，纯纯的多写了个bug。这是一个比较严重的错误了，让我没想到的是强测居然只挂了一个点，真是对这个无比致命的错误来说非常的友好了orz 于是我也在第一次oo作业就获得极致的互hack乱砍体验，我用一些随机生成的数据便收获了约30%的命中率，甚至最后不知道自己在砍谁（bushi</p><p>修复bug就是把我那几行预处理删掉，至今有时想到这个错误还是不知道自己当时是怎么想的。。</p><h3 id="homework2"><a href="#homework2" class="headerlink" title="homework2"></a>homework2</h3><p>第二次作业增加了：1.自定义函数 2.指数函数因子。此外要求实现多层括号嵌套化简，这一点递归下降自然可以解决。</p><h4 id="设计思路-1"><a href="#设计思路-1" class="headerlink" title="设计思路"></a>设计思路</h4><p>多项式<code>Poly</code>类内用<code>ArrayList&lt;Mono&gt;</code>存储各个单项式，符号直接在<code>coe</code>中体现。</p><p>单项式Mono的结构调整如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Mono</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">BigInteger</span> coe<span class="token punctuation">;</span> <span class="token comment">//系数</span>    <span class="token keyword">private</span> <span class="token class-name">BigInteger</span> exponent<span class="token punctuation">;</span> <span class="token comment">//指数</span>    <span class="token keyword">private</span> <span class="token class-name">Poly</span> poly <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Poly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//exp(Poly)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h5><p>$$<br>Define: f(x_1,x_2,x_3)= Expr，将x扩展为x_1，x_2，x_3<br>$$</p><p>$$<br>Call: f(Factor_1, Factor_2, Factor_3)，此处Factor_i只包含x<br>$$</p><p>第二次作业在定义函数的时候保证不出现其他函数，但第三次作业可以在定义中调用之前定义过的函数。我在第二次作业中就实现了这个功能。</p><p>引入<code>FuncFac</code>类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FuncFac</span> <span class="token keyword">implements</span> <span class="token class-name">Factor</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> newFunc<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Expr</span> expr<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>为了保存和解析定义的函数，新建一个<code>Define</code>类来存储和解析自定义函数。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Define</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> defMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//储存读入的函数定义，Map：函数名-&gt;函数表达式，直接存储为String</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">ArrayList</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> paraMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//储存每个函数的形参列表：Map：函数名-&gt;[x1,x2,x3]</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">addFunc</span><span class="token punctuation">(</span><span class="token class-name">String</span> in<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 构造defMap</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">callFunc</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Factor</span><span class="token punctuation">&gt;</span></span> actualPara<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">//返回用实参代替、形参之后的函数调用形式</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我让<code>lexer</code>在处理过程中将整个函数调用<code>f(因子,因子,...)</code>作为一个<code>Token</code>，交给parser中的<code>parseFuncFac</code>函数解析。我们建立<code>ArrayList&lt;Factor&gt; actualPara</code>作为该函数的实参表，只要将括号内的由<code>,</code>隔开的各个因子解析出来放到List中就可以了。考虑到因子内可能依然含有<code>FuncFac</code>，我将括号里各个因子内部的,替换为不会出现的其他符号，再在分别解析因子的时候替换回来。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Factor</span> <span class="token function">parseFuncFac</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Factor</span><span class="token punctuation">&gt;</span></span> actualPara <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/*    * 将因子内的','换成其他字符    */</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> s <span class="token operator">:</span> str<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//将因子s中原本的,恢复</span>        <span class="token comment">//新建一个parser解析各个Factor</span>    <span class="token punctuation">}</span>    <span class="token comment">//解析name=f/g/h</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FuncFac</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> actualPara<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>至此再调用<code>FuncFac</code>的构造函数，解析<code>Define</code>中的<code>callFunc</code>返回的字符串，这样就得到解析好的函数的<code>Expr</code>了。</p><h5 id="表达式因子"><a href="#表达式因子" class="headerlink" title="表达式因子"></a>表达式因子</h5><p>格式是<code>exp(因子)</code>，注意这里的因子为<strong>不带指数的表达式因子</strong>时，该表达式因子两侧必要的一层括号。为此引入<code>ExpoFac</code>类。<code>parser</code>分别解析括号内的因子和括号外的指数即可。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ExpoFac</span> <span class="token keyword">implements</span> <span class="token class-name">Factor</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">Factor</span> factor<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">BigInteger</span> exp<span class="token punctuation">;</span><span class="token comment">//^a</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>作为<code>Factor</code>转化为<code>Poly</code>时，直接将指数<code>a</code>乘进<code>factor</code>。</p><h5 id="关于合并同类项"><a href="#关于合并同类项" class="headerlink" title="关于合并同类项"></a>关于合并同类项</h5><p>在计算的过程中<code>Poly</code>类中有一个<code>addMono</code>的方法，我直接遍历该<code>poly</code>的<code>MonoList</code>是否含有待加入<code>mono</code>的同类项，也就是需要重写<code>mono</code>的<code>equals</code>方法。<br>$$<br>Mono = Coe * x^{a} * exp (Poly)<br>$$</p><p>$$<br>Poly=\sum_{}^{}Mono<br>$$</p><p>要想判断两个<code>mono</code>是否可以合并，只需要比较<code>x</code>的指数<code>a</code>以及<code>e</code>指数上的<code>Poly</code>，这两者均相等就可以合并。作为<code>BigInteger</code>的<code>a</code>直接比较即可，而<code>Poly</code>的相等则需要我们再写相应的<code>equals</code>方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//Mono.java</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">myEqual</span><span class="token punctuation">(</span><span class="token class-name">Mono</span> mono<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//第一次调用Mono的equal，不需要看coe</span>    <span class="token keyword">return</span> exponent<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>mono<span class="token punctuation">.</span>exponent<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>poly<span class="token punctuation">,</span> mono<span class="token punctuation">.</span>poly<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那么<code>Poly</code>相等该如何判断呢？显然所有<code>Mono</code>相等时才能算是相等。这里我遇到了两个问题：</p><ul><li><p>对于<code>Poly</code>的比较我们实际上需要比较两个<code>List</code>中的元素是否完全一样，而<code>MonoList</code>中的<code>Mono</code>由于被add进来时顺序是未知的，那么这两个<code>List</code>该如何比较？</p><ul><li>我们第一次调用<code>mono</code>是否相等时是不需要比较<code>Coe</code>的。然而在比较<code>exp</code>指数上的内容时需要的是<code>mono</code>完全相等，系数也需要加入比较。否则如果按照最开始的<code>mono</code>比较策略就会出现将<code>exp(x)</code>和<code>exp((3*x))</code>合并的情况。</li></ul></li></ul><p>为了解决以上问题，我在<code>Poly</code>中重写了<code>equals</code>方法，返回的是同时比较<code>coe</code>，指数<code>a</code>和<code>poly</code>的结果。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//...</span>        <span class="token keyword">return</span> <span class="token class-name">Mono</span><span class="token punctuation">.</span><span class="token function">myEqual</span><span class="token punctuation">(</span>monos<span class="token punctuation">,</span> poly<span class="token punctuation">.</span>monos<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这需要我在<code>Mono</code>中写的另一个静态的用于比较的方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">myEqual</span><span class="token punctuation">(</span><span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Mono</span><span class="token punctuation">&gt;</span></span> m1<span class="token punctuation">,</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Mono</span><span class="token punctuation">&gt;</span></span> m2<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> m1<span class="token punctuation">.</span><span class="token function">containsAll</span><span class="token punctuation">(</span>m2<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> m2<span class="token punctuation">.</span><span class="token function">containsAll</span><span class="token punctuation">(</span>m1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里的<code>containsAll</code>会调用我重写的<code>Mono</code>的<code>equals</code>比较方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//...</span>        <span class="token class-name">Mono</span> mono <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Mono</span><span class="token punctuation">)</span> o<span class="token punctuation">;</span>        <span class="token keyword">return</span> exponent<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>mono<span class="token punctuation">.</span>exponent<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>coe<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>mono<span class="token punctuation">.</span>coe<span class="token punctuation">)</span>                <span class="token operator">&amp;&amp;</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>poly<span class="token punctuation">,</span> mono<span class="token punctuation">.</span>poly<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//此后调用的都是Poly的equals方法，需要比较系数</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里还有两个细节要注意：</p><p>1.在比较<code>Poly</code>之前还需要<code>removeZero()</code>操作，以除去<code>coe</code>为0的项。</p><p>2.关于深克隆：需要在<code>addMono</code>这个函数中深克隆。如果不进行深克隆，会出现把<code>Mono</code>直接放到<code>poly</code>相乘的结果中，之后<code>setCoe</code>的时候会由于指针指向同一个<code>Mono</code>而导致本来想修改的是答案<code>Poly</code>的系数，但顺便也把原先作为乘数<code>Poly</code>中的<code>Mono</code>也改了。我和这个问题从早上决斗到下午才改好。</p><p>结合这样一个例子就可以说明：<code>(exp(x)+1)^2</code>。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//Poly.java</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addMono</span><span class="token punctuation">(</span><span class="token class-name">Mono</span> mono<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">CloneNotSupportedException</span> <span class="token punctuation">{</span>    <span class="token comment">//计算Poly+Mono</span>    <span class="token class-name">Mono</span> monoClone <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Mono</span><span class="token punctuation">)</span> mono<span class="token punctuation">.</span><span class="token function">myClone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">if</span><span class="token punctuation">(</span>可以合并同类项<span class="token punctuation">)</span><span class="token punctuation">{</span>            m<span class="token punctuation">.</span><span class="token function">setCoe</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">getCoe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>mono<span class="token punctuation">.</span><span class="token function">getCoe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>monos<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>monoClone<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="结果输出"><a href="#结果输出" class="headerlink" title="结果输出"></a>结果输出</h5><p>我在<code>Mono</code>和<code>Poly</code>类中分别写了<code>toString</code>方法用于输出。</p><p>需要注意的是在<code>toString</code>的规范：只进行转换为字符串的操作。<strong>不要在<code>toString</code>里做一些改变对象内容的事请</strong>。如果在该函数中改变了对象中的内容可能会导致调试的时候结果正确而最后输出错误的情况。调试的时候对于对象会自动调用<code>toString</code>函数，如果没有写<code>toString</code>就会输出<code>@(toHex)HashCode</code>。</p><img src="https://s21.ax1x.com/2024/03/21/pFfGox1.png" alt="" width="90%"><h5 id="UML类图-1"><a href="#UML类图-1" class="headerlink" title="UML类图"></a>UML类图</h5><img src="https://s21.ax1x.com/2024/03/21/pFfNAIO.jpg" alt="" width="100%"><h3 id="homework3"><a href="#homework3" class="headerlink" title="homework3"></a>homework3</h3><h5 id="设计思路-2"><a href="#设计思路-2" class="headerlink" title="设计思路"></a>设计思路</h5><p>第三次作业增加了求导因子。第三次作业在我们之前的递归下降架构上很快就能写好。为此我加入<code>DiffFac</code>类。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DiffFac</span> <span class="token keyword">implements</span> <span class="token class-name">Factor</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">Expr</span> expr<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>先把每个因子的<code>toDiff()</code>写了，全部返回<code>Poly</code>。至于求导因子的嵌套需要如下处理。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token class-name">Poly</span> <span class="token function">toDiffPoly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">CloneNotSupportedException</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> expr<span class="token punctuation">.</span><span class="token function">toDiffPoly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toDiffPoly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>所以还要对<code>Mono</code>和<code>Poly</code>的求导，求导的过程也很直观。这里只要注意一下指数为0的时候返回<code>0</code>就可以了。</p><p>$$<br>Mono’ = (Coe*a) * x^{a-1} * exp (Poly)+Coe*x^{a}*exp(Poly)*Poly’<br>$$</p><p>$$<br>Poly’=\sum_{}^{}mono’<br>$$</p><h5 id="UML类图-2"><a href="#UML类图-2" class="headerlink" title="UML类图"></a>UML类图</h5><img src="https://s21.ax1x.com/2024/03/21/pFft829.png" alt="" width="100%"><h5 id="Bug分析-1"><a href="#Bug分析-1" class="headerlink" title="Bug分析"></a>Bug分析</h5><p>所幸后两次作业强测没有出现Bug，后两次发现的别人的Bug有：无法处理类似于<code>f((x)^2)</code>后面的指数，还有指数没改为<code>BigInteger</code>的，但由于cost我无法hack，以及一些tle。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><table><thead><tr><th>method</th><th>CogC</th><th align="left">ev(G)</th><th>iv(G)</th><th>v(G)</th></tr></thead><tbody><tr><td>Change.dealComa(String)</td><td>19.0</td><td align="left">1.0</td><td>6.0</td><td>10.0</td></tr><tr><td>Define.callFunc(String, ArrayList)</td><td>18.0</td><td align="left">3.0</td><td>7.0</td><td>13.0</td></tr><tr><td>Lexer.next()</td><td>8.0</td><td align="left">2.0</td><td>6.0</td><td>9.0</td></tr><tr><td>Poly.isSimple()</td><td>8.0</td><td align="left">4.0</td><td>6.0</td><td>6.0</td></tr><tr><td>Mono.toString()</td><td>7.0</td><td align="left">2.0</td><td>4.0</td><td>6.0</td></tr><tr><td>Parser.parseFactor()</td><td>7.0</td><td align="left">6.0</td><td>8.0</td><td>8.0</td></tr><tr><td>Lexer.getFunc()</td><td>6.0</td><td align="left">1.0</td><td>3.0</td><td>5.0</td></tr><tr><td>Parser.parseExpr()</td><td>6.0</td><td align="left">1.0</td><td>4.0</td><td>5.0</td></tr><tr><td>Term.toDiffPoly()</td><td>6.0</td><td align="left">1.0</td><td>4.0</td><td>4.0</td></tr><tr><td>Define.addFunc(String)</td><td>4.0</td><td align="left">1.0</td><td>3.0</td><td>5.0</td></tr><tr><td>Poly.addPoly(Poly, int)</td><td>4.0</td><td align="left">1.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Mono.equals(Object)</td><td>3.0</td><td align="left">3.0</td><td>3.0</td><td>5.0</td></tr><tr><td>Parser.parseNumFac()</td><td>3.0</td><td align="left">1.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Poly.addMono(Mono)</td><td>3.0</td><td align="left">3.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Poly.changeOrder()</td><td>3.0</td><td align="left">3.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Poly.mulPoly(Poly, Poly)</td><td>3.0</td><td align="left">1.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Poly.removeZero()</td><td>3.0</td><td align="left">1.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Poly.toString()</td><td>3.0</td><td align="left">2.0</td><td>3.0</td><td>4.0</td></tr><tr><td>ExprFac.toDiffPoly()</td><td>2.0</td><td align="left">2.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Lexer.getNumber()</td><td>2.0</td><td align="left">1.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Mono.toDiffPoly()</td><td>2.0</td><td align="left">1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Poly.addPolyNew(Poly, Poly)</td><td>2.0</td><td align="left">1.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Poly.equals(Object)</td><td>2.0</td><td align="left">3.0</td><td>1.0</td><td>3.0</td></tr><tr><td>Poly.powPoly(Poly, BigInteger)</td><td>2.0</td><td align="left">2.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Term.toPoly()</td><td>2.0</td><td align="left">2.0</td><td>2.0</td><td>3.0</td></tr><tr><td>VarFac.toDiffPoly()</td><td>2.0</td><td align="left">1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>ExpoFac.toPoly()</td><td>1.0</td><td align="left">2.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Expr.toDiffPoly()</td><td>1.0</td><td align="left">1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Expr.toPoly()</td><td>1.0</td><td align="left">1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Main.main(String[])</td><td>1.0</td><td align="left">1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Mono.isOnlyE()</td><td>1.0</td><td align="left">1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Mono.isOnlyX()</td><td>1.0</td><td align="left">1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Mono.myEqual(ArrayList, ArrayList)</td><td>1.0</td><td align="left">1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Mono.myEqual(Mono)</td><td>1.0</td><td align="left">1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Parser.parseExponent()</td><td>1.0</td><td align="left">1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Parser.parseFuncFac()</td><td>1.0</td><td align="left">1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Parser.parseTerm(int)</td><td>1.0</td><td align="left">1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Poly.myClone()</td><td>1.0</td><td align="left">1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Poly.toDiffPoly()</td><td>1.0</td><td align="left">1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Change.process(String)</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>DiffFac.DiffFac(Expr)</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>DiffFac.toDiffPoly()</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>DiffFac.toPoly()</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>ExpoFac.ExpoFac(Factor, BigInteger)</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>ExpoFac.toDiffPoly()</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Expr.Expr()</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Expr.addTerm(Term)</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>ExprFac.ExprFac(Expr, BigInteger)</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>ExprFac.toPoly()</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>FuncFac.FuncFac(String, ArrayList)</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>FuncFac.toDiffPoly()</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>FuncFac.toPoly()</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Lexer.Lexer(String)</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Lexer.peak()</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Mono.Mono(BigInteger, BigInteger)</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Mono.Mono(BigInteger, BigInteger, Poly)</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Mono.Mono(Poly)</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Mono.getCoe()</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Mono.getExponent()</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Mono.getPoly()</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Mono.mulMono(Mono, Mono)</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Mono.myClone()</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Mono.setCoe(BigInteger)</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Mono.setExponent(BigInteger)</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>NumFac.NumFac(BigInteger)</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>NumFac.toDiffPoly()</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>NumFac.toPoly()</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Parser.Parser(Lexer)</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Parser.parseDiffFac()</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Parser.parseExpoFac()</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Parser.parseExprFac()</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Parser.parseVarFac()</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Poly.Poly()</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Term.Term()</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Term.addFactor(Factor)</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Term.getSign()</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Term.setSign(int)</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>VarFac.VarFac(BigInteger)</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>VarFac.toPoly()</td><td>0.0</td><td align="left">1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Total</td><td>143.0</td><td align="left">104.0</td><td>159.0</td><td>185.0</td></tr><tr><td>Average</td><td>1.810</td><td align="left">1.316</td><td>2.013</td><td>2.342</td></tr></tbody></table><p>我在处理函数逗号的<code>dealComa</code>方法中引入了较为复杂的循环分支以支持处理嵌套函数，其实这里的嵌套交给parser也可以完成。还有就是<code>Define</code>中<code>callFunc</code>中我分别判断是<code>x/y/z</code>使得复杂度较高。我在<code>Mono</code>的<code>toString</code>中做了一些简化，同样需要各种判断。但除了<code>Lexer</code>和<code>ParseFactor</code>需要解析各种Token和因子，<code>if-else</code>难免较多之外，前面提到的还是可以进一步优化解耦使得框架更为清晰。</p><h3 id="总结与心得"><a href="#总结与心得" class="headerlink" title="总结与心得"></a>总结与心得</h3><ul><li><p>在优化方面我则基本没做，每次做完作业就都剩下<code>TODO</code>，甚至将正项提前这一基本的优化我也是第二次才做。</p></li><li><p>本单元第一次作业由于我封装的不够彻底，直到第二次作业才开始引入<code>Poly</code>类。好在思路还是统一的，并没有进行大规模的修改。</p></li></ul><p>本单元的递归下降方法要求我们写代码时头脑非常清晰，需要明确每一层递归到底发生了什么。我对面向对象思维的理解也更为深刻，在思考架构的时候尽量降低代码间的耦合度。此外我在判断对象相等时所用的<code>equals</code>和<code>HashCode</code>相关知识有了更进一步的了解，其中有很多更深刻的知识有待学习，总而言之还是很有收获的一次作业。</p>]]></content>
      
      
      
        <tags>
            
            <tag> OO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OO_Unit2</title>
      <link href="/2024/03/20/oo-unit2/"/>
      <url>/2024/03/20/oo-unit2/</url>
      
        <content type="html"><![CDATA[<h1 id="OO-Unit2-电梯调度"><a href="#OO-Unit2-电梯调度" class="headerlink" title="OO_Unit2: 电梯调度"></a>OO_Unit2: 电梯调度</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>OO第二单元主要是对多部电梯的运行进行模拟，要求我们使用多线程编程，难点在于理解线程交互过程，需要通过对合适的共享对象加锁来解决线程安全问题。多个线程的同步进行使得需要分析的情况变得复杂多变，而且错误是概率出现的，增加了作业完成和debug难度。随着作业结构越发复杂，更需要理清电梯调度的时序等多种细节，总之要清楚某些时刻电梯在干什么事儿才能尽量避免bug的出现。</p><h3 id="hw5"><a href="#hw5" class="headerlink" title="hw5"></a>hw5</h3><p>电梯第一次作业需要管理6部电梯，题目已经给出每个<code>Request</code>需要乘坐的电梯ID。本次作业我对多线程设计有了基本的概念，对synchronize同步块和锁的设置有了初步体会。此外我也意识到解耦的重要性，运用好面向对象思想，使用好的架构和明确的分工会让整个作业的构建和调试难度大大降低，同时也会让自己的思路更加清晰明确。</p><h4 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h4><h5 id="生产者-消费者模型"><a href="#生产者-消费者模型" class="headerlink" title="生产者-消费者模型"></a>生产者-消费者模型</h5><p>本次作业首先要解决的是如何将乘客请求正确分配给电梯。</p><p>我用<code>RequestTable</code>类来存储请求。该类实例化为以下两种请求队列：</p><ul><li><code>allRequest</code>：用于存放来自输入所有的请求。</li><li><code>ElevatorReqTable</code>：每个电梯都会实例化一个该电梯专有的请求，用于存放该电梯要处理的请求队列。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RequestTable</span> <span class="token punctuation">{</span>    <span class="token comment">//&lt;楼层序号，出发地在该楼层的请求&gt;</span>    <span class="token keyword">private</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">ArrayList</span><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> requestMap<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> isEnd<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我使用生产者-消费者模型，其中生产者是输入线程类<code>Input</code>，该类拥有实例<code>allRequest</code>，每当有请求输入进来就新建一个<code>Person</code>加入到<code>allRequest</code>中；消费者是<code>Elevator</code>类，每个实例化的电梯都有自己的<code>eleReqTable</code>作为待处理请求。此外输入线程类还负责在输入结束后将总请求队列的<code>isEnd</code>置1代表不再会有新请求，输入结束。</p><p><code>Manager</code>类在这里发挥分配请求的作用，同时拥有以上两种<code>RequestTable</code>。主要负责：</p><ul><li><p>如果<code>allRequest</code>中还有请求，则将其pop出来，按照所需乘坐的电梯id交给相应的电梯自己的<code>eleReqTable</code>。</p></li><li><p>如果<code>allRequest</code>中没有请求了而且<code>isEnd</code>为1，则将电梯的子table也设为结束结束本进程。</p></li></ul><p>至此电梯类通过成员变量<code>eleReqTable</code>获得了自己需要处理的请求。这时电梯需要根据自身状态以及请求决定其行为。</p><h5 id="电梯调度"><a href="#电梯调度" class="headerlink" title="电梯调度"></a>电梯调度</h5><p>我的电梯类有如下成员变量：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Elevator</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">,</span> <span class="token class-name">RequestTable</span> reqTable<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>reqTable <span class="token operator">=</span> reqTable<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>curFloor <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>curNum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//电梯内总人数</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>direction <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>destMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// HashMap&lt;Integer, ArrayList&lt;Person&gt;&gt;，当前在电梯内部的Person，按照目的地层数划分</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>strategy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Strategy</span><span class="token punctuation">(</span>reqTable<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>电梯会有如下的行为：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">move</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//电梯沿着原方向移动一层，改变curFloor即可</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token class-name">OpenAndClose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//电梯开门，人员先下后上getOut(),getIn()，关门</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//电梯转向，direction取反</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">getOut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//目的地为这一层的人全部出去，直接将destMap整个键删去</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">getIn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//从电梯请求队列移除，delRequest返回需要进入电梯的Person列表</span>        <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">&gt;</span></span> inPersonList <span class="token operator">=</span> reqTable<span class="token punctuation">.</span><span class="token function">delRequest</span><span class="token punctuation">(</span>curFloor<span class="token punctuation">,</span> <span class="token number">6</span> <span class="token operator">-</span> curNum<span class="token punctuation">,</span> direction<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Person</span> per <span class="token operator">:</span> inPersonList<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">//加入电梯的destMap</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>电梯该如何决定进行何种行为，需要引入<code>Strategy</code>策略类，该类中的一个<code>getAdvice</code>函数会将具体策略<code>(OPEN, MOVE, REVERSE, WAIT, END)</code>交给电梯。所以策略类需要获取当前电梯的请求队列，在之前电梯构造创建自己的<code>Strategy</code>时已经作为<code>Strategy</code>自己的成员变量传入了；至于当前电梯的状态则会在调用<code>getAdvice</code>函数时作为参数传入，具体来说就是：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Advice</span> <span class="token function">getAdvice</span><span class="token punctuation">(</span><span class="token keyword">int</span> curFloor<span class="token punctuation">,</span> <span class="token keyword">int</span> curNum<span class="token punctuation">,</span> <span class="token keyword">int</span> dir<span class="token punctuation">,</span>                       <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">ArrayList</span><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> destMap<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>接下来执行具体的电梯调度策略就行了，这里我选择了简单易行的LOOK算法。</p><h5 id="锁的设置"><a href="#锁的设置" class="headerlink" title="锁的设置"></a>锁的设置</h5><p>由于<code>RequestTable</code>类在多个线程中使用，因此对这个类的任何读写操作我都加了锁。此外，由于对<code>RequestTable</code>的任何读写操作我都在该类内完成，我的所有<code>synchronized</code>块全部而且仅出现在请求类中。具体来说，读写<code>RequestTable</code>类主要分为以下几种情况：</p><ul><li><code>addPerson</code>: 两类请求都要用，用于向请求队列中加入新的请求<code>(Person)</code>。</li><li>由主请求队列<code>allRequest</code>调用的：<ul><li><code>popPerson</code>: 从主请求中pop出一个Person用于分配给电梯子请求。</li></ul></li><li>由电梯的分请求队列<code>eleReqTable</code>调用的：<ul><li><code>delRequest</code>: 用于从电梯子请求队列中移除一些符合要求的请求，即代表这些Person进入电梯。</li></ul></li><li>上面的方法全都要加锁，此外还有一些判断Map是否为空，读和写<code>isEnd</code>和其他一些队列情况的方法，也需要上锁。这样我的读写全部封装在类内进行，外面只需要调用这些函数即可。</li></ul><p>至于<code>notifyAll</code>，当一个线程调用了某个对象的 <code>notifyAll()</code> 方法时，该对象上所有调用了 <code>wait()</code> 方法而被挂起的线程都将被唤醒，然后它们会竞争对象上的锁。考虑我整个程序中的两个需要<code>wait</code>的地方：</p><ul><li>主请求队列在<code>popPerson</code>时主请求队列空了，但输入还没有结束，也就是需要等待外部输入新的请求。在这种情况下：①若外部输入了新的请求，则会通过<code>addPerson</code>函数进行，所以<code>addPerson</code>我增加了<code>notifyAll()</code> 来唤醒。②如果不会再有新的输入，就会执行<code>setEnd</code>，所以在<code>setEnd</code>也增加<code>notifyAll()</code>。</li><li>在每个电梯的分请求队列中同理，不过主请求等待的是<code>Input</code>传入，分请求等待<code>Manager</code>的分配。</li></ul><p>所以我只在上述两个函数里进行了<code>notifyAll()</code>。</p><h4 id="Bug分析"><a href="#Bug分析" class="headerlink" title="Bug分析"></a>Bug分析</h4><p>强测和互测没有出现bug，需要注意的是：</p><ul><li>超载判断：我一开始在<code>Strategy</code>内判断需要是否需要开门的时候想着先下后上，因此没有在<code>getAdvice</code>中判断是否超载，只在电梯内执行<code>getIn</code>的时候进行了判断。但这造成了电梯一直在某层开关门停不下来的情况。原因是：<code>openToOut(...) | openToIn(...)</code>这一<code>|</code>关系代表着，在没有人在这一层要下电梯的时候才会进行判断有没有人要上电梯的操作，既然没人要下电梯就必然要判断是否超载，因为如果在这里不判断的话返回的就会是开门操作，开门又发现人进不去，于是就造成了上述的死循环。在<code>openToIn</code>中判断人数是否超载即可。</li><li>由于会对请求队列的<code>Map</code>进行是否为空的判断，在进行<code>Map</code>的删除时，我都进行了<strong>这个键对应的List是否为空</strong>的判断，如果为空就直接把这个键删除，这样保证在没有请求（请求被删干净）之后<code>Map</code>也是空的。</li></ul><h4 id="UML类图-amp-时序图"><a href="#UML类图-amp-时序图" class="headerlink" title="UML类图&amp;时序图"></a>UML类图&amp;时序图</h4><img src="https://s21.ax1x.com/2024/03/29/pFobQ81.png" width="100%"><h3 id="hw6"><a href="#hw6" class="headerlink" title="hw6"></a>hw6</h3><h4 id="设计思路-1"><a href="#设计思路-1" class="headerlink" title="设计思路"></a>设计思路</h4><p>第二次迭代新增了电梯<code>RESET</code>功能，电梯接收到重置请求后尽快停下，将所有人放出后修改相关属性，再投入使用，此外还需要自行设计电梯的分配。为了杜绝自由竞争的使用，需要电梯接到请求后输出<code>RECEIVE</code>后才能进行合法移动。</p><h5 id="处理RESET请求"><a href="#处理RESET请求" class="headerlink" title="处理RESET请求"></a>处理RESET请求</h5><p>首先对于<code>RESET</code>的处理，调度器<code>Manager</code>类新增方法<code>resetElevator</code>，该方法修改需重置电梯对应<code>RequestTable</code>的<code>resetRequest</code>属性，使其从原先的<code>null</code>变成相应的重置请求。那么电梯便可以在<code>getAdvice</code>时获得<code>RESET</code>的建议，从而执行重置请求。注意请求表类中的<code>setResetReq</code>方法需要<code>notifyAll</code>。此外结束条件需要加上一条：所有电梯都不在reset才能结束。</p><p>需要注意的是电梯的<code>reset</code>执行顺序。如果先把<code>Person</code>扔回总表再输出，可能出现同一个人被<code>RECEIVE</code>两次的情况，所以要先立即输出<code>RESET_BEGIN</code>。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">allOut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//电梯内的乘客清空，扔回电梯请求队列</span>    <span class="token class-name">TimableOutput</span><span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"RESET_BEGIN-"</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">&gt;</span></span> personList <span class="token operator">=</span> reqTable<span class="token punctuation">.</span><span class="token function">delAllRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    allRequest<span class="token punctuation">.</span><span class="token function">getAllRequest</span><span class="token punctuation">(</span>personList<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//执行重置，sleep 1.2s</span>        <span class="token class-name">TimableOutput</span><span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"RESET_END-"</span> <span class="token operator">+</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>    reqTable<span class="token punctuation">.</span><span class="token function">setResetReq</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="电梯调度-1"><a href="#电梯调度-1" class="headerlink" title="电梯调度"></a>电梯调度</h5><p><code>import java.util.Random;</code></p><p>为了保证正确性我直接采用随机策略。在随机到一个电梯之后只要不在reset就返回其id，如果恰好所有电梯都在reset状态就睡一会儿。这个策略使我在互测从上午10点被hack到第二天下午5点钟，原因在于当只剩下一部电梯可运行时，我的调度策略会把所有请求全部给剩下一部电梯，导致<code>rtle</code>。修改也很简单，就是判断一下仅当<code>≥3</code>部电梯在运行时才进行任务分配。</p><h4 id="Bug分析-1"><a href="#Bug分析-1" class="headerlink" title="Bug分析"></a>Bug分析</h4><p>本次作业强测由于采取了随机策略分数不高但没有出现问题。互测则出现了上述未限流导致的一个问题。</p><p>此外，课下我在交中测时发现自己出现了近10s的cpu时间<del>但不知道为什么一直没ctle</del>，于是我开始寻找轮询的可能性。在使用idea自带的Profiler运行时我发现我的cpu浪费了大量资源在<code>Manager</code>的<code>run</code>方法中。打印输出发现在这个循环内出现了轮询的情况。当电梯输入全部结束且主请求表为空时，就会进入判断是否全都不在reset状态。如果得到了<code>false</code>，就会迅速无限重复上述过程造成了轮询，解决方法就是加一个else让程序睡过去。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>allRequest<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> allRequest<span class="token punctuation">.</span><span class="token function">isEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">allNotReset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">//...</span>                <span class="token comment">//输入结束，将所有子table设为结束，本进程结束</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token class-name">Person</span> per <span class="token operator">=</span> allRequest<span class="token punctuation">.</span><span class="token function">popPerson</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>per <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//将Person分配给电梯</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="UML类图-amp-时序图-1"><a href="#UML类图-amp-时序图-1" class="headerlink" title="UML类图&amp;时序图"></a>UML类图&amp;时序图</h4><img src="https://s21.ax1x.com/2024/04/15/pFvRJYQ.png"><h3 id="hw7"><a href="#hw7" class="headerlink" title="hw7"></a>hw7</h3><p>第7次作业增加了双轿厢电梯的重置请求，复杂度进一步提高。</p><h4 id="设计思路-2"><a href="#设计思路-2" class="headerlink" title="设计思路"></a>设计思路</h4><p>本次作业我将<code>Manager</code>改为单例模式，这样做的好处是其他类需要使用总表<code>allRequest</code>的时候可以通过<code>Manager</code>直接获取，实现起来更加清晰和安全。此外前两次作业我在main函数让各个线程分别开始跑，本次作业改为层次化的<code>start</code>，使得程序层次更清晰。</p><p>我在<code>Manager</code>类中实现两类电梯的创建和管理。首先是<code>Manager</code>的构造方法负责创建总表，6个电梯的分请求表对象，以及6部电梯的启动。实际上我们在调度器<code>Manager</code>中并非直接管理电梯，甚至不需要专门设置管理<code>Elevator</code>电梯类的容器——我们实际上都是通过操作电梯所对应的<code>requestTable</code>来进行管理的。我先前使用<code>List</code>管理6个请求表，但考虑到之后有双轿厢电梯和普通电梯同时运行，本次作业我简单地使用<code>HashMap&lt;Integer, RequestTable&gt; requestMap</code>统一管理两种电梯。具体映射方法如下。初始就只需新建key为1-6的电梯请求表。查看给定<code>id</code>的电梯，如果是普通电梯就会存在<code>key=id</code>， 如果是双轿电梯则存在<code>key=id + 6</code>和<code>key=id + 12</code>。</p><table><thead><tr><th align="center"><code>Key</code></th><th align="center"><code>Value</code></th></tr></thead><tbody><tr><td align="center">1-6</td><td align="center">普通电梯1-6的请求表</td></tr><tr><td align="center">7-12</td><td align="center">双轿厢电梯A1-A6的请求表</td></tr><tr><td align="center">13-18</td><td align="center">双轿厢电梯B1-B6的请求表</td></tr></tbody></table><h5 id="双轿厢电梯RESET"><a href="#双轿厢电梯RESET" class="headerlink" title="双轿厢电梯RESET"></a>双轿厢电梯RESET</h5><p>这类请求相当于需要把原来的电梯直接弃用，再new两个新电梯。关于请求的设置思路与<code>NormalReset</code>相同，依然是在电梯相应的<code>requestTable</code>里修改属性，然后电梯通过<code>Advice</code>得到。不同的是原先的电梯线程执行完<code>dcReset</code>之后就可以光荣下岗了，我的实现中直接将其<code>break</code>掉，线程结束。</p><p>至于电梯的<code>dcReset</code>函数，同样需要将电梯里的人全都赶出去扔回总表，打印等流程，然后我令其调用<code>Manager</code>创建双轿厢电梯的方法，然后该电梯圆满完成任务。</p><p><code>createLine</code>新建双轿厢电梯，引入<code>Line</code>类实现双轿厢电梯的管理，在其中设置新电梯的相关属性并使其<code>start</code>即可。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">createLine</span><span class="token punctuation">(</span><span class="token class-name">DoubleCarResetRequest</span> dcReq<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//新创建 requestTableA，requestTableB</span>requestMap<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>eleId<span class="token punctuation">)</span><span class="token punctuation">;</span>    requestMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>eleId <span class="token operator">+</span> <span class="token number">6</span><span class="token punctuation">,</span> requestTableA<span class="token punctuation">)</span><span class="token punctuation">;</span>    requestMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>eleId <span class="token operator">+</span> <span class="token number">12</span><span class="token punctuation">,</span> requestTableB<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//...</span>   <span class="token comment">//新建Line</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="电梯防撞"><a href="#电梯防撞" class="headerlink" title="电梯防撞"></a>电梯防撞</h5><p>另一个重点就是如何避免电梯在A，B共享的停靠层相撞。引入<code>Floor</code>类作为一对双轿电梯的共享对象，在创建<code>Line</code>对象的时候将其作为电梯的属性分配给两个新电梯。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Floor</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> isOccupied<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">RequestTable</span> reqTableA<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">RequestTable</span> reqTableB<span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当双轿厢类型电梯在运行<code>move()</code>的时候需要特判一下：如果电梯下一步会<code>move</code>到换乘层，就需要判断<code>Floor</code>是否被占用。同样地使用<code>RequestTable</code>作为信息传递的媒介,新增<code>isNeedAway</code>属性即可。同样需要判断，如果双轿厢电梯离开了换乘层将<code>occupied</code>标志解除占用。</p><p>另一个重要的问题是如果电梯已经占有<code>floor</code>，移动到了换乘层，需要额外再获取一下Advice，如果这时候得到的是<code>OPEN</code>，就需要开门。</p><p>新增一个<code>AWAY</code>的<code>Advice</code>，如果这时有电梯在换乘层且挡道了就让其避开。最后，如果一个双轿厢电梯在得到结束的<code>Advice</code>时，如果还停在换乘层，同样让其<code>AWAY</code>以避免出现因电梯A停止运行而B电梯无法让A再避开的情况。</p><p><code>ADVICE</code>的优先级问题：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Strategy</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token class-name">Advice</span> <span class="token function">getAdvice</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>reqTable<span class="token punctuation">.</span><span class="token function">getNormalResetRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token class-name">Advice</span><span class="token punctuation">.</span><span class="token constant">RESET</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>reqTable<span class="token punctuation">.</span><span class="token function">getDcResetReq</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token class-name">Advice</span><span class="token punctuation">.</span><span class="token constant">DCRESET</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">openToOut</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">openToIn</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token class-name">OpenToTransfer</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token class-name">Advice</span><span class="token punctuation">.</span><span class="token constant">OPEN</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>curFloor <span class="token operator">==</span> transFloor <span class="token operator">&amp;&amp;</span> reqTable<span class="token punctuation">.</span><span class="token function">isNeedAway</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token class-name">Advice</span><span class="token punctuation">.</span><span class="token constant">AWAY</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>curNum <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token comment">//look算法...</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这一部分电梯的运行以及<code>Advice</code>的获取有很多细节要注意，一旦出现一些小问题就很容易出现电梯遁地，升天等停不下来的情况，不过相比死锁和轮询还是友好的。</p><p>至于互斥的实现，一开始的时候我使用了一种类似于下述代码的方法，先检查是否有占用标记，若没被占用留下标志。后来看到osppt明确说明了这样实现的问题，即：<code>Occupied</code>的读和写会出现一个空档，无法真正实现互斥。当时已经是周五晚，于是也直接通过<code>sleep</code>解决。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token class-name">Occupied</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token class-name">Occupied</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token comment">//访问Floor</span><span class="token class-name">Occupied</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="双轿厢电梯乘客换乘"><a href="#双轿厢电梯乘客换乘" class="headerlink" title="双轿厢电梯乘客换乘"></a>双轿厢电梯乘客换乘</h5><p>由于双轿厢电梯的出现，有些乘客一次分配是无法被送达目的地的。这时我会把人扔回总表。这时总表结束条件判断还需要新增一个条件，那就是所有需要换乘的乘客请求都完成。为此为<code>Person</code>新建<code>needTransfer</code>属性。在调度器中引入记录需要换乘的乘客数量<code>transferNum</code>。每当把一个<code>personRequest</code>分配给双轿电梯时，就需要判断一下这个A/B电梯是否能一趟把乘客送达。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">int</span> <span class="token function">getEleId</span><span class="token punctuation">(</span><span class="token class-name">Person</span> person<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> id <span class="token operator">=</span> random<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>requestMap<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//分配给单轿厢</span>            <span class="token comment">//... return id</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">//双轿电梯</span>            <span class="token keyword">int</span> tmp<span class="token punctuation">;</span><span class="token comment">//用于决定给A/B梯</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isChange</span><span class="token punctuation">(</span>from<span class="token punctuation">,</span> <span class="token keyword">to</span><span class="token punctuation">,</span> transFloor<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//不需要换乘</span>                <span class="token comment">//...确定tmp</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                transferNum<span class="token operator">++</span><span class="token punctuation">;</span>                person<span class="token punctuation">.</span><span class="token function">setNeedTransfer</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//该人分配给了双轿电梯，且需要换乘</span>                <span class="token comment">//...确定tmp</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> tmp <span class="token operator">*</span> <span class="token number">6</span> <span class="token operator">+</span> id<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在<code>Elevator</code>开关门的时候也需要更改：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token class-name">OpenAndClose</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//...</span>    <span class="token function">getOut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> curFloor <span class="token operator">==</span> transferFloor<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">transfer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token class-name">Advice</span> adv <span class="token operator">=</span> strategy<span class="token punctuation">.</span><span class="token function">getAdvice</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>adv <span class="token operator">==</span> <span class="token class-name">Advice</span><span class="token punctuation">.</span><span class="token constant">REVERSE</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token function">getIn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//...</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//将电梯里所有需要换乘的人放出去, 扔回总表</span>        <span class="token comment">//...遍历电梯内剩下的乘客</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>per<span class="token punctuation">.</span><span class="token function">isNeedTransfer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">//开门放人...</span>            per<span class="token punctuation">.</span><span class="token function">setFromFloor</span><span class="token punctuation">(</span>transferFloor<span class="token punctuation">)</span><span class="token punctuation">;</span>            per<span class="token punctuation">.</span><span class="token function">setNeedTransfer</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">Manager</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getAllRequestTable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addPerson</span><span class="token punctuation">(</span>per<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">Manager</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">decTransferNum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            listIter<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//把这个人删去</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>换乘函数<code>transfer</code>负责将电梯里所有需要换乘的人放出去, 扔回总表。这时，在我的实现下，最好先执行完<code>getOut()</code>，将所有本来就在该换乘层到达目的地的乘客送出去。这时双轿电梯剩下的乘客应该只剩下因被迫换乘而下电梯的乘客。依然要注意<code>Map</code>在对应键为空的时候要维护，将整个键也删除。</p><p>于是我在结束条件判断的时候，总共需要判断：①总表输入结束且总表为空 ②普通电梯不能在执行任意一种reset，且所有分请求表为空 ③需要换乘的乘客都送完了，<code>transferNum != 0</code>。这样结束条件的问题也解决了。</p><h4 id="Bug分析-2"><a href="#Bug分析-2" class="headerlink" title="Bug分析"></a>Bug分析</h4><p>本次作业强测和互测都没有出现bug。一些细节是：<br>我在对<code>RequestTable</code>的属性<code>(NormalResetReq，dcResetRequest，needAway)</code>进行<code>set</code>的时候都进行了<code>notifyAll</code>。对于第二次作业会被hack的数据，我继续采用sleep，也就是如果随机到的电梯刚好在reset就睡，然后获取新的随机id，随到一个能用的电梯为止。这样既保证了很难被hack，又保证了这样一个最基本的策略分数注定很低。</p><h4 id="UML类图-amp-时序图-2"><a href="#UML类图-amp-时序图-2" class="headerlink" title="UML类图&amp;时序图"></a>UML类图&amp;时序图</h4><img src="https://s21.ax1x.com/2024/04/15/pFvhq1J.png"><h3 id="总结与心得"><a href="#总结与心得" class="headerlink" title="总结与心得"></a>总结与心得</h3><img src="https://s21.ax1x.com/2024/04/17/pFxI5aq.png" alt="final"><p>本单元让我对多线程有了深刻的体会，同时我也加强了合理进行规划设计，降低耦合，让线程间各司其职的意识，加深了我对面向对象思想的理解。我也又一次意识到保持代码的简洁和结构的清晰是多么重要。</p><p>传说中的电梯单元总算是快结束了，总体来看我三次作业的完成和debug过程果然是困难重重。之前我习惯性打断点调试的方法不再适用，我非常清晰地记得第三次迭代的周四周五的两点钟依然在宿舍debug，<del>看到错误的输出仿佛能听到我电梯相撞的声音。。</del>虽然最后没有出现很大的问题，但不足之处也很明显，就是为了保证最基本的正确性可以说是一点优化也没做了，几乎全是睡过去的。希望以后能在优化方面做得更好吧orz</p>]]></content>
      
      
      
        <tags>
            
            <tag> OO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OS_lab1</title>
      <link href="/2024/03/14/lab1-shi-yan-bao-gao/"/>
      <url>/2024/03/14/lab1-shi-yan-bao-gao/</url>
      
        <content type="html"><![CDATA[<h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><h5 id="Thinking-1-1"><a href="#Thinking-1-1" class="headerlink" title="Thinking 1.1"></a>Thinking 1.1</h5><p><strong>Q:</strong> 请阅读 附录中的编译链接详解，尝试分别使用实验环境中的原生x86工具链（gcc、ld、readelf、objdump 等）和 MIPS 交叉编译工具链（带有 mips-linux-gnu-前缀），重复其中的编译和解析过程，观察相应的结果，并解释其中向 objdump 传入的参数的含义。</p><p><strong>A:</strong> 执行<code>gcc -E hello.c</code>只进行预处理不编译：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">//...extern int printf (const char *__restrict __format, ...);//...# 3 "hello.c"int main() {    printf("Hello World!\n");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行<code>gcc -c hello.c</code>只编译不链接，对生成hello.o执行反汇编：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">objdump <span class="token parameter variable">-DS</span> hello.o<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>部分输出：</p><pre class="line-numbers language-none"><code class="language-none">git@22373537:~ $ objdump -DS hello.ohello.o：     文件格式 elf64-x86-64Disassembly of section .text:0000000000000000 &lt;main&gt;:   0:   f3 0f 1e fa             endbr64    4:   55                      push   %rbp   5:   48 89 e5                mov    %rsp,%rbp   8:   48 8d 05 00 00 00 00    lea    0x0(%rip),%rax        # f &lt;main+0xf&gt;   f:   48 89 c7                mov    %rax,%rdi  12:   e8 00 00 00 00          call   17 &lt;main+0x17&gt;  17:   b8 00 00 00 00          mov    $0x0,%eax  1c:   5d                      pop    %rbp  1d:   c3                      ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对正常编译（加上链接）生产的可执行文件进行反汇编，部分输出如下：</p><pre class="line-numbers language-none"><code class="language-none">git@22373537:~ $ objdump -DS hellohello：     文件格式 elf64-x86-64Disassembly of section .interp:.....0000000000001149 &lt;main&gt;:    1149:       f3 0f 1e fa             endbr64     114d:       55                      push   %rbp    114e:       48 89 e5                mov    %rsp,%rbp    1151:       48 8d 05 ac 0e 00 00    lea    0xeac(%rip),%rax        # 2004 &lt;_IO_stdin_used+0x4&gt;    1158:       48 89 c7                mov    %rax,%rdi    115b:       e8 f0 fe ff ff          call   1050 &lt;puts@plt&gt;    1160:       b8 00 00 00 00          mov    $0x0,%eax    1165:       5d                      pop    %rbp    1166:       c3                      ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果直接用MIPS交叉编译工具链编译<code>hello.c</code>，其生成的可执行文件的目标架构应该是 MIPS，需使用适用于 MIPS 架构的 objdump 版本。</p><pre class="line-numbers language-none"><code class="language-none">git@22373537:~ $ mips-linux-gnu-gcc hello.c -o hellogit@22373537:~ $ objdump -DShello：     文件格式 elf32-bigobjdump: can't disassemble for architecture UNKNOWN!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">git@22373537:~ $ mips-linux-gnu-objdump -DS hellohello：     文件格式 elf32-tradbigmipsDisassembly of section .interp:......004006e0 &lt;main&gt;:  4006e0:       27bdffe0        addiu   sp,sp,-32  4006e4:       afbf001c        sw      ra,28(sp)  4006e8:       afbe0018        sw      s8,24(sp)  4006ec:       03a0f025        move    s8,sp  4006f0:       3c1c0042        lui     gp,0x42  4006f4:       279c9010        addiu   gp,gp,-28656  4006f8:       afbc0010        sw      gp,16(sp)  4006fc:       3c020040        lui     v0,0x40  400700:       24440830        addiu   a0,v0,2096  400704:       8f828030        lw      v0,-32720(gp)  400708:       0040c825        move    t9,v0  40070c:       0320f809        jalr    t9  400710:       00000000        nop  400714:       8fdc0010        lw      gp,16(s8)  400718:       00001025        move    v0,zero  40071c:       03c0e825        move    sp,s8  400720:       8fbf001c        lw      ra,28(sp)  400724:       8fbe0018        lw      s8,24(sp)  400728:       27bd0020        addiu   sp,sp,32  40072c:       03e00008        jr      ra  400730:       00000000        nop  ......<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>objdump</code>参数的意义：</p><ul><li><code>-D</code> 选项表示进行反汇编。它告诉 <code>objdump</code> 将目标文件的机器代码转换为汇编代码。</li><li><code>-S</code> 选项表示 <code>objdump</code> 会在反汇编的过程中，将机器代码与源代码进行关联，并将C语言源代码行显示在反汇编结果中。</li></ul><h5 id="Thinking-1-2"><a href="#Thinking-1-2" class="headerlink" title="Thinking 1.2"></a>Thinking 1.2</h5><p><strong>Q:</strong> </p><p>• 尝试使用我们编写的 <code>readelf</code>程序，解析之前在<code> target</code>目录下生成的内核 ELF 文件。 </p><p>• 也许你会发现我们编写的<code>readelf </code>程序是不能解析<code>readelf</code>文件本身的，而我们刚才介绍的系统工具 <code>readelf</code> 则可以解析，这是为什么呢？（提示：尝试使用<code>readelf -h</code>，并阅读 <code>tools/readelf </code>目录下的 <code>Makefile</code>，观察 <code>readelf </code>与<code>hello</code>的不同）</p><p><strong>A:</strong></p><p>使用我们自己编写的<code>readelf</code>解析内核ELF文件的结果：</p><pre class="line-numbers language-none"><code class="language-none">git@22373537:~/22373537/tools/readelf (lab1)$ ./readelf ~/22373537/target/mos 0:0x01:0x804000002:0x804016f03:0x804017084:0x804017205:0x06:0x07:0x08:0x09:0x010:0x011:0x012:0x013:0x014:0x015:0x016:0x0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>-h表示显示 ELF 文件的文件头信息（header）</p><pre class="line-numbers language-none"><code class="language-none">-h --file-header       Display the ELF file header<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>readelf</code>可执行文件是64位格式的，而<code>hello</code>是32位的</p><img src="https://s21.ax1x.com/2024/03/15/pFgLs2Q.png" width="75%"><img src="https://s21.ax1x.com/2024/03/15/pFgLr8g.png" width="75%"><p><code>tools/readelf</code>目录下的Makefile文件：</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">readelf</span><span class="token punctuation">:</span> main.o readelf.o        <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$^</span> -o <span class="token variable">$@</span><span class="token target symbol">hello</span><span class="token punctuation">:</span> hello.c        <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$^</span> -o <span class="token variable">$@</span> -m32 -static -g <span class="token comment"># m32选项生成32位可执行文件</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们自己编写的<code>readelf.c</code>文件内数据类型前缀均为<code>ELF32</code>，因此可以解析的是32位的hello，却不能解析作为64位elf的自己。</p><h5 id="Thinking-1-3"><a href="#Thinking-1-3" class="headerlink" title="Thinking 1.3"></a>Thinking 1.3</h5><p><strong>Q:</strong> 在理论课上我们了解到，MIPS 体系结构上电时，启动入口地址为 <code>0xBFC00000</code>（其实启动入口地址是根据具体型号而定的，由硬件逻辑确定，也有可能不是这个地址，但 一定是一个确定的地址），但实验操作系统的内核入口并没有放在上电启动地址，而是按照内存布局图放置。思考为什么这样放置内核还能保证内核入口被正确跳转到？（提示：思考实验中启动过程的两阶段分别由谁执行。）</p><p><strong>A:</strong> 启动的第一阶段是硬件初始化，从ROM或FLASH加载bootloader，初始化硬件，然后为软件启动做准备，做一些载入内核等工作，完成后跳转到内核入口地址，即可将CPU控制权交给内核，进入第二阶段（内核启动）。</p><p>GEMU仿真器支持直接加载ELF文件内核，所以我们要做的启动流程简化为加载内核到内存，再跳转到内核入口即可。</p><p>在实验中我们用<code>kernel.lds</code>将内核加载到正确位置，通过<code>ENTRY(_start)</code>设置设置程序入口为 _start，保证正确地跳转到内核入口。</p><h3 id="难点分析"><a href="#难点分析" class="headerlink" title="难点分析"></a>难点分析</h3><p>我认为本次实验较难的部分主要是ELF文件的解析，还有就是补全<code>prinfk</code>要看懂每一部分在做什么，此外每个目录下的<code>Makefile</code>文件也值得认真琢磨。</p><p>本次lab1课下实验首先介绍了ELF文件的结构，包括：</p><p>1.<strong>ELF头（ELF Header）</strong>，即结构体<code>Elf32_Ehdr</code>，存放ELF文件信息</p><p>2.<strong>程序头表（Program Header Table）</strong>，含有段头表项（Segment Header），即结构体<code>Elf32_Phdr</code>作为段头表中的每个条目来存储</p><p>3.<strong>节头表（Section Header Table）</strong>，含有节头表项（Section Header），即结构体<code>Elf32_Shdr</code>作为节头表中的每个条目来存储</p><p>3.<strong>段（Segment）：</strong>包含多个节</p><p>4.<strong>节（Section）：</strong> 常见的节： <code>.text</code>（代码段）、<code>.data</code>（数据段）、<code>.bss</code>（未初始化的数据段）</p><p>通过编译链接我们用C语言写的readelf.c生成readelf这个可执行文件，后者可以对32位ELF格式的文件进行简单的解析。</p><p>介绍了MIPS虚拟内存布局以及内核所处的位置；介绍了<code>kernel.lds</code> 文件（链接脚本Linker Script），用于定义目标文件在内存中的布局和排列方式（如各个节的位置）及程序入口。</p><h3 id="实验体会"><a href="#实验体会" class="headerlink" title="实验体会"></a>实验体会</h3><p>本次实验我在理解指导书内容以及实验代码上花费了大量时间，需要在众多目录和文件中找到并理解彼此的关系。首先，自己对Makefile的变量定义等不够熟悉，需要明确的是Makefile用来组织实验编写的操作系统代码；我逐渐了解到我们所编写的操作系统内核实际上是在为程序的运行提供一个基础设施/平台，我们之前编写程序，下层有操作系统；当我们在构建操作系统时下层就直接是硬件了，QEMU则负责了模拟CPU和计算机硬件。</p>]]></content>
      
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OS_lab0</title>
      <link href="/2024/03/13/lab0-shi-yan-bao-gao/"/>
      <url>/2024/03/13/lab0-shi-yan-bao-gao/</url>
      
        <content type="html"><![CDATA[<h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><h5 id="Thinking-0-1"><a href="#Thinking-0-1" class="headerlink" title="Thinking 0.1"></a>Thinking 0.1</h5><p>不一样。</p><p>创建README.txt文件后（第一次执行add之前）状态为未跟踪（Untracked）。</p><p>add+commit之后修改README.txt内容，状态为修改状态，存在未暂存的变更（Modified）。</p><h5 id="Thinking-0-2"><a href="#Thinking-0-2" class="headerlink" title="Thinking 0.2"></a>Thinking 0.2</h5><p>思考一下箭头中的 add the file 、stage the file 和 commit 分别对应的是 Git 里的哪些命令呢？</p><p>add the file: <code>git add</code></p><p>stage the file: <code>git add</code></p><p>commit the file:  <code>git commit</code></p><h5 id="Thinking-0-3"><a href="#Thinking-0-3" class="headerlink" title="Thinking 0.3"></a>Thinking 0.3</h5><p>1.代码文件 print.c 被错误删除时，应当使用什么命令将其恢复？</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> checkout print.c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2.代码文件 print.c 被错误删除后，执行了 <code>git rm print.c </code>命令，此时应当 使用什么命令将其恢复？ </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> restore <span class="token parameter variable">--staged</span> print.c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3.无关文件 hello.txt 已经被添加到暂存区时，如何在不删除此文件的前提下将其移出暂存区？</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> <span class="token function">rm</span> <span class="token parameter variable">--cached</span> hello.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="Thinking-0-4"><a href="#Thinking-0-4" class="headerlink" title="Thinking 0.4"></a>Thinking 0.4</h5><p>提交日志</p><img src="https://s21.ax1x.com/2024/03/13/pFc1UQe.png" alt="git log" width="60%"><p>进行版本回退。执行命令 <code>git reset --hard HEAD^</code> 后</p><pre class="line-numbers language-none"><code class="language-none">git@22373537:~/learnGit(master)$ git reset --hard HEAD^HEAD 现在位于 21b5f83 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>再执行<code>git log</code>，发现只剩下message为1和2的提交</p><p>找到提交说明为 1 的哈希值，执行命令 <code>git reset --hard &lt;hash&gt;</code></p><pre class="line-numbers language-none"><code class="language-none">git@22373537:~/learnGit(master)$ git reset --hard ba88651a99d7bg1088240897+6f66796561430HEAD 现在位于 ba88651 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>现在已经回到了旧版本，为了再次回到新版本，执行 <code>git reset --hard &lt;hash&gt; </code> ，再执行 git log，发现与上面的提交日志相同</p><h5 id="Thinking-0-5"><a href="#Thinking-0-5" class="headerlink" title="Thinking 0.5"></a>Thinking 0.5</h5><p>注意：&gt;&gt;是追加，&gt;是覆盖</p><p><img src="C:\Users\86182\AppData\Roaming\Typora\typora-user-images\image-20240308173453711.png" alt=">和>>"></p><h5 id="Thinking-0-6"><a href="#Thinking-0-6" class="headerlink" title="Thinking 0.6"></a>Thinking 0.6</h5><p>command（创建该test文件的命令序列）</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">touch</span> <span class="token builtin class-name">test</span><span class="token function">chmod</span> +x <span class="token builtin class-name">test</span><span class="token builtin class-name">echo</span> <span class="token builtin class-name">echo</span> Shell Start<span class="token punctuation">..</span>. <span class="token operator">&gt;</span> <span class="token builtin class-name">test</span><span class="token builtin class-name">echo</span> <span class="token builtin class-name">echo</span> <span class="token builtin class-name">set</span> a <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&gt;&gt;</span> <span class="token builtin class-name">test</span><span class="token builtin class-name">echo</span> <span class="token assign-left variable">a</span><span class="token operator">=</span><span class="token number">1</span> <span class="token operator">&gt;&gt;</span> <span class="token builtin class-name">test</span><span class="token builtin class-name">echo</span> <span class="token builtin class-name">echo</span> <span class="token builtin class-name">set</span> b <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">&gt;&gt;</span> <span class="token builtin class-name">test</span><span class="token builtin class-name">echo</span> <span class="token assign-left variable">b</span><span class="token operator">=</span><span class="token number">2</span> <span class="token operator">&gt;&gt;</span> <span class="token builtin class-name">test</span><span class="token builtin class-name">echo</span> <span class="token builtin class-name">echo</span> <span class="token builtin class-name">set</span> c <span class="token operator">=</span> a+b <span class="token operator">&gt;&gt;</span> <span class="token builtin class-name">test</span><span class="token builtin class-name">echo</span> <span class="token string">'c=$[$a+$b]'</span> <span class="token operator">&gt;&gt;</span> <span class="token builtin class-name">test</span><span class="token builtin class-name">echo</span> <span class="token string">'echo c = $c'</span> <span class="token operator">&gt;&gt;</span> <span class="token builtin class-name">test</span><span class="token builtin class-name">echo</span> <span class="token builtin class-name">echo</span> save c to ./file1 <span class="token operator">&gt;&gt;</span> <span class="token builtin class-name">test</span><span class="token builtin class-name">echo</span> <span class="token string">'echo $c&gt;file1'</span> <span class="token operator">&gt;&gt;</span> <span class="token builtin class-name">test</span><span class="token builtin class-name">echo</span> <span class="token builtin class-name">echo</span> save b to ./file2 <span class="token operator">&gt;&gt;</span> <span class="token builtin class-name">test</span><span class="token builtin class-name">echo</span> <span class="token string">'echo $b&gt;file2'</span> <span class="token operator">&gt;&gt;</span> <span class="token builtin class-name">test</span><span class="token builtin class-name">echo</span> <span class="token builtin class-name">echo</span> save a to ./file3 <span class="token operator">&gt;&gt;</span> <span class="token builtin class-name">test</span><span class="token builtin class-name">echo</span> <span class="token string">'echo $a&gt;file3'</span> <span class="token operator">&gt;&gt;</span> <span class="token builtin class-name">test</span><span class="token builtin class-name">echo</span> <span class="token builtin class-name">echo</span> save file1 file2 file3 to file4 <span class="token operator">&gt;&gt;</span> <span class="token builtin class-name">test</span><span class="token builtin class-name">echo</span> <span class="token string">'cat file1&gt;file4'</span> <span class="token operator">&gt;&gt;</span> <span class="token builtin class-name">test</span><span class="token builtin class-name">echo</span> <span class="token string">'cat file2&gt;&gt;file4'</span> <span class="token operator">&gt;&gt;</span> <span class="token builtin class-name">test</span><span class="token builtin class-name">echo</span> <span class="token string">'cat file3&gt;&gt;file4'</span> <span class="token operator">&gt;&gt;</span> <span class="token builtin class-name">test</span><span class="token builtin class-name">echo</span> <span class="token builtin class-name">echo</span> save file4 to ./result <span class="token operator">&gt;&gt;</span> <span class="token builtin class-name">test</span><span class="token builtin class-name">echo</span> <span class="token string">'cat file4&gt;&gt;result'</span> <span class="token operator">&gt;&gt;</span> <span class="token builtin class-name">test</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>test</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> Shell Start<span class="token punctuation">..</span>.<span class="token builtin class-name">echo</span> <span class="token builtin class-name">set</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token assign-left variable">a</span><span class="token operator">=</span><span class="token number">1</span><span class="token builtin class-name">echo</span> <span class="token builtin class-name">set</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token assign-left variable">b</span><span class="token operator">=</span><span class="token number">2</span><span class="token builtin class-name">echo</span> <span class="token builtin class-name">set</span> c <span class="token operator">=</span> a+b<span class="token assign-left variable">c</span><span class="token operator">=</span>$<span class="token punctuation">[</span><span class="token variable">$a</span>+<span class="token variable">$b</span><span class="token punctuation">]</span><span class="token builtin class-name">echo</span> c <span class="token operator">=</span> <span class="token variable">$c</span><span class="token builtin class-name">echo</span> save c to ./file1<span class="token builtin class-name">echo</span> <span class="token variable">$c</span><span class="token operator">&gt;</span>file1<span class="token builtin class-name">echo</span> save b to ./file2<span class="token builtin class-name">echo</span> <span class="token variable">$b</span><span class="token operator">&gt;</span>file2<span class="token builtin class-name">echo</span> save a to ./file3<span class="token builtin class-name">echo</span> <span class="token variable">$a</span><span class="token operator">&gt;</span>file1<span class="token builtin class-name">echo</span> save file1 file2 file3 to file4<span class="token function">cat</span> file<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span>file4<span class="token function">cat</span> file<span class="token operator"><span class="token file-descriptor important">2</span>&gt;&gt;</span>file4<span class="token function">cat</span> file<span class="token operator"><span class="token file-descriptor important">3</span>&gt;&gt;</span>file4<span class="token builtin class-name">echo</span> save file4 to ./result<span class="token function">cat</span> file<span class="token operator"><span class="token file-descriptor important">4</span>&gt;&gt;</span>result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 控制台输出</p><pre class="line-numbers language-none"><code class="language-none">git@22373537:~/learnGit(master)$ ./testShell Start.set a=1set b=2set c= a+bc=3save c to ./file1save b to ./file2save a to ./file3save filel file2 file3 to file4save file4 to ./result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>result 内容</p><pre class="line-numbers language-none"><code class="language-none">321<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><img src="C:\Users\86182\AppData\Roaming\Typora\typora-user-images\image-20240310233959207.png" alt="image-20240310233959207" style="float : left;zoom:47%;"><p><code>echo 'c=$[$a+$b]'</code>  用单引号防止Shell解释变量。或用<code>\</code>转义：<code>echo "c=\$[\$a+\$b]"</code>，反正双引号不行。<code>echo 'echo c = $c' </code>同理。</p><p>命令<code>echo echo $c &gt; file1</code>将字符串”echo $c”写入file1文件。</p><p>命令<code>echo `echo $c&gt; file1` </code> 反引号进行命令替换，被替换后本身不输出内容，故输出echo自带的换行。</p><h5 id="Exercise-0-3"><a href="#Exercise-0-3" class="headerlink" title="Exercise 0.3"></a>Exercise 0.3</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">grep</span> <span class="token parameter variable">-n</span> <span class="token string">"<span class="token variable">$2</span>"</span> <span class="token variable">$1</span> <span class="token operator">|</span> <span class="token function">cut</span> -d: <span class="token parameter variable">-f1</span> <span class="token operator">&gt;</span> <span class="token variable">$3</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>-f1</code> 表示提取每行的第1个字段</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">grep</span> <span class="token parameter variable">-n</span> <span class="token string">"<span class="token variable">$2</span>"</span> <span class="token variable">$1</span> <span class="token operator">|</span> <span class="token function">awk</span> -F: <span class="token string">'{print $1}'</span> <span class="token operator">&gt;</span> <span class="token variable">$3</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>-F </code>选项用来指定用于分隔的字符，默认是空格。所以该命令的 $1 就是用“:”分隔 的第1项了。</p><h5 id="Exercise-0-4"><a href="#Exercise-0-4" class="headerlink" title="Exercise 0.4"></a>Exercise 0.4</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">from</span><span class="token operator">=</span><span class="token variable">$2</span><span class="token assign-left variable">to</span><span class="token operator">=</span><span class="token variable">$3</span><span class="token function">sed</span> <span class="token parameter variable">-i</span> <span class="token string">"s/<span class="token variable">${from}</span>/<span class="token variable">${to}</span>/g"</span> <span class="token variable">$1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里必须是双引号，因为要解析里面的变量（变量在单引号中不会被展开）。</p><h3 id="难点分析"><a href="#难点分析" class="headerlink" title="难点分析"></a>难点分析</h3><ul><li><p>最初我对grep，sed，awk各自的功能不够了解导致不知道该使用哪种指令来处理文本。grep搜索匹配某个模式的行，sed对文本进行各种编辑操作，awk可以分割字段处理且可以执行更为复杂的操作。</p></li><li><p>单双引号和反引号的使用：</p><p>单引号内所有字符都被当作普通字符对待，而双引号会解析变量和特殊字符（如<code>$</code>,<code>\</code>）</p><p>反引号或 <code>$()</code> 进行命令替换。执行命令，并将命令的输出插入到命令行中。</p></li><li><p>对git理解不够深入，还需要勤加练习。shell语言中的各种括号语法也需要注意，感觉有很多细节还是与平时使用的高级语言有不小的差异。</p></li></ul><h3 id="实验体会"><a href="#实验体会" class="headerlink" title="实验体会"></a>实验体会</h3><p>学习了一些基本的bash指令，vim编辑器的使用，Makefile的编写，git的基本操作等等，补充了一些编译链接和MIPS的相关知识。</p><p>本次实验学习了很多工具的使用，东西比较杂，可以说是为以后的lab打好基础。然而我感觉自己很多操作依然不够熟练，此后还是要争取花更多时间学习os（悲</p><h3 id="Lab0上机"><a href="#Lab0上机" class="headerlink" title="Lab0上机"></a>Lab0上机</h3><h4 id="exam"><a href="#exam" class="headerlink" title="exam"></a>exam</h4><p> <code>gcc -c</code> (只编译不链接，生成目标文件）默认情况下，目标文件命名为源文件的名称的扩展名（例如<code>.c</code>）替换为<code>.o</code>。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gcc <span class="token parameter variable">-c</span> *.c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="extra"><a href="#extra" class="headerlink" title="extra"></a>extra</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># Your code here. (3/3)</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">0</span><span class="token keyword">while</span> <span class="token variable"><span class="token punctuation">((</span>$PID <span class="token operator">&gt;</span> $i<span class="token punctuation">))</span></span><span class="token keyword">do</span><span class="token function">awk</span> <span class="token parameter variable">-v</span> <span class="token assign-left variable">input</span><span class="token operator">=</span><span class="token variable">$PID</span>  <span class="token string">'input==$2 {print $3}'</span> <span class="token string">"<span class="token variable">$FILE</span>"</span><span class="token assign-left variable">PID</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">awk</span> <span class="token parameter variable">-v</span> <span class="token assign-left variable">input</span><span class="token operator">=</span>$PID  <span class="token string">'input==$2 {print $3}'</span> <span class="token string">"<span class="token variable">$FILE</span>"</span><span class="token variable">`</span></span><span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我一开始的时候写错了input==$2写错了</p>]]></content>
      
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HelloBlog</title>
      <link href="/2023/02/04/helloblog/"/>
      <url>/2023/02/04/helloblog/</url>
      
        <content type="html"><![CDATA[<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h2 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h2><p>whale梦拓是个好梦拓。</p>]]></content>
      
      
      
        <tags>
            
            <tag> try </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
